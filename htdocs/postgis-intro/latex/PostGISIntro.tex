%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Introduction to PostGIS}
\date{January 08, 2020}
\release{2.0}
\author{Mayra Zurbaran, Mark Leslie, Paul Ramsey}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Welcome}
\label{\detokenize{welcome:welcome}}\label{\detokenize{welcome:id1}}\label{\detokenize{welcome::doc}}

\section{Workshop Conventions}
\label{\detokenize{welcome:workshop-conventions}}
These sections conform to a number of conventions to make it easier to follow the conversation. This section gives a brief overview of what to expect in the way of typographic conventions, as well as a short overview of the structure of each workbook.


\subsection{Directions}
\label{\detokenize{welcome:directions}}
Directions for you, the workshop attendee, will be noted by \sphinxstylestrong{bold} font.

For example:
\begin{quote}

Click \sphinxstylestrong{Next} to continue.
\end{quote}


\subsection{Code}
\label{\detokenize{welcome:code}}
SQL query examples will be displayed in an offset box

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{postgis\PYGZus{}full\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

These examples can be entered into the query window or command line interface.


\subsection{Notes}
\label{\detokenize{welcome:notes}}
Notes are used to provide information that is useful but not critical to the overall understanding of the topic.

\begin{sphinxadmonition}{note}{Note:}
If you haven’t eaten an apple today, the doctor may be on the way.
\end{sphinxadmonition}


\subsection{Functions}
\label{\detokenize{welcome:functions}}
Where function names are defined in the text, they will be rendered in a \sphinxstyleliteralstrong{\sphinxupquote{bold}} font.

For example:
\begin{quote}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Touches(geometry A, geometry B)}} returns TRUE if either of the geometries’ boundaries intersect
\end{quote}


\subsection{Files, Tables and Column Names}
\label{\detokenize{welcome:files-tables-and-column-names}}
File names, paths, table names and column names will be shown in \sphinxcode{\sphinxupquote{fixed-width}} font.

For example:
\begin{quote}

Select the \sphinxcode{\sphinxupquote{name}} column in the \sphinxcode{\sphinxupquote{nyc\_streets}} table.
\end{quote}


\subsection{Menus and Form elements}
\label{\detokenize{welcome:menus-and-form-elements}}
Menus/submenus and form elements such as fields or check boxes and other on-screen artifacts are displayed in \sphinxstyleemphasis{italics}.

For example:
\begin{quote}

Click on the \sphinxstyleemphasis{File \textgreater{} New} menu. Check the box that says \sphinxstyleemphasis{Confirm}.
\end{quote}


\subsection{Workflow}
\label{\detokenize{welcome:workflow}}
Sections are designed to be progressive. Each section will start with the assumption that you have completed and understood the previous section in the series and will build on that knowledge. A single section will progress through a handful of ideas and provide working examples wherever possible. At the end of a section, where appropriate, we have included a handful of exercises to allow you to try out the ideas we’ve presented. In some cases the section will include “Things To Try”. These tasks contain more complex problems than the exercises and is designed to challenge participants with advanced knowledge.


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction:id1}}\label{\detokenize{introduction::doc}}

\section{What is a Spatial Database?}
\label{\detokenize{introduction:what-is-a-spatial-database}}
PostGIS is a spatial database. Oracle Spatial and SQL Server (2008 and later) are also spatial databases. But what does that mean; what is it that makes an ordinary database a spatial database?

The short answer, is…

\sphinxstylestrong{Spatial databases store and manipulate spatial objects like any other object in the database.}

The following briefly covers the evolution of spatial databases, and then reviews three aspects that associate \sphinxstyleemphasis{spatial} data with a database \textendash{} data types, indexes, and functions.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Spatial data types} refer to shapes such as point, line, and polygon;

\item {} 
Multi-dimensional \sphinxstylestrong{spatial indexing} is used for efficient processing of spatial operations;

\item {} 
\sphinxstylestrong{Spatial functions}, posed in {\hyperref[\detokenize{glossary:term-sql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SQL}}}}, are for querying of spatial properties and relationships.

\end{enumerate}

Combined, spatial data types, indexes, and functions provide a flexible structure for optimized performance and analysis.


\subsection{In the Beginning}
\label{\detokenize{introduction:in-the-beginning}}
In legacy first-generation {\hyperref[\detokenize{glossary:term-gis}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIS}}}} implementations, all spatial data was stored in flat files and special {\hyperref[\detokenize{glossary:term-gis}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIS}}}}
software was required to interpret and manipulate the data. These first-generation management systems were designed to meet the needs of users where all required data is within the user’s organizational domain. They are proprietary, self-contained systems specifically built for handling spatial data.

Second-generation spatial systems store some data in relational databases (usually the “attribute” or non-spatial parts) but still lack the flexibility afforded with direct integration.

\sphinxstylestrong{True spatial databases were born when people started to treat spatial features as first class database objects.}

Spatial databases fully integrate spatial data with an object relational database. The orientation changed from GIS-centric to database-centric.

\noindent\sphinxincludegraphics{{beginning}.png}

\begin{sphinxadmonition}{note}{Note:}
Where ADT stands for Abstract Data Type, a mathematical model for data types. In addition, A spatial database management system may be used in applications besides the geographic world.  Spatial databases are used to manage data related to the anatomy of the human body, large-scale integrated circuits, molecular structures, and electro-magnetic fields, among others.
\end{sphinxadmonition}


\subsection{Spatial Data Types}
\label{\detokenize{introduction:spatial-data-types}}
An ordinary database has strings, numbers, and dates. A spatial database adds additional (spatial) types for representing \sphinxstylestrong{geographic features}. These spatial data types abstract and encapsulate spatial structures such as boundary and dimension. In many respects, spatial data types can be understood simply as shapes.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{hierarchy}.png}\hspace*{\fill}}

Spatial data types are organized in a type hierarchy.  Each sub-type inherits the structure (attributes) and the behavior (methods or functions) of its super-type.


\subsection{Spatial Indexes and Bounding Boxes}
\label{\detokenize{introduction:spatial-indexes-and-bounding-boxes}}
An ordinary database provides “access methods” \textendash{} commonly known as \sphinxstylestrong{indexes} \textendash{} to allow for fast and random access to subsets of data.  Indexing for standard types (numbers, strings, dates) is usually done with \sphinxhref{http://en.wikipedia.org/wiki/B-tree}{B-tree} indexes.  A B-tree partitions the data using the natural sort order to put the data into a hierarchical tree.

The natural sort order of numbers, strings, and dates is simple to determine \textendash{} every value is less than, greater than or equal to every other value. But because polygons can overlap, can be contained in one another, and are arrayed in a two-dimensional (or more) space, a B-tree cannot be used to efficiently index them. Real spatial databases provide a “spatial index” that instead answers the question “which objects are within this particular bounding box?”.

A \sphinxstylestrong{bounding box} is the smallest rectangle \textendash{} parallel to the coordinate axes \textendash{} capable of containing a given feature.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{boundingbox}.png}\hspace*{\fill}}

Bounding boxes are used because answering the question “is A inside B?” is very computationally intensive for polygons but very fast in the case of rectangles.  Even the most complex polygons and linestrings can be represented by a simple bounding box.

Indexes have to perform quickly in order to be useful. So instead of providing exact results, as B-trees do, spatial indexes provide approximate results. The question “what lines are inside this polygon?” will be instead interpreted by a spatial index as “what lines have bounding boxes that are contained inside this polygon’s bounding box?”

The actual spatial indexes implemented by various databases vary widely. The most common implementation is the \sphinxhref{http://en.wikipedia.org/wiki/R-tree}{R-tree} (used in PostGIS), but there are also \sphinxhref{http://en.wikipedia.org/wiki/Quadtree}{Quadtrees}, and \sphinxhref{http://en.wikipedia.org/wiki/Grid\_(spatial\_index)}{grid-based indexes} implemented in other spatial databases.


\subsection{Spatial Functions}
\label{\detokenize{introduction:spatial-functions}}
For manipulating data during a query, an ordinary database provides \sphinxstylestrong{functions} such as concatenating strings, performing hash operations on strings, doing mathematics on numbers, and extracting information from dates.  A spatial database provides a complete set of functions for analyzing geometric components, determining spatial relationships, and manipulating geometries.  These spatial functions serve as the building block for any spatial project.

The majority of all spatial functions can be grouped into one of the following five categories:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Conversion}: Functions that \sphinxstyleemphasis{convert} between geometries and external data formats.

\item {} 
\sphinxstylestrong{Management}: Functions that \sphinxstyleemphasis{manage} information about spatial tables and PostGIS administration.

\item {} 
\sphinxstylestrong{Retrieval}: Functions that \sphinxstyleemphasis{retrieve} properties and measurements of a Geometry.

\item {} 
\sphinxstylestrong{Comparison}: Functions that \sphinxstyleemphasis{compare} two geometries with respect to their spatial relation.

\item {} 
\sphinxstylestrong{Generation}: Functions that \sphinxstyleemphasis{generate} new geometries from others.

\end{enumerate}

The list of possible functions is very large, but a common set of functions is defined by the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} and implemented (along with additional useful functions) by PostGIS.


\section{What is PostGIS?}
\label{\detokenize{introduction:what-is-postgis}}
PostGIS turns the \sphinxhref{http://www.postgresql.org/}{PostgreSQL} Database Management System into a spatial database by adding support for the three features: spatial types, indexes, and functions.  Because it is built on PostgreSQL, PostGIS automatically inherits important “enterprise” features as well as open standards for implementation


\subsection{But what is PostgreSQL?}
\label{\detokenize{introduction:but-what-is-postgresql}}
PostgreSQL is a powerful, object-relational database management system (ORDBMS). It is released under a BSD-style license and is thus free and open source software. As with many other open source programs, PostgreSQL is not controlled by any single company, but has a global community of developers and companies to develop it.

PostgreSQL was designed from the very start with type extension in mind \textendash{} the ability to add new data types, functions and access methods at run-time. Because of this, the PostGIS extension can be developed by a separate development team, yet still integrate very tightly into the core PostgreSQL database.


\subsubsection{Why choose PostgreSQL?}
\label{\detokenize{introduction:why-choose-postgresql}}
PostgreSQL has:
\begin{itemize}
\item {} 
Proven reliability and transactional integrity by default (ACID)

\item {} 
Careful support for SQL standards (full SQL92)

\item {} 
Pluggable type extension and function extension

\item {} 
Community-oriented development model

\item {} 
No limit on column sizes (“TOAST”able tuples) to support big GIS objects

\item {} 
Generic index structure (GiST) to allow R-Tree index

\item {} 
Easy to add custom functions

\end{itemize}

Combined, PostgreSQL provides a very easy development path to add new spatial types. In the propietary world, Illustra is a proprietary re-working of the original PostgreSQL code base from the 1980’s.

Because the development path for adding types to PostgreSQL was so straightforward, it made sense to start there. When MySQL released basic spatial types in version 4.1, the PostGIS team took a look at their code, and the exercise reinforced the original decision to use PostgreSQL. Because MySQL spatial objects had to be hacked on top of the string type as a special case, the MySQL code was spread over the entire code base. Development of PostGIS 0.1 took under a month. Doing a “MyGIS” 0.1 would have taken a lot longer, and as such, might never have seen the light of day.


\subsection{Why not Shapefiles?}
\label{\detokenize{introduction:why-not-shapefiles}}
The \sphinxhref{http://en.wikipedia.org/wiki/Shapefile}{shapefile} (and other file formats) have been the standard way of storing and interacting with spatial data since GIS software was first written. However, these “flat” files have the following disadvantages:
\begin{itemize}
\item {} 
\sphinxstylestrong{Files require special software to read and write.}  SQL is an abstraction for random data access and analysis. Without that abstraction, you will need to write all the access and analysis code yourself.

\item {} 
\sphinxstylestrong{Concurrent users can cause corruption.} While it’s possible to write extra code to ensure that multiple writes to the same file do not corrupt the data, by the time you have solved the problem and also solved the associated performance problem, you will have written the better part of a database system. Why not just use a standard database?

\item {} 
\sphinxstylestrong{Complicated questions require complicated software to answer.} Complicated and interesting questions (spatial joins, aggregations, etc) that are expressible in one line of SQL in the database take hundreds of lines of specialized code to answer when programming against files. This is now improved with the use of \sphinxhref{http://geopandas.org/}{GeoPandas}.

\end{itemize}

Most users of PostGIS are setting up systems where multiple applications will be expected to access the data, so having a standard SQL access method simplifies deployment and development. Some users are working with large data sets; with files, they might be segmented into multiple files, but in a database they can be stored as a single large table.

In summation, the combination of support for multiple users, complex ad hoc queries, and performance on large data sets are what sets spatial databases apart from file-based systems.


\subsection{A brief history of PostGIS}
\label{\detokenize{introduction:a-brief-history-of-postgis}}
In the May of 2001, \sphinxhref{http://www.refractions.net/}{Refractions Research}  released the first version of PostGIS. PostGIS 0.1 had objects, indexes and a handful of functions. The result was a database suitable for storage and retrieval, but not analysis.

As the number of functions increased, the need for an organizing principle became clear.  The “Simple Features for SQL” ({\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}}) specification from the Open Geospatial Consortium provided such structure with guidelines for function naming and requirements.

With PostGIS support for simple analysis and spatial joins, \sphinxhref{http://mapserver.org/}{Mapserver} became the first external application to provide visualization of data in the database.

Over the next several years the number of PostGIS functions grew, but its power remained limited. Many of the most interesting functions (e.g., ST\_Intersects(), ST\_Buffer(), ST\_Union()) were very difficult to code.  Writing them from scratch promised years of work.

Fortunately a second project, the “Geometry Engine, Open Source” or \sphinxhref{http://trac.osgeo.org/geos}{GEOS}, came along. The GEOS library provides the necessary algorithms for implementing the {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} specification. By linking in GEOS, PostGIS provided complete support for {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} by version 0.8.

As PostGIS data capacity grew, another issue surfaced: the representation used to store geometry proved relatively inefficient. For small objects like points and short lines, the metadata in the representation had as much as a 300\% overhead. For performance reasons, it was necessary to put the representation on a diet.  By shrinking the metadata header and required dimensions, overhead greatly reduced. In PostGIS 1.0, this new, faster, lightweight representation became the default.

Recent updates of PostGIS have worked on expanding standards compliance, adding support for curve-based geometries and function signatures specified in the ISO {\hyperref[\detokenize{glossary:term-sql-mm}]{\sphinxtermref{\DUrole{xref,std,std-term}{SQL/MM}}}} standard. Through a continued focus on performance,  PostGIS 1.4 significantly improved the speed of geometry testing routines.


\subsection{Who uses PostGIS?}
\label{\detokenize{introduction:who-uses-postgis}}
For a complete list of case studies, see the \sphinxhref{http://postgis.net/casestudy}{PostGIS case studies} page.


\subsubsection{Institut Geographique National, France}
\label{\detokenize{introduction:institut-geographique-national-france}}
IGN is the national mapping agency of France, and uses PostGIS to store the high resolution topographic map of the country, “BDUni”. BDUni has more than 100 million features, and is maintained by a staff of over 100 field staff who verify observations and add new mapping to the database daily. The IGN installation uses the database transactional system to ensure consistency during update processes, and a \sphinxhref{http://developer.postgresql.org/pgdocs/postgres/warm-standby.html}{warm standby system} to maintain uptime in the event of a system failure.


\subsubsection{GlobeXplorer}
\label{\detokenize{introduction:globexplorer}}
GlobeXplorer is a web-based service providing online access to petabytes of global satellite and aerial imagery. GlobeXplorer uses PostGIS to manage the metadata associated with the imagery catalogue, so queries for imagery first search the PostGIS catalogue to find the location of the relevant images, then pull the images from storage and return them to the client. In building their system, GlobeXplorer tried other spatial databases but eventually settled on PostGIS because of the great combination of price and performance it offers.


\subsection{What applications support PostGIS?}
\label{\detokenize{introduction:what-applications-support-postgis}}
PostGIS has become a widely used spatial database, and the number of third-party programs that support storing and retrieving data using it has increased as well. The \sphinxhref{http://trac.osgeo.org/postgis/wiki/UsersWikiToolsSupportPostgis}{programs that support PostGIS} include both open source and proprietary software on both server and desktop systems.

The following table shows a list of some of the software that leverages PostGIS:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Open/Free
&\sphinxstyletheadfamily 
Closed/Proprietary
\\
\hline\begin{itemize}
\item {} 
Loading/Extracting
\begin{itemize}
\item {} 
Shp2Pgsql

\item {} 
ogr2ogr

\item {} 
Dxf2PostGIS

\end{itemize}

\item {} 
Web-Based
\begin{itemize}
\item {} 
Mapserver

\item {} 
GeoServer (Java-based WFS / WMS -server )

\item {} 
SharpMap SDK - for ASP.NET 2.0

\item {} 
MapGuide Open Source (using FDO)

\end{itemize}

\item {} 
Desktop
\begin{itemize}
\item {} 
uDig

\item {} 
QGIS

\item {} 
mezoGIS

\item {} 
OpenJUMP

\item {} 
OpenEV

\item {} 
SharpMap SDK for Microsoft.NET 2.0

\item {} 
GvSIG

\item {} 
GRASS

\end{itemize}

\end{itemize}
&\begin{itemize}
\item {} 
Loading/Extracting
\begin{itemize}
\item {} 
Safe FME Desktop Translator/Converter

\end{itemize}

\item {} 
Web-Based
\begin{itemize}
\item {} 
Ionic Red Spider (now ERDAS)

\item {} 
Cadcorp GeognoSIS

\item {} 
Iwan Mapserver

\item {} 
MapDotNet Server

\item {} 
MapGuide Enterprise (using FDO)

\item {} 
ESRI ArcGIS Server 9.3+

\end{itemize}

\item {} 
Desktop
\begin{itemize}
\item {} 
Cadcorp SIS

\item {} 
Microimages TNTmips GIS

\item {} 
ESRI ArcGIS 9.3+

\item {} 
Manifold

\item {} 
GeoConcept

\item {} 
MapInfo (v10)

\item {} 
AutoCAD Map 3D (using FDO)

\end{itemize}

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\chapter{Learning Outcomes}
\label{\detokenize{instructions:learning-outcomes}}\label{\detokenize{instructions::doc}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Get familiar with the web user interface that PGAdmin 4 offers to perform SQL operations on a PostgreSQL database and install the PostGIS extension.

\item {} 
Learn PostGIS geometry types, geography, spatial reference identifiers (SRID), and projections.

\item {} 
Use the spatial extension PostGIS to move spatial data in and out of a PostgreSQL database, taking advantage of the QGIS DB Manager and GDAL/OGR commands to handle raster and vector layers.

\item {} 
Understand and use spatial indexing.

\item {} 
Perform spatial calculations with vector data stored as PotGIS geometries or geography.

\item {} 
Use spatial operations to validate and simplify geometries.

\item {} 
Perform GIS analysis by using spatial joins.

\item {} 
Explore raster data information and perform simple analysis by combining geometries with rasters.

\item {} 
Perform nearest-neighbour search (NNS).

\item {} 
Use PGRouting for basic routing algorithms in a graph structure stored in a PostgreSQL+PostGIS database.

\item {} 
Connect QGIS and a PostgreSQL+PostGIS database to visualize and process spatial data.

\end{enumerate}


\section{Prerequisite Knowledge}
\label{\detokenize{instructions:prerequisite-knowledge}}
For this training it is required an understanding of relational databases, tables, indexing, and the SQL language. Overall knowledge of spatial data formats and features is also necessary.
Basic knowledge of the use of QGIS is desired for handling, visualizing, and styling vector and rasters layers.


\section{Educational Approach}
\label{\detokenize{instructions:educational-approach}}
The proposed training will be based on a hands-on approach that encourages the reader to follow each exercise step by step at his/her pace. The material will be provided with practices starting with an introduction to a real life scenario using datasets from current sources.
Each practice will contain screenshots that accompany each step of the exercises to minimize the risk of lack of completion by the trainee due to misinterpretation. In addition, the course will be assisted through a collaborative platform where trainees can exchange their experiences, issues, and successes in relation to every practice.


\chapter{Setup Instructions}
\label{\detokenize{setup:setup-instructions}}\label{\detokenize{setup::doc}}

\section{Installation}
\label{\detokenize{setup:installation}}\label{\detokenize{setup:id1}}
PostGIS is an extension for the PostgreSQL database to deal with spatial data, so in order to use it we first need an installation of the database engine. The following instructions will guide you using the PostGIS binary installers available from the official project site: \sphinxurl{https://postgis.net/install/}. There are options for multiple platforms.


\subsection{Windows}
\label{\detokenize{installation_win:windows}}\label{\detokenize{installation_win:installation-win}}\label{\detokenize{installation_win::doc}}
For Windows, there is the EnterpriseDB PostgreSQL distributions: \sphinxurl{https://www.postgresql.org/download/windows/}, an interactive installer that will provide the option for installing PostGIS in an installation dialog with “Stack Builder”:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
First install PostgreSQL with the EDB installer:

\noindent\sphinxincludegraphics{{windows01}.PNG}

\item {} 
Follow the installation process leaving the directories as they are by default and make sure all components (postgreSQL Server, pgAdmin 4, Stack Builder and Command Line Tools) are selected to install.

\noindent\sphinxincludegraphics{{windows03}.PNG}

\item {} 
Set a password that you will use later for login. You may use \sphinxcode{\sphinxupquote{postgres}}.

\noindent\sphinxincludegraphics{{windows05}.PNG}

\item {} 
Leave the default port to 5432:

\noindent\sphinxincludegraphics{{windows06}.PNG}

\item {} 
At the end of the PostgreSQL installation check the option to launch Stack Builder. This will continue to install PostGIS.

\noindent\sphinxincludegraphics{{windows09}.PNG}

\item {} 
Select the recent PostgreSQL installation:

\noindent\sphinxincludegraphics{{windows10}.PNG}

\item {} 
Search for PostGIS under \sphinxstylestrong{Spatial Extensions} and check it.

\noindent\sphinxincludegraphics{{windows11}.PNG}

\item {} 
Follow the installation process and click on \sphinxstylestrong{I Agree} in the License Agreement step:

\noindent\sphinxincludegraphics{{windows14}.PNG}

\item {} 
Choose the PostGIS component:

\noindent\sphinxincludegraphics{{windows15}.PNG}

\item {} 
Leave the default directories, \sphinxstylestrong{agree to registering the GDAL\_DATA environment variable, enable raster drivers, and complete} the installation:

\noindent\sphinxincludegraphics{{windows20}.PNG}

\item {} 
Go to \sphinxstylestrong{Start} and look for the PostgreSQL folder where pgAdmin 4 will be located. Open it and set a password to login everytime.

\end{enumerate}


\subsection{Mac OS X}
\label{\detokenize{installation_mac:mac-os-x}}\label{\detokenize{installation_mac:installation-mac}}\label{\detokenize{installation_mac::doc}}
For OSX users it is possile to install PostGIS along with PostgreSQL using the Postgres app: \sphinxurl{http://postgresapp.com/}. This is the easiest way to do the installation but you can also use the EnterpriseDb installer: \sphinxurl{https://www.enterprisedb.com/downloads/postgres-postgresql-downloads} or the homebrew installer if you are familiar with it by running the command: \sphinxcode{\sphinxupquote{brew install postgis}}.

The following steps will guide you in the installation using Postgres.app:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download the dmg file: \sphinxurl{https://postgresapp.com/downloads.html}.

\item {} 
Drag the Postgres icon into your applications folder.

\end{enumerate}
\begin{quote}

\noindent\sphinxincludegraphics{{installosx1}.png}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Double click the application and allow it to be opened:

\end{enumerate}
\begin{quote}

\noindent\sphinxincludegraphics{{installosx2}.png}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Click initialize to start the process.

\noindent\sphinxincludegraphics{{installosx3}.png}

\item {} 
If successful, you will see the databases available to connect to, this means that the database engine is up and running. By clicking the icons of the databases you will be prompted to a command line but for this course, the user interface pgAdmin 4 will be preferred.

\noindent\sphinxincludegraphics{{installosx4}.png}

\end{enumerate}


\subsubsection{Install pgAdmin 4}
\label{\detokenize{installation_mac:install-pgadmin-4}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Go to: \sphinxurl{https://www.pgadmin.org/download/} to get pgAdmin 4 for \sphinxstylestrong{Mac OS X}. Double click the installer and agree to the terms by clicking \sphinxstylestrong{Agree}.

\noindent\sphinxincludegraphics{{installpgadmin1}.png}

\item {} 
For \sphinxstylestrong{Mac OS X} drag the pgAdmin 4 icon to your applications folder.

\noindent\sphinxincludegraphics{{installpgadmin2}.png}

\item {} 
Open the installed application and allow it to run:

\noindent\sphinxincludegraphics{{installpgadmin3}.png}

\item {} 
pgAdmin 4 is web-based so a tab will open in your browser window. The first time, it will prompt for a master password to use, set one, then enter it to see the servers.

\end{enumerate}


\subsection{Linux (Ubuntu 18.04 / Debian 10 Linux distribution)}
\label{\detokenize{installation_linux:linux-ubuntu-18-04-debian-10-linux-distribution}}\label{\detokenize{installation_linux:installation-linux}}\label{\detokenize{installation_linux::doc}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
An installation of PostgreSQL is required before we can add the PostGIS spatial extension. To begin, first update and upgrade the packages from the terminal, you will need to reboot after this.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{upgrade}
\PYG{n}{sudo} \PYG{n}{reboot}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Now, you’re ready to add the APT repository to install PostgreSQL:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{install} \PYG{n}{gnupg2}
\PYG{n}{wget} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{quiet} \PYG{o}{\PYGZhy{}}\PYG{n}{O} \PYG{o}{\PYGZhy{}} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{postgresql}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{media}\PYG{o}{/}\PYG{n}{keys}\PYG{o}{/}\PYG{n}{ACCC4CF8}\PYG{o}{.}\PYG{n}{asc} \PYG{o}{\textbar{}} \PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{add} \PYG{o}{\PYGZhy{}}
\PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deb http://apt.postgresql.org/pub/repos/apt/ {}`lsb\PYGZus{}release \PYGZhy{}cs{}`\PYGZhy{}pgdg main}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\textbar{}}\PYG{n}{sudo} \PYG{n}{tee}  \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{sources}\PYG{o}{.}\PYG{n}{list}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/}\PYG{n}{pgdg}\PYG{o}{.}\PYG{n}{list}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Verify the repository files content:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cat} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{sources}\PYG{o}{.}\PYG{n}{list}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/}\PYG{n}{pgdg}\PYG{o}{.}\PYG{n}{list}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install PostgreSQL 11:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{install} \PYG{n}{postgresql}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
After the installation of PostgreSQL, we’re ready to proceed to install PostGIS.

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{postgis} \PYG{n}{postgresql}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{n}{postgis}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
For installing the web interface PGAdmin 4 enter the following commands:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{pgadmin4} \PYG{n}{pgadmin4}\PYG{o}{\PYGZhy{}}\PYG{n}{apache2}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
During the installation set a password for the \sphinxcode{\sphinxupquote{postgres}} user. You may use \sphinxcode{\sphinxupquote{postgres}} for local purposes.

\noindent\sphinxincludegraphics{{pgadmin_linux1}.png}

\item {} 
Test opening the PGAdmin interface. The first time, it will prompt for a master password to use, set one, then enter it to see the servers.

\end{enumerate}


\section{Creating a Spatial Database}
\label{\detokenize{setup:creating-a-spatial-database}}\label{\detokenize{setup:creating-db}}

\subsection{PgAdmin}
\label{\detokenize{setup:pgadmin}}
PostgreSQL has a number of administrative front-ends.  The primary one is \sphinxhref{http://www.postgresql.org/docs/current/static/app-psql.html}{psql} a command-line tool for entering SQL queries.  Another popular PostgreSQL front-end is the free and open source graphical tool \sphinxhref{http://www.pgadmin.org/}{pgAdmin}. All queries done in pgAdmin can also be done on the command line with \sphinxcode{\sphinxupquote{psql}}.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Find pgAdmin and start it up. If it is the first time you are running it, it will ask you to set up a master password, this will allow you to log in to pgAdmin everytime and connect to servers.

\noindent\sphinxincludegraphics{{pgadmin_00}.png}

\item {} 
Afterwards it will show you a list of servers. Click on \sphinxstylestrong{Servers} to view the active servers.

\noindent\sphinxincludegraphics{{pgadminstart}.png}

\item {} 
If this is the first time you have run pgAdmin, you should have a server entry for \sphinxstylestrong{PostGIS (localhost:5432)} already configured in pgAdmin. Click to display the databases in it.

The PostGIS database has been installed with unrestricted access for local users (users connecting from the same machine as the database is running). That means that it will accept \sphinxstyleemphasis{any} password you provide. If you need to connect from a remote computer, the password for the \sphinxcode{\sphinxupquote{postgres}} user has been set to \sphinxcode{\sphinxupquote{postgres}}.

\end{enumerate}


\subsection{Creating a Database}
\label{\detokenize{setup:creating-a-database}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Open the Databases tree item and have a look at the available databases.  The \sphinxcode{\sphinxupquote{postgres}} database is the user database for the default postgres user. It is created in the initialization \sphinxcode{\sphinxupquote{ìnitdb}} as a new PostgreSQL database cluster. A database cluster is a collection of databases that are managed by a single server instance. Creating a database cluster consists of creating the directories in which the database data will live, generating the shared catalog tables (tables that belong to the whole cluster rather than to any particular database), and creating the template1 and postgres databases. When you later create a new database, everything in the template1 database is copied. Therefore, anything installed in template1 is automatically copied into each database created later. The postgres database is a default database meant for use by users, utilities and third party applications.

\item {} 
Right-click on the \sphinxcode{\sphinxupquote{Databases}} item and select \sphinxcode{\sphinxupquote{New Database}}.

\noindent\sphinxincludegraphics{{pgadmin_03}.png}

\item {} 
Fill in the \sphinxcode{\sphinxupquote{New Database}} form as shown below and click \sphinxstylestrong{OK}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{Name}
&
\sphinxcode{\sphinxupquote{nyc}}
\\
\hline
\sphinxstylestrong{Owner}
&
\sphinxcode{\sphinxupquote{postgres}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\noindent\sphinxincludegraphics{{pgadmin_02}.png}

\item {} 
Select the new \sphinxcode{\sphinxupquote{nyc}} database and open it up to display the tree of objects. Where the parent \sphinxcode{\sphinxupquote{nyc}} is the database. The objects contained within it allow to understand the components of this database like showing the extisting \sphinxhref{https://www.postgresql.org/docs/9.2/sql-createcast.html}{CAST} operators; \sphinxhref{https://www.postgresql.org/docs/9.1/catalogs.html}{Catalogs}, where a relational database management system stores schema metadata, such as information about tables and columns, and internal bookkeeping information; \sphinxhref{https://www.postgresql.org/docs/11/plpgsql-trigger.html}{Triggers}; list the existing \sphinxhref{https://www.postgresql.org/docs/11/external-extensions.html}{Extensions} and create new ones through the pgAdmin interface; \sphinxhref{https://wiki.postgresql.org/wiki/Foreign\_data\_wrappers}{Foreign Data Wrappers} for handling access to remote objects from external SQL databases; see the installed \sphinxhref{https://www.postgresql.org/docs/11/xplang.html}{Procedural Languages} to interact with the database; and the \sphinxhref{https://www.postgresql.org/docs/11/ddl-schemas.html}{Schemas}, a database contains one or more named schemas, which in turn contain tables. Once you select the \sphinxcode{\sphinxupquote{public}} schema you’ll see the tree of objects.

\noindent\sphinxincludegraphics{{pgadmin_04}.png}

\item {} 
Click on the SQL query button indicated below (or go to \sphinxstyleemphasis{Tools \textgreater{} Query Tool}).

\noindent\sphinxincludegraphics{{pgadmin_05}.png}

\item {} 
Enter the following query into the query text field to load the PostGIS spatial extension:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{n}{EXTENSION} \PYG{n}{postgis}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Click the \sphinxstylestrong{Execute} button in the toolbar (or press \sphinxstylestrong{F5}) to “Execute the query.”

\item {} 
Now confirm that PostGIS is installed by running a PostGIS function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{postgis\PYGZus{}full\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

You have successfully created a PostGIS spatial database!!


\subsection{Function List}
\label{\detokenize{setup:function-list}}
\sphinxhref{http://postgis.net/docs/manual-2.5/PostGIS\_Full\_Version.html}{PostGIS\_Full\_Version}: Reports full PostGIS version and build configuration info.


\section{Loading spatial data}
\label{\detokenize{setup:loading-spatial-data}}\label{\detokenize{setup:loading-data}}
Supported by a wide variety of libraries and applications, PostGIS provides many options for loading data. This section will focus on the basics \textendash{} loading shapefiles using QGIS DB Manager.

\sphinxhref{https://qgis.org}{QGIS} is a free and open source geographic information system to create, edit, visualize, analyse and publish geospatial information. It’s available for multiple platforms: Windows, Mac, Linux, BSD. To get it, download the long term release (LTR) from the project website: \sphinxurl{https://qgis.org/en/site/forusers/download.html} and follow the installation process. This tutorial was made using the version 3.4 (Madeira).
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
First, launch the QGIS software and navigate to the browser panel where you will find the PostGIS icon. \sphinxstylestrong{Right click} on it and select \sphinxstylestrong{New Connection…}.

\noindent\sphinxincludegraphics{{qgis_postgis}.png}

\item {} 
Fill in the connection details for the \sphinxstyleemphasis{Authentication} section and click on the \sphinxstylestrong{Test Connection} button. This will test the connection and report back if it works or not. If it is working, click the \sphinxstylestrong{Ok} button to create the connection.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{Username}
&
\sphinxcode{\sphinxupquote{postgres}}
\\
\hline
\sphinxstylestrong{Password}
&
\sphinxcode{\sphinxupquote{postgres}}
\\
\hline
\sphinxstylestrong{Server Host}
&
\sphinxcode{\sphinxupquote{localhost}} \sphinxcode{\sphinxupquote{5432}}
\\
\hline
\sphinxstylestrong{Database}
&
\sphinxcode{\sphinxupquote{nyc}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\noindent\sphinxincludegraphics{{qgis_postgis02}.png}

\item {} 
Next, open the \sphinxstyleemphasis{DB Manager} browser from the menu \sphinxstylestrong{Database \textgreater{} DB Manager…} and select the postgis connection added in the previous step.

\noindent\sphinxincludegraphics{{qgis_postgis_03}.png}

\item {} 
Then \sphinxstylestrong{Click} on \sphinxstyleemphasis{Import Layer/File} and navigate to the folder from the data bundle:\sphinxtitleref{\textbackslash{}postgis-workshop-2018\textbackslash{}data}. Select the \sphinxcode{\sphinxupquote{nyc\_census\_blocks.shp}} file and tick the checkboxes next to \sphinxstylestrong{Create single-part geometries instead of multi-part} and \sphinxstylestrong{Create spatial index}. Make sure the SRID value for the file is set to \sphinxstylestrong{26918} and the schema is set to public. Note that the primary key, geometry column, source SRID, target SRID and encoding are already filled in using the shapefile, but you can optionally change them (\sphinxstylestrong{Don’t!} There are steps later in the workshop that expect the default names.)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{Destination Schema}
&
\sphinxcode{\sphinxupquote{public}}
\\
\hline
\sphinxstylestrong{SRID}
&
\sphinxcode{\sphinxupquote{26918}}
\\
\hline
\sphinxstylestrong{Destination Table}
&
\sphinxcode{\sphinxupquote{nyc\_census\_blocks}}
\\
\hline
\sphinxstylestrong{Geometry Column}
&
\sphinxcode{\sphinxupquote{geom}}
\\
\hline
\sphinxstylestrong{Create single-part geometries instead of multi-part}
&
\sphinxcode{\sphinxupquote{true}}
\\
\hline
\sphinxstylestrong{Create spatial index}
&
\sphinxcode{\sphinxupquote{true}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\noindent\sphinxincludegraphics{{qgis_postgis_04}.png}

\item {} 
Click the \sphinxstylestrong{Ok} button to create the table. It may take a few minutes to load, but this is the largest file in our data set.

\item {} 
Repeat the import process for the remaining shapefiles in the data directory:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nyc\_streets.shp}}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_neighborhoods.shp}}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_subway\_stations.shp}}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_homicides.shp}}

\end{itemize}

\item {} 
When all the files are loaded, click the “Refresh” button in pgAdmin to update the tree view. You should see your four tables show up in the \sphinxstylestrong{Databases \textgreater{} nyc \textgreater{} Schemas \textgreater{} public \textgreater{} Tables} section of the tree.

\noindent\sphinxincludegraphics{{refresh}.png}

\end{enumerate}


\subsection{Shapefiles? What’s that?}
\label{\detokenize{setup:shapefiles-what-s-that}}
You may be asking yourself \textendash{} “What’s this shapefile thing?”  A “shapefile” commonly refers to a collection of files with \sphinxcode{\sphinxupquote{.shp}}, \sphinxcode{\sphinxupquote{.shx}}, \sphinxcode{\sphinxupquote{.dbf}}, and other extensions on a common prefix name (e.g., nyc\_census\_blocks). The actual shapefile relates specifically to files with the \sphinxcode{\sphinxupquote{.shp}} extension. However, the \sphinxcode{\sphinxupquote{.shp}} file alone is incomplete for distribution without the required supporting files.

Mandatory files:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{.shp}}—shape format; the feature geometry itself

\item {} 
\sphinxcode{\sphinxupquote{.shx}}—shape index format; a positional index of the feature geometry

\item {} 
\sphinxcode{\sphinxupquote{.dbf}}—attribute format; columnar attributes for each shape, in dBase III

\end{itemize}

Optional files include:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{.prj}}—projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format

\end{itemize}

The Db Manager importer makes shape data usable in PostGIS by converting it from binary data into a series of SQL commands that are then run in the database to load the data.


\subsection{SRID 26918? What’s with that?}
\label{\detokenize{setup:srid-26918-what-s-with-that}}
Most of the import process is self-explanatory, but even experienced GIS professionals can trip over an \sphinxstylestrong{SRID}.

An “SRID” stands for “Spatial Reference IDentifier.” It defines all the parameters of our data’s geographic coordinate system and projection. An SRID is convenient because it packs all the information about a map projection (which can be quite complex) into a single number.

You can see the definition of our workshop map projection by looking it up either in an online database,
\begin{itemize}
\item {} 
\sphinxurl{http://spatialreference.org/ref/epsg/26918/}

\end{itemize}

or directly inside PostGIS with a query to the \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{srtext} \PYG{k}{FROM} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys} \PYG{k}{WHERE} \PYG{n}{srid} \PYG{o}{=} \PYG{l+m+mi}{26918}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The PostGIS \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} table is an {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}}-standard table that defines all the spatial reference systems known to the database. The data shipped with PostGIS, lists over 3000 known spatial reference systems and details needed to transform/re-project between them.
\end{sphinxadmonition}

In both cases, you see a textual representation of the \sphinxstylestrong{26918} spatial reference system (pretty-printed here for clarity):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PROJCS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAD83 / UTM zone 18N}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAD83}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{North\PYGZus{}American\PYGZus{}Datum\PYGZus{}1983}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GRS 1980}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{6378137}\PYG{p}{,}\PYG{l+m+mf}{298.257222101}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7019}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
      \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6269}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Greenwich}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8901}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{degree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.01745329251994328}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{9122}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4269}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metre}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{9001}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PROJECTION}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Transverse\PYGZus{}Mercator}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latitude\PYGZus{}of\PYGZus{}origin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{central\PYGZus{}meridian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{75}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale\PYGZus{}factor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.9996}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{false\PYGZus{}easting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{500000}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{false\PYGZus{}northing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{26918}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Easting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{EAST}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Northing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{NORTH}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

If you open up the \sphinxcode{\sphinxupquote{nyc\_neighborhoods.prj}} file from the data directory, you’ll see the same projection definition.

A common problem for people getting started with PostGIS is figuring out what SRID number to use for their data. All they have is a \sphinxcode{\sphinxupquote{.prj}} file. But how do humans translate a \sphinxcode{\sphinxupquote{.prj}} file into the correct SRID number?

The easy answer is to use a computer.  Plug the contents of the \sphinxcode{\sphinxupquote{.prj}} file into \sphinxurl{http://prj2epsg.org}. This will give you the number (or a list of numbers) that most closely match your projection definition. There aren’t numbers for \sphinxstyleemphasis{every} map projection in the world, but most common ones are contained within the prj2epsg database of standard numbers.

\noindent\sphinxincludegraphics{{prj2epsg_01}.png}

Data you receive from local agencies—such as New York City—will usually be in a local projection noted by “state plane” or “UTM”.  Our projection is “Universal Transverse Mercator (UTM) Zone 18 North” or EPSG:26918.


\subsection{Things to Try: View data using QGIS}
\label{\detokenize{setup:things-to-try-view-data-using-qgis}}
You can use QGIS for quickly looking at data too. You can view a number of data formats including flat shapefiles and a PostGIS database. Its graphical interface allows for easy exploration of your data, as well as simple testing and fast styling.

To view the imported data, click on the connection in the left panel and \sphinxstylestrong{Double-click} on the tables created to add them to the map.

\noindent\sphinxincludegraphics{{qgis_postgis_05}.png}


\section{About our data}
\label{\detokenize{setup:about-our-data}}\label{\detokenize{setup:about-data}}
The data for this workshop is four shapefiles for New York City, and one attribute table of sociodemographic variables.  We’ve loaded our shapefiles as PostGIS tables and will add sociodemographic data later in the workshop.

The following describes the number of records and table attributes for each of our datasets.  These attribute values and relationships are fundamental to our future analysis.

To explore the nature of your tables in pgAdmin, right-click a highlighted table and select \sphinxstylestrong{Properties}.  You will find a summary of table properties, including a list of table attributes within the \sphinxstylestrong{Columns} tab.


\subsection{nyc\_census\_blocks}
\label{\detokenize{setup:nyc-census-blocks}}
A census block is the smallest geography for which census data is reported. All higher level census geographies (block groups, tracts, metro areas, counties, etc) can be built from unions of census blocks. We have attached some demographic data to our collection of blocks.

Number of records: 36592


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{blkid}
&
A 15-digit code that uniquely identifies every census \sphinxstylestrong{block}. Eg: 360050001009000
\\
\hline
\sphinxstylestrong{popn\_total}
&
Total number of people in the census block
\\
\hline
\sphinxstylestrong{popn\_white}
&
Number of people self-identifying as “White” in the block
\\
\hline
\sphinxstylestrong{popn\_black}
&
Number of people self-identifying as “Black” in the block
\\
\hline
\sphinxstylestrong{popn\_nativ}
&
Number of people self-identifying as “Native American” in the block
\\
\hline
\sphinxstylestrong{popn\_asian}
&
Number of people self-identifying as “Asian” in the block
\\
\hline
\sphinxstylestrong{popn\_other}
&
Number of people self-identifying with other categories in the block
\\
\hline
\sphinxstylestrong{boroname}
&
Name of the New York borough. Manhattan, The Bronx, Brooklyn, Staten Island, Queens
\\
\hline
\sphinxstylestrong{geom}
&
Polygon boundary of the block
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{nyc_census_blocks}.png}
\caption{\sphinxstyleemphasis{Black population as a percentage of Total Population}}\label{\detokenize{setup:id3}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
To get census data into GIS, you need to join two pieces of information: the actual data (text), and the boundary files (spatial).  There are many options for getting the data, including downloading data and boundaries from the Census Bureau’s \sphinxhref{http://factfinder.census.gov}{American FactFinder}.
\end{sphinxadmonition}


\subsection{nyc\_neighborhoods}
\label{\detokenize{setup:nyc-neighborhoods}}
New York has a rich history of neighborhood names and extent.  Neighborhoods are social constructs that do not follow lines laid down by the government. For example, the Brooklyn neighborhoods of Carroll Gardens, Red Hook, and Cobble Hill were once collectively known as “South Brooklyn.” And now, depending on which real estate agent you talk to, the same four blocks in the-neighborhood-formerly-known-as-Red-Hook can be referred to as Columbia Heights, Carroll Gardens West, or Red Hook!

Number of records: 129


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{name}
&
Name of the neighborhood
\\
\hline
\sphinxstylestrong{boroname}
&
Name of the New York borough. Manhattan, The Bronx, Brooklyn, Staten Island, Queens
\\
\hline
\sphinxstylestrong{geom}
&
Polygon boundary of the neighborhood
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{nyc_neighborhoods}.png}
\caption{\sphinxstyleemphasis{The neighborhoods of New York City}}\label{\detokenize{setup:id4}}\end{figure}


\subsection{nyc\_streets}
\label{\detokenize{setup:nyc-streets}}
The street centerlines form the transportation network of the city. These streets have been flagged with types in order to distinguish between such thoroughfares as back alleys, arterial streets, freeways, and smaller streets. Desirable areas to live might be on residential streets rather than next to a freeway.

Number of records: 19091


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{name}
&
Name of the street
\\
\hline
\sphinxstylestrong{oneway}
&
Is the street one-way? “yes” = yes, “” = no
\\
\hline
\sphinxstylestrong{type}
&
Road type (primary, secondary, residential, motorway)
\\
\hline
\sphinxstylestrong{geom}
&
Linear centerline of the street
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{nyc_streets}.png}
\caption{\sphinxstyleemphasis{The streets of New York City. Major roads are in red.}}\label{\detokenize{setup:id5}}\end{figure}


\subsection{nyc\_subway\_stations}
\label{\detokenize{setup:nyc-subway-stations}}
The subway stations link the upper world where people live to the invisible network of subways beneath. As portals to the public transportation system, station locations help determine how easy it is for different people to enter the subway system.

Number of records: 491


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{name}
&
Name of the station
\\
\hline
\sphinxstylestrong{borough}
&
Name of the New York borough. Manhattan, The Bronx, Brooklyn, Staten Island, Queens
\\
\hline
\sphinxstylestrong{routes}
&
Subway lines that run through this station
\\
\hline
\sphinxstylestrong{transfers}
&
Lines you can transfer to via this station
\\
\hline
\sphinxstylestrong{express}
&
Stations where express trains stop, “express” = yes, “” = no
\\
\hline
\sphinxstylestrong{geom}
&
Point location of the station
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{nyc_subway_stations}.png}
\caption{\sphinxstyleemphasis{Point locations for New York City subway stations}}\label{\detokenize{setup:id6}}\end{figure}


\subsection{nyc\_census\_sociodata}
\label{\detokenize{setup:nyc-census-sociodata}}
There is a rich collection of social-economic data collected during the census process, but only at the larger geography level of census tract.  Census blocks combine to form census tracts (and block groups). We have collected some social-economic at a census tract level to answer some of these more interesting questions about New York City.

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{nyc\_census\_sociodata}} is a data table.  We will need to connect it to Census geographies before conducting any spatial analysis.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{tractid}
&
An 11-digit code that uniquely identifies every census \sphinxstylestrong{tract}. (“36005000100”)
\\
\hline
\sphinxstylestrong{transit\_total}
&
Number of workers in the tract
\\
\hline
\sphinxstylestrong{transit\_private}
&
Number of workers in the tract who use private automobiles / motorcycles
\\
\hline
\sphinxstylestrong{transit\_public}
&
Number of workers in the tract who take public transit
\\
\hline
\sphinxstylestrong{transit\_walk}
&
Number of workers in the tract who walk
\\
\hline
\sphinxstylestrong{transit\_other}
&
Number of workers in the tract who use other forms like walking / biking
\\
\hline
\sphinxstylestrong{transit\_none}
&
Number of workers in the tract who work from home
\\
\hline
\sphinxstylestrong{transit\_time\_mins}
&
Total number of minutes spent in transit by all workers in the tract (minutes)
\\
\hline
\sphinxstylestrong{family\_count}
&
Number of families in the tract
\\
\hline
\sphinxstylestrong{family\_income\_median}
&
Median family income in the tract (dollars)
\\
\hline
\sphinxstylestrong{family\_income\_mean}
&
Average family income in the tract (dollars)
\\
\hline
\sphinxstylestrong{family\_income\_aggregate}
&
Total income of all families in the tract (dollars)
\\
\hline
\sphinxstylestrong{edu\_total}
&
Number of people with educational history
\\
\hline
\sphinxstylestrong{edu\_no\_highschool\_dipl}
&
Number of people with no high school diploma
\\
\hline
\sphinxstylestrong{edu\_highschool\_dipl}
&
Number of people with high school diploma and no further education
\\
\hline
\sphinxstylestrong{edu\_college\_dipl}
&
Number of people with college diploma and no further education
\\
\hline
\sphinxstylestrong{edu\_graduate\_dipl}
&
Number of people with graduate school diploma
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\chapter{PostGIS - Basics}
\label{\detokenize{basic:postgis-basics}}\label{\detokenize{basic::doc}}

\section{Simple SQL}
\label{\detokenize{basic:simple-sql}}\label{\detokenize{basic:id1}}
{\hyperref[\detokenize{glossary:term-sql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SQL}}}}, or “Structured Query Language”, is a means of asking questions of, and updating data in, relational databases. You have already seen SQL when we created our first database.  Recall:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{postgis\PYGZus{}full\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

But that was a question about the database.  Now that we’ve loaded data into our database, let’s use SQL to ask questions of the data! For example,
\begin{quote}

“What are the names of all the neighborhoods in New York City?”
\end{quote}

Open up the SQL query window in pgAdmin by clicking the SQL button

\noindent\sphinxincludegraphics{{pgadmin_05}.png}

then enter the following query in to the query window

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}\PYG{p}{;}
\end{sphinxVerbatim}

and click the \sphinxstylestrong{Execute Query} button (again the thunder).

\noindent\sphinxincludegraphics{{pgadmin_05}.png}

The query will run for a few (milli)seconds and return the 129 results.

\noindent\sphinxincludegraphics{{pgadmin_09}.png}

But what exactly happened here?  To understand, let’s begin with the four “verbs” of SQL,
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SELECT}}, returns rows in response to a query

\item {} 
\sphinxcode{\sphinxupquote{INSERT}}, adds new rows to a table

\item {} 
\sphinxcode{\sphinxupquote{UPDATE}}, alters existing rows in a table

\item {} 
\sphinxcode{\sphinxupquote{DELETE}}, removes rows from a table

\end{itemize}

We will be working almost exclusively with \sphinxcode{\sphinxupquote{SELECT}} in order to ask questions of tables using spatial functions.


\subsection{SELECT queries}
\label{\detokenize{basic:select-queries}}
A select query is generally of the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{some\PYGZus{}columns} \PYG{n}{FROM} \PYG{n}{some\PYGZus{}data\PYGZus{}source} \PYG{n}{WHERE} \PYG{n}{some\PYGZus{}condition}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
For a synopsis of all \sphinxcode{\sphinxupquote{SELECT}} parameters, see the \sphinxhref{http://www.postgresql.org/docs/current/interactive/sql-select.html}{PostgresSQL documentation}.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{some\_columns}} are either column names or functions of column values. The \sphinxcode{\sphinxupquote{some\_data\_source}} is either a single table, or a composite table created by joining two tables on a key or condition. The \sphinxcode{\sphinxupquote{some\_condition}} is a filter that restricts the number of rows to be returned.
\begin{quote}

“What are the names of all the neighborhoods in Brooklyn?”
\end{quote}

We return to our \sphinxcode{\sphinxupquote{nyc\_neighborhoods}} table with a filter in hand.  The table contains all the neighborhoods in New York, but we only want the ones in Brooklyn.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Brooklyn\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

The query will run for even fewer (milli)seconds and return the 23 results.

Sometimes we will need to apply a function to the results of our query. For example,
\begin{quote}

“What is the number of letters in the names of all the neighborhoods in Brooklyn?”
\end{quote}

Fortunately, PostgreSQL has a string length function, \sphinxstyleliteralstrong{\sphinxupquote{char\_length(string)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{char\PYGZus{}length}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Brooklyn\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

Often, we are less interested in the individual rows than in a statistic that applies to all of them. So knowing the lengths of the neighborhood names might be less interesting than knowing the average length of the names. Functions that take in multiple rows and return a single result are called “aggregate” functions.

PostgreSQL has a series of built-in aggregate functions, including the general purpose \sphinxstyleliteralstrong{\sphinxupquote{avg()}} for average values and \sphinxstyleliteralstrong{\sphinxupquote{stddev()}} for standard deviations.
\begin{quote}

“What is the average number of letters and standard deviation of number of letters in the names of all the neighborhoods in Brooklyn?”
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{avg}\PYG{p}{(}\PYG{k}{char\PYGZus{}length}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stddev}\PYG{p}{(}\PYG{k}{char\PYGZus{}length}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Brooklyn\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
         \PYG{n}{avg}         \PYG{o}{\textbar{}}       \PYG{n}{stddev}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mf}{11.7391304347826087} \PYG{o}{\textbar{}} \PYG{l+m+mf}{3.9105613559407395}
\end{sphinxVerbatim}

The aggregate functions in our last example were applied to every row in the result set. What if we want the summaries to be carried out over smaller groups within the overall result set? For that we add a \sphinxcode{\sphinxupquote{GROUP BY}} clause. Aggregate functions often need an added \sphinxcode{\sphinxupquote{GROUP BY}} statement to group the result-set by one or more columns.
\begin{quote}

“What is the average number of letters in the names of all the neighborhoods in New York City, reported by borough?”
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{boroname}\PYG{p}{,} \PYG{k}{avg}\PYG{p}{(}\PYG{k}{char\PYGZus{}length}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stddev}\PYG{p}{(}\PYG{k}{char\PYGZus{}length}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{boroname}\PYG{p}{;}
\end{sphinxVerbatim}

We include the \sphinxcode{\sphinxupquote{boroname}} column in the output result so we can determine which statistic applies to which borough. In an aggregate query, you can only output columns that are either (a) members of the grouping clause or (b) aggregate functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{boroname}    \PYG{o}{\textbar{}}         \PYG{n}{avg}         \PYG{o}{\textbar{}}       \PYG{n}{stddev}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Brooklyn}      \PYG{o}{\textbar{}} \PYG{l+m+mf}{11.7391304347826087} \PYG{o}{\textbar{}} \PYG{l+m+mf}{3.9105613559407395}
 \PYG{n}{Manhattan}     \PYG{o}{\textbar{}} \PYG{l+m+mf}{11.8214285714285714} \PYG{o}{\textbar{}} \PYG{l+m+mf}{4.3123729948325257}
 \PYG{n}{The} \PYG{n}{Bronx}     \PYG{o}{\textbar{}} \PYG{l+m+mf}{12.0416666666666667} \PYG{o}{\textbar{}} \PYG{l+m+mf}{3.6651017740975152}
 \PYG{n}{Queens}        \PYG{o}{\textbar{}} \PYG{l+m+mf}{11.6666666666666667} \PYG{o}{\textbar{}} \PYG{l+m+mf}{5.0057438272815975}
 \PYG{n}{Staten} \PYG{n}{Island} \PYG{o}{\textbar{}} \PYG{l+m+mf}{12.2916666666666667} \PYG{o}{\textbar{}} \PYG{l+m+mf}{5.2043390480959474}
\end{sphinxVerbatim}


\subsection{Function List}
\label{\detokenize{basic:function-list}}
\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{avg(expression)}: PostgreSQL aggregate function that returns the average value of a numeric column.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-string.html}{char\_length(string)}: PostgreSQL string function that returns the number of character in a string.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-STATISTICS-TABLE}{stddev(expression)}: PostgreSQL aggregate function that returns the standard deviation of input values.


\section{Simple SQL Exercises}
\label{\detokenize{basic:simple-sql-exercises}}\label{\detokenize{basic:id2}}
Using the \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table, answer the following questions (don’t peak at the answers!).

Here is some helpful information to get started.  Recall from the \DUrole{xref,std,std-ref}{About Our Data} section our \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table definition.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{100}|\X{80}{100}|}
\hline

\sphinxstylestrong{blkid}
&
A 15-digit code that uniquely identifies every census \sphinxstylestrong{block}. (“360050001009000”)
\\
\hline
\sphinxstylestrong{popn\_total}
&
Total number of people in the census block
\\
\hline
\sphinxstylestrong{popn\_white}
&
Number of people self-identifying as “white” in the block
\\
\hline
\sphinxstylestrong{popn\_black}
&
Number of people self-identifying as “black” in the block
\\
\hline
\sphinxstylestrong{popn\_nativ}
&
Number of people self-identifying as “native american” in the block
\\
\hline
\sphinxstylestrong{popn\_asian}
&
Number of people self-identifying as “asias” in the block
\\
\hline
\sphinxstylestrong{popn\_other}
&
Number of people self-identifying with other categories in the block
\\
\hline
\sphinxstylestrong{hous\_total}
&
Number of housing units in the block
\\
\hline
\sphinxstylestrong{hous\_own}
&
Number of owner-occupied housing units in the block
\\
\hline
\sphinxstylestrong{hous\_rent}
&
Number of renter-occupied housing units in the block
\\
\hline
\sphinxstylestrong{boroname}
&
Name of the New York borough. Manhattan, The Bronx, Brooklyn, Staten Island, Queens
\\
\hline
\sphinxstylestrong{geom}
&
Polygon boundary of the block
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

And, here are some common SQL aggregation functions you might find useful:
\begin{itemize}
\item {} 
avg() - the average (mean) of the values in a set of records

\item {} 
sum() - the sum of the values in a set of records

\item {} 
count() - the number of records in a set of records

\end{itemize}

Now the questions:
\begin{itemize}
\item {} 
\sphinxstylestrong{“What is the geometry value for the street named ‘Atlantic Commons’?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Atlantic Commons\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MULTILINESTRING}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{586781.701577724} \PYG{l+m+mf}{4504202.15314339}\PYG{p}{,}\PYG{l+m+mf}{586863.51964484} \PYG{l+m+mf}{4504215.9881701}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What neighborhood and borough is Atlantic Commons in?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}
  \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{name}    \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Fort} \PYG{n}{Green} \PYG{o}{\textbar{}} \PYG{n}{Brooklyn}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
“Hey, why did you change from a ‘MULTILINESTRING’ to a ‘LINESTRING’?” Spatially they describe the same shape, so going from a single-item multi-geometry to a singleton saves a few keystrokes.

More importantly, we also rounded the coordinates to make them easier to read, which does actually change results: we couldn’t use the ST\_Touches() predicate to find out which roads join Atlantic Commons, because the coordinates are not exactly the same anymore.
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{“What streets does Atlantic Commons join with?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}
  \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
  \PYG{l+m+mi}{0}\PYG{p}{.}\PYG{l+m+mi}{1}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
     \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Cumberland} \PYG{n}{St}
 \PYG{n}{Atlantic} \PYG{n}{Commons}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{atlantic_commons}.jpg}

\item {} 
\sphinxstylestrong{“Approximately how many people live on (within 50 meters of) Atlantic Commons?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
  \PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}
   \PYG{n}{geom}\PYG{p}{,}
   \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
   \PYG{l+m+mi}{50}
  \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1438}
\end{sphinxVerbatim}

\end{itemize}


\subsection{Function List}
\label{\detokenize{basic:id3}}
\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{avg(expression)}: PostgreSQL aggregate function that returns the average value of a numeric column.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{count(expression)}: PostgreSQL aggregate function that returns the number of records in a set of records.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{sum(expression)}: PostgreSQL aggregate function that returns the sum of records in a set of records.


\section{Geometries}
\label{\detokenize{basic:geometries}}\label{\detokenize{basic:id5}}

\subsection{Introduction}
\label{\detokenize{basic:introduction}}
In the previous \DUrole{xref,std,std-ref}{section}, we loaded a variety of data.  Before we start playing with our data lets have a look at some simpler examples.  In pgAdmin, once again select the \sphinxstylestrong{nyc} database and open the SQL query tool.  Paste this example SQL code into the pgAdmin SQL Editor window (removing any text that may be there by default) and then execute.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{geometries} \PYG{p}{(}\PYG{n}{name} \PYG{n+nb}{varchar}\PYG{p}{,} \PYG{n}{geom} \PYG{n}{geometry}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{geometries} \PYG{k}{VALUES}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Point\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Linestring\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0, 1 1, 2 1, 2 2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Polygon\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}PolygonWithHole\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 10 0, 10 10, 0 10, 0 0),(1 1, 1 2, 2 2, 2 1, 1 1))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Collection\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}GEOMETRYCOLLECTION(POINT(2 0),POLYGON((0 0, 1 0, 1 1, 0 1, 0 0)))\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{FROM} \PYG{n}{geometries}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{start01}.png}

\begin{sphinxadmonition}{note}{Note:}
In versions of PostGIS \textgreater{}= 2.0 the behavior to add geometry columns changed and it is now possible to specify the type of geometry and srid while creating a table as done in the previous query. Before, the \sphinxhref{https://postgis.net/docs/AddGeometryColumn.html}{AddGeometryColumn} function had to be used to specify the geometry column after the creation of the table, both ways are now possible.
\end{sphinxadmonition}

The above example CREATEs a table (\sphinxstylestrong{geometries}) then INSERTs five geometries: a point, a line, a polygon, a polygon with a hole, and a collection. Finally, the inserted rows are SELECTed and displayed in the Output pane.


\subsection{Metadata Tables}
\label{\detokenize{basic:metadata-tables}}
In conformance with the Simple Features for SQL ({\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}}) specification, PostGIS provides two tables to track and report on the geometry types available in a given database.
\begin{itemize}
\item {} 
The first table, \sphinxcode{\sphinxupquote{spatial\_ref\_sys}}, defines all the spatial reference systems known to the database and will be described in greater detail later.

\item {} 
The second table (actually, a view), \sphinxcode{\sphinxupquote{geometry\_columns}}, provides a listing of all “features” (defined as an object with geometric attributes), and the basic details of those features.

\end{itemize}

\noindent\sphinxincludegraphics{{table01}.png}

Let’s have a look at the \sphinxcode{\sphinxupquote{geometry\_columns}} table in our database.  Paste this command in the Query Tool as before:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{geometry\PYGZus{}columns}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{start08}.png}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{f\_table\_catalog}} together with \sphinxcode{\sphinxupquote{f\_table\_schema}}, and \sphinxcode{\sphinxupquote{f\_table\_name}}, the fully qualified name of the featured table containing the geometry column. Where the \sphinxcode{\sphinxupquote{f\_table\_catalog}} contains detailed information (sometimes called \sphinxstylestrong{descriptor information} or \sphinxstylestrong{metadata}) regarding the various objects that are of interest to the system itself. The catalog is the place where\textendash{}among other things\textendash{}all of the various schemas (\sphinxcode{\sphinxupquote{f\_table\_schema}}) (external, conceptual, internal) and all of the corresponding mappings (external/conceptual, conceptual/internal) are kept.

\item {} 
\sphinxcode{\sphinxupquote{f\_table\_name}} is the table schema that is implementing the geometry column.

\item {} 
{\color{red}\bfseries{}{}`{}`}g\_table\_name{}`{}`is the table name that is implementing the geometry column.

\item {} 
\sphinxcode{\sphinxupquote{f\_geometry\_column}} is the name of the column that contains a geometry \textendash{} for feature tables with multiple geometry columns, there will be one record for each.

\item {} 
\sphinxcode{\sphinxupquote{coord\_dimension}} and \sphinxcode{\sphinxupquote{srid}} define the the dimension of the geometry (2-, 3- or 4-dimensional) and the Spatial Reference system identifier that refers to the \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} table respectively.

\item {} 
The \sphinxcode{\sphinxupquote{type}} column defines the type of geometry as described below; we’ve seen Point and Linestring types so far.

\end{itemize}

By querying this table, GIS clients and libraries can determine what to expect when retrieving data and can perform any necessary projection, processing or rendering without needing to inspect each geometry.

\begin{sphinxadmonition}{note}{Note:}
Do some or all of your \sphinxcode{\sphinxupquote{nyc}} tables not have an \sphinxcode{\sphinxupquote{srid}} of 26918? It’s easy to fix by updating the table

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{UpdateGeometrySRID}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}nyc\PYGZus{}neighborhoods\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}geom\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Representing Real World Objects}
\label{\detokenize{basic:representing-real-world-objects}}
The Simple Features for SQL ({\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}}) specification, the original guiding standard for PostGIS development, defines how a real world object is represented.  By taking a continuous shape and digitizing it at a fixed resolution we achieve a passable representation of the object.  SFSQL only handled 2-dimensional representations.  PostGIS has extended that to include 3- and 4-dimensional representations; more recently the SQL-Multimedia Part 3 ({\hyperref[\detokenize{glossary:term-sql-mm}]{\sphinxtermref{\DUrole{xref,std,std-term}{SQL/MM}}}}) specification has officially defined their own representation.

Our example table contains a mixture of different geometry types. We can collect general information about each object using functions that read the geometry metadata.
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryType(geometry)}} returns the type of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NDims(geometry)}} returns the number of dimensions of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_SRID(geometry)}} returns the spatial reference identifier number of the geometry

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}GeometryType}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ST\PYGZus{}NDims}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ST\PYGZus{}SRID}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{name}       \PYG{o}{\textbar{}}    \PYG{n}{st\PYGZus{}geometrytype}    \PYG{o}{\textbar{}} \PYG{n}{st\PYGZus{}ndims} \PYG{o}{\textbar{}} \PYG{n}{st\PYGZus{}srid}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Point}           \PYG{o}{\textbar{}} \PYG{n}{ST\PYGZus{}Point}              \PYG{o}{\textbar{}}        \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}       \PYG{l+m+mi}{0}
 \PYG{n}{Polygon}         \PYG{o}{\textbar{}} \PYG{n}{ST\PYGZus{}Polygon}            \PYG{o}{\textbar{}}        \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}       \PYG{l+m+mi}{0}
 \PYG{n}{PolygonWithHole} \PYG{o}{\textbar{}} \PYG{n}{ST\PYGZus{}Polygon}            \PYG{o}{\textbar{}}        \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}       \PYG{l+m+mi}{0}
 \PYG{n}{Collection}      \PYG{o}{\textbar{}} \PYG{n}{ST\PYGZus{}GeometryCollection} \PYG{o}{\textbar{}}        \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}       \PYG{l+m+mi}{0}
 \PYG{n}{Linestring}      \PYG{o}{\textbar{}} \PYG{n}{ST\PYGZus{}LineString}         \PYG{o}{\textbar{}}        \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}       \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsubsection{Points}
\label{\detokenize{basic:points}}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{points}.png}\hspace*{\fill}}

A spatial \sphinxstylestrong{point} represents a single location on the Earth.  This point is represented by a single coordinate (including either 2-, 3- or 4-dimensions).  Points are used to represent objects when the exact details, such as shape and size, are not important at the target scale.  For example, cities on a map of the world can be described as points, while a map of a single state might represent cities as polygons.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Point\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POINT}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

Some of the specific spatial functions for working with points are:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_X(geometry)}} returns the X ordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Y(geometry)}} returns the Y ordinate

\end{itemize}

So, we can read the ordinates from a point like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}X}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Y}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Point\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{st\PYGZus{}x} \PYG{o}{\textbar{}} \PYG{n}{st\PYGZus{}y}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}    \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

The New York City subway stations (\sphinxcode{\sphinxupquote{nyc\_subway\_stations}}) table is a data set represented as points. The following SQL query will return the geometry associated with one point (in the \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText}} column).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
  \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Linestrings}
\label{\detokenize{basic:linestrings}}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{lines}.png}\hspace*{\fill}}

A \sphinxstylestrong{linestring} is a path between locations.  It takes the form of an ordered series of two or more points.  Roads and rivers are typically represented as linestrings.  A linestring is said to be \sphinxstylestrong{closed} if it starts and ends on the same point.  It is said to be \sphinxstylestrong{simple} if it does not cross or touch itself (except at its endpoints if it is closed).  A linestring can be both \sphinxstylestrong{closed} and \sphinxstylestrong{simple}.

The street network for New York (\sphinxcode{\sphinxupquote{nyc\_streets}}) was loaded earlier in the course.  This dataset contains details such as name, and type.  A single real world street may consist of many linestrings, each representing a segment of road with different attributes.

The following SQL query will return the geometry associated with one linestring (in the \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText}} column).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Linestring\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LINESTRING}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

Some of the specific spatial functions for working with linestrings are:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(geometry)}} returns the length of the linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_StartPoint(geometry)}} returns the first coordinate as a point

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_EndPoint(geometry)}} returns the last coordinate as a point

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NPoints(geometry)}} returns the number of coordinates in the linestring

\end{itemize}

So, the length of our linestring is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Linestring\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{3.41421356237309}
\end{sphinxVerbatim}


\subsubsection{Polygons}
\label{\detokenize{basic:polygons}}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{polygons}.png}\hspace*{\fill}}

A polygon is a representation of an area.  The outer boundary of the polygon is represented by a ring.  This ring is a linestring that is both closed and simple as defined above.  Holes within the polygon are also represented by rings.

Polygons are used to represent objects whose size and shape are important.  City limits, parks, building footprints or bodies of water are all commonly represented as polygons when the scale is sufficiently high to see their area.  Roads and rivers can sometimes be represented as polygons.

The following SQL query will return the geometry associated with one linestring (in the \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText}} column).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{k}{LIKE} \PYG{l+s+s1}{\PYGZsq{}Polygon\PYGZpc{}\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Rather than using an \sphinxcode{\sphinxupquote{=}} sign in our \sphinxcode{\sphinxupquote{WHERE}} clause, we are using the \sphinxcode{\sphinxupquote{LIKE}} operator to carry out a string matching operation. \sphinxstylestrong{You may be used to the {}`{}`*{}`{}` symbol as a “glob” for pattern matching, but in SQL the {}`{}`\%{}`{}` symbol is used}, along with the \sphinxcode{\sphinxupquote{LIKE}} operator to tell the system to do globbing.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The first polygon has only one ring. The second one has an interior “hole”. Most graphics systems include the concept of a “polygon”, but GIS systems are relatively unique in allowing polygons to explicitly have holes.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{polygons1}.png}\hspace*{\fill}}

Some of the specific spatial functions for working with polygons are:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}} returns the area of the polygons

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NRings(geometry)}} returns the number of rings (usually 1, more of there are holes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_ExteriorRing(geometry)}} returns the outer ring as a linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_InteriorRingN(geometry,n)}} returns a specified interior ring as a linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Perimeter(geometry)}} returns the length of all the rings

\end{itemize}

We can calculate the area of our polygons using the area function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{k}{LIKE} \PYG{l+s+s1}{\PYGZsq{}Polygon\PYGZpc{}\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Polygon}            \PYG{l+m+mi}{1}
\PYG{n}{PolygonWithHole}    \PYG{l+m+mi}{99}
\end{sphinxVerbatim}

Note that the polygon with a hole has an area that is the area of the outer shell (a 10x10 square) minus the area of the hole (a 1x1 square).


\subsubsection{Collections}
\label{\detokenize{basic:collections}}
There are four collection types, which group multiple simple geometries into sets.
\begin{itemize}
\item {} 
\sphinxstylestrong{MultiPoint}, a collection of points

\item {} 
\sphinxstylestrong{MultiLineString}, a collection of linestrings

\item {} 
\sphinxstylestrong{MultiPolygon}, a collection of polygons

\item {} 
\sphinxstylestrong{GeometryCollection}, a heterogeneous collection of any geometry (including other collections)

\end{itemize}

Collections are another concept that shows up in GIS software more than in generic graphics software. They are useful for directly modeling real world objects as spatial objects. For example, how to model a lot that is split by a right-of-way? As a \sphinxstylestrong{MultiPolygon}, with a part on either side of the right-of-way.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{collection2}.png}\hspace*{\fill}}

Our example collection contains a polygon and a point:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{geometries}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Collection\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GEOMETRYCOLLECTION}\PYG{p}{(}\PYG{n}{POINT}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{collection}.png}\hspace*{\fill}}

Some of the specific spatial functions for working with collections are:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NumGeometries(geometry)}} returns the number of parts in the collection

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryN(geometry,n)}} returns the specified part

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}} returns the total area of all polygonal parts

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(geometry)}} returns the total length of all linear parts

\end{itemize}


\subsection{Geometry Input and Output}
\label{\detokenize{basic:geometry-input-and-output}}
Within the database, geometries are stored on disk in a format only used by the PostGIS program. In order for external programs to insert and retrieve useful geometries, they need to be converted into a format that other applications can understand. Fortunately, PostGIS supports emitting and consuming geometries in a large number of formats:
\begin{itemize}
\item {} 
Well-known text ({\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}})
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText(text, srid)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsEWKT(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\end{itemize}

\item {} 
Well-known binary ({\hyperref[\detokenize{glossary:term-wkb}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKB}}}})
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromWKB(bytea)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsBinary(geometry)}} returns \sphinxcode{\sphinxupquote{bytea}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsEWKB(geometry)}} returns \sphinxcode{\sphinxupquote{bytea}}

\end{itemize}

\item {} 
Geographic Mark-up Language ({\hyperref[\detokenize{glossary:term-gml}]{\sphinxtermref{\DUrole{xref,std,std-term}{GML}}}})
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromGML(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\end{itemize}

\item {} 
Keyhole Mark-up Language ({\hyperref[\detokenize{glossary:term-kml}]{\sphinxtermref{\DUrole{xref,std,std-term}{KML}}}})
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromKML(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsKML(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{glossary:term-geojson}]{\sphinxtermref{\DUrole{xref,std,std-term}{GeoJSON}}}}
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGeoJSON(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\end{itemize}

\item {} 
Scalable Vector Graphics ({\hyperref[\detokenize{glossary:term-svg}]{\sphinxtermref{\DUrole{xref,std,std-term}{SVG}}}})
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsSVG(geometry)}} returns \sphinxcode{\sphinxupquote{text}}

\end{itemize}

\end{itemize}

The most common use of a constructor is to turn a text representation of a geometry into an internal representation:

Note that in addition to a text parameter with a geometry representation, we also have a numeric parameter providing the {\hyperref[\detokenize{glossary:term-srid}]{\sphinxtermref{\DUrole{xref,std,std-term}{SRID}}}} of the geometry.

The following SQL query shows an example of {\hyperref[\detokenize{glossary:term-wkb}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKB}}}} representation (the call to \sphinxstyleliteralstrong{\sphinxupquote{encode()}} is required to convert the binary output into an ASCII form for printing):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{encode}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}AsBinary}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0,1 0)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}hex\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{01020000000200000000000000000000000000000000000000000000000000}\PYG{n}{f03f0000000000000000}
\end{sphinxVerbatim}

For the purposes of this course we will continue to use WKT to ensure you can read and understand the geometries we’re viewing.  However, most actual processes, such as viewing data in a GIS application, transferring data to a web service, or processing data remotely, WKB is the binary equivalent and is format of choice as they were originally defined by the Open Geospatial Consortium (OGC) and described in their \sphinxhref{https://www.opengeospatial.org/standards/sfa}{Simple Feature Access}.

Since WKT and WKB were defined in the  {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} specification, they do not handle 3- or 4-dimensional geometries.  For these cases PostGIS has defined the Extended Well Known Text (EWKT) and Extended Well Known Binary (EWKB) formats.  These provide the same formatting capabilities of WKT and WKB with the added dimensionality and will be explored in a further section of this course {\hyperref[\detokenize{advanced:d}]{\sphinxcrossref{\DUrole{std,std-ref}{section}}}}.

Here is an example of a 3D linestring in WKT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0 0,1 0 0,1 1 2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LINESTRING} \PYG{n}{Z} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the text representation changes! This is because the text input routine for PostGIS is liberal in what it consumes. It will consume
\begin{itemize}
\item {} 
hex-encoded EWKB,

\item {} 
extended well-known text, and

\item {} 
ISO standard well-known text.

\end{itemize}

On the output side, the \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText}} function is conservative, and only emits ISO standard well-known text.

In addition to the \sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryFromText}} function, there are many other ways to create geometries from well-known text or similar formatted inputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using ST\PYGZus{}GeomFromText with the SRID parameter}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(2 2)\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using ST\PYGZus{}GeomFromText without the SRID parameter}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(2 2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using a ST\PYGZus{}Make* function}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{n}{ST\PYGZus{}MakePoint}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using PostgreSQL casting syntax and ISO WKT}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(2 2)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using PostgreSQL casting syntax and extended WKT}
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}SRID=4326;POINT(2 2)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}
\end{sphinxVerbatim}

In addition to emitters for the various forms (WKT, WKB, GML, KML, JSON, SVG), PostGIS also has consumers for four (WKT, WKB, GML, KML). Most applications use the WKT or WKB geometry creation functions, but the others work too. Here’s an example that consumes GML and output JSON:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsGeoJSON}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeomFromGML}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZlt{}gml:Point\PYGZgt{}\PYGZlt{}gml:coordinates\PYGZgt{}1,1\PYGZlt{}/gml:coordinates\PYGZgt{}\PYGZlt{}/gml:Point\PYGZgt{}\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{represent-07}.png}\hspace*{\fill}}


\subsection{Casting from Text}
\label{\detokenize{basic:casting-from-text}}
The {\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}} strings we’ve see so far have been of type ‘text’ and we have been converting them to type ‘geometry’ using PostGIS functions like \sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText()}}.

PostgreSQL includes a short form syntax that allows data to be converted from one type to another, the casting syntax, \sphinxtitleref{oldata::newtype}. So for example, this SQL converts a double into a text string.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{l+m+mi}{0}\PYG{p}{.}\PYG{l+m+mi}{9}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{text}\PYG{p}{;}
\end{sphinxVerbatim}

Less trivially, this SQL converts a {\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}} string into a geometry:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}
\end{sphinxVerbatim}

One thing to note about using casting to create geometries: unless you specify the SRID, you will get a geometry with an unknown SRID. You can specify the SRID using the “extended” well-known text form, which includes an SRID block at the front:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}SRID=4326;POINT(0 0)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}
\end{sphinxVerbatim}

It’s very common to use the casting notation when working with {\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}}, as well as \sphinxtitleref{geometry} and \sphinxtitleref{geography} columns (see \DUrole{xref,std,std-ref}{geography}).


\subsection{Function List}
\label{\detokenize{basic:id8}}
\sphinxhref{http://postgis.net/docs/ST\_Area.html}{ST\_Area}: Returns the area of the surface if it is a polygon or multi-polygon. For “geometry” type area is in SRID units. For “geography” area is in square meters.

\sphinxhref{http://postgis.net/docs/ST\_AsText.html}{ST\_AsText}: Returns the Well-Known Text (WKT) representation of the geometry/geography without SRID metadata.

\sphinxhref{http://postgis.net/docs/ST\_AsBinary.html}{ST\_AsBinary}: Returns the Well-Known Binary (WKB) representation of the geometry/geography without SRID meta data.

\sphinxhref{http://postgis.net/docs/ST\_EndPoint.html}{ST\_EndPoint}: Returns the last point of a LINESTRING geometry as a POINT.

\sphinxhref{http://postgis.net/docs/ST\_AsEWKB.html}{ST\_AsEWKB}: Returns the Well-Known Binary (WKB) representation of the geometry with SRID meta data.

\sphinxhref{http://postgis.net/docs/ST\_AsEWKT.html}{ST\_AsEWKT}: Returns the Well-Known Text (WKT) representation of the geometry with SRID meta data.

\sphinxhref{http://postgis.net/docs/ST\_AsGeoJSON.html}{ST\_AsGeoJSON}: Returns the geometry as a GeoJSON element.

\sphinxhref{http://postgis.net/docs/ST\_AsGML.html}{ST\_AsGML}: Returns the geometry as a GML version 2 or 3 element.

\sphinxhref{http://postgis.net/docs/ST\_AsKML.html}{ST\_AsKML}: Returns the geometry as a KML element. Several variants. Default version=2, default precision=15.

\sphinxhref{http://postgis.net/docs/ST\_AsSVG.html}{ST\_AsSVG}: Returns a Geometry in SVG path data given a geometry or geography object.

\sphinxhref{http://postgis.net/docs/ST\_ExteriorRing.html}{ST\_ExteriorRing}: Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon.

\sphinxhref{https://postgis.net/docs/ST\_GeometryN.html}{ST\_GeometryN}: Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, (MULTI)CURVE, (MULTI)POLYGON or POLYHEDRALSURFACE. Otherwise, return NULL.

\sphinxhref{http://postgis.net/docs/ST\_GeomFromGML.html}{ST\_GeomFromGML}: Takes as input GML representation of geometry and outputs a PostGIS geometry object.

\sphinxhref{http://postgis.net/docs/ST\_GeomFromKML.html}{ST\_GeomFromKML}: Takes as input KML representation of geometry and outputs a PostGIS geometry object

\sphinxhref{http://postgis.net/docs/ST\_GeomFromText.html}{ST\_GeomFromText}: Returns a specified ST\_Geometry value from Well-Known Text representation (WKT).

\sphinxhref{http://postgis.net/docs/ST\_GeomFromWKB.html}{ST\_GeomFromWKB}: Creates a geometry instance from a Well-Known Binary geometry representation (WKB) and optional SRID.

\sphinxhref{http://postgis.net/docs/ST\_GeometryType.html}{ST\_GeometryType}: Returns the geometry type of the ST\_Geometry value.

\sphinxhref{http://postgis.net/docs/ST\_InteriorRingN.html}{ST\_InteriorRingN}: Returns the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range. index starts at 1.

\sphinxhref{http://postgis.net/docs/ST\_Length.html}{ST\_Length}: Returns the 2d length of the geometry if it is a linestring or multilinestring. geometry are in units of spatial reference and geography are in meters (default spheroid)

\sphinxhref{http://postgis.net/docs/ST\_NDims.html}{ST\_NDims}: Returns coordinate dimension of the geometry. Values are: 2,3 or 4.

\sphinxhref{http://postgis.net/docs/ST\_NPoints.html}{ST\_NPoints}: Returns the number of points (vertexes) in a geometry.

\sphinxhref{http://postgis.net/docs/ST\_NRings.html}{ST\_NRings}: If the geometry is a polygon or multi-polygon returns the number of rings. Unlike :command: \sphinxtitleref{NumInteriorRings}, it counts the outer rings as well.

\sphinxhref{http://postgis.net/docs/ST\_NumGeometries.html}{ST\_NumGeometries}: If geometry is a GEOMETRYCOLLECTION (or MULTI*) returns the number of geometries, for single geometries will return 1, otherwise return NULL.

\sphinxhref{http://postgis.net/docs/ST\_Perimeter.html}{ST\_Perimeter}: Returns the length measurement of the boundary of an ST\_Surface or ST\_MultiSurface value. (Polygon, Multipolygon)

\sphinxhref{http://postgis.net/docs/ST\_SRID.html}{ST\_SRID}: Returns the spatial reference identifier for the ST\_Geometry as defined in spatial\_ref\_sys table.

\sphinxhref{http://postgis.net/docs/ST\_StartPoint.html}{ST\_StartPoint}: Returns the first point of a LINESTRING or CIRCULARLINESTRIING geometry as a POINT.

\sphinxhref{http://postgis.net/docs/ST\_X.html}{ST\_X}: Returns the X coordinate of the point, or NULL if not available. Input must be a point.

\sphinxhref{http://postgis.net/docs/ST\_Y.html}{ST\_Y}: Returns the Y coordinate of the point, or NULL if not available. Input must be a point.


\section{Geometry Exercises}
\label{\detokenize{basic:geometry-exercises}}\label{\detokenize{basic:geometries-exercises}}
Here’s a reminder of all the functions we have seen so far. They should be useful for the exercises!
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sum(expression)}} aggregate to return a sum for a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{count(expression)}} aggregate to return the size of a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryType(geometry)}} returns the type of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NDims(geometry)}} returns the number of dimensions of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_SRID(geometry)}} returns the spatial reference identifier number of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_X(point)}} returns the X ordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Y(point)}} returns the Y ordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(linestring)}} returns the length of the linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_StartPoint(geometry)}} returns the first coordinate as a point

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_EndPoint(geometry)}} returns the last coordinate as a point

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NPoints(geometry)}} returns the number of coordinates in the linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}} returns the area of the polygons

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NRings(geometry)}} returns the number of rings (usually 1, more if there are holes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_ExteriorRing(polygon)}} returns the outer ring as a linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_InteriorRingN(polygon, integer)}} returns a specified interior ring as a linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Perimeter(geometry)}} returns the length of all the rings

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_NumGeometries(multi/geomcollection)}} returns the number of parts in the collection

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryN(geometry, integer)}} returns the specified part of the collection

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}} returns WKT \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsEWKT(geometry)}} returns EWKT \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromWKB(bytea)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsBinary(geometry)}} returns WKB \sphinxcode{\sphinxupquote{bytea}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsEWKB(geometry)}} returns EWKB \sphinxcode{\sphinxupquote{bytea}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromGML(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geometry)}} returns GML \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromKML(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsKML(geometry)}} returns KML \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGeoJSON(geometry)}} returns JSON \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsSVG(geometry)}} returns SVG \sphinxcode{\sphinxupquote{text}}

\end{itemize}

Also remember the tables we have available:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nyc\_census\_blocks}}
\begin{itemize}
\item {} 
blkid, popn\_total, boroname, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_streets}}
\begin{itemize}
\item {} 
name, type, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_subway\_stations}}
\begin{itemize}
\item {} 
name, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_neighborhoods}}
\begin{itemize}
\item {} 
name, boroname, geom

\end{itemize}

\end{itemize}


\subsection{Exercises}
\label{\detokenize{basic:exercises}}\begin{itemize}
\item {} 
\sphinxstylestrong{“What is the area of the ‘West Village’ neighborhood?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}West Village\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1044614.5296486}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The area is given in square meters. To get an area in hectares, divide by 10000. To get an area in acres, divide by 4047.
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{“What is the area of Manhattan in acres?”} (Hint: both \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} and \sphinxcode{\sphinxupquote{nyc\_neighborhoods}} have a \sphinxcode{\sphinxupquote{boroname}} in them.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{4047}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Manhattan\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{13965.3201224118}
\end{sphinxVerbatim}

or…

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{4047}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
  \PYG{k}{WHERE} \PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Manhattan\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{14601.3987215548}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“How many census blocks in New York City have a hole in them?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Count}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
  \PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}NumInteriorRings}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryN}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The ST\_NRings() functions might be tempting, but it also counts the exterior rings of multi-polygons as well as interior rings.  In order to run ST\_NumInteriorRings() we need to convert the MultiPolygon geometries of the blocks into simple polygons, so we extract the first polygon from each collection using ST\_GeometryN(). Yuck!
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{43}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What is the total length of streets (in kilometers) in New York City?”} (Hint: The units of measurement of the spatial data are meters, there are 1000 meters in a kilometer.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{1000}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{10418.9047172}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“How long is ‘Columbus Cir’ (Columbus Circle)?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Columbus Cir\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{308.34199}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What is the JSON representation of the boundary of the ‘West Village’?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsGeoJSON}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}West Village\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MultiPolygon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coordinates}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
 \PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{583263.2776595836}\PYG{p}{,}\PYG{l+m+mf}{4509242.6260239873}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{583276.81990686338}\PYG{p}{,}\PYG{l+m+mf}{4509378.825446927}\PYG{p}{]}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{[}\PYG{l+m+mf}{583263.2776595836}\PYG{p}{,}\PYG{l+m+mf}{4509242.6260239873}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The geometry type is “MultiPolygon”, interesting!

\item {} 
\sphinxstylestrong{“How many polygons are in the ‘West Village’ multipolygon?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}NumGeometries}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}West Village\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
It is not uncommon to find single-element MultiPolygons in spatial tables. Using MultiPolygons allows a table with only one geometry type to store both single- and multi-geometries without using mixed types.
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{“What is the length of streets in New York City, summarized by type?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{type}\PYG{p}{,} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{k}{length}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{k}{type}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{k}{length} \PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                       \PYG{n+nb}{type}                       \PYG{o}{\textbar{}}      \PYG{n}{length}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{residential}                                      \PYG{o}{\textbar{}} \PYG{l+m+mf}{8629870.33786606}
 \PYG{n}{motorway}                                         \PYG{o}{\textbar{}} \PYG{l+m+mf}{403622.478126363}
 \PYG{n}{tertiary}                                         \PYG{o}{\textbar{}} \PYG{l+m+mf}{360394.879051303}
 \PYG{n}{motorway\PYGZus{}link}                                    \PYG{o}{\textbar{}} \PYG{l+m+mf}{294261.419479668}
 \PYG{n}{secondary}                                        \PYG{o}{\textbar{}} \PYG{l+m+mf}{276264.303897926}
 \PYG{n}{unclassified}                                     \PYG{o}{\textbar{}} \PYG{l+m+mf}{166936.371604458}
 \PYG{n}{primary}                                          \PYG{o}{\textbar{}} \PYG{l+m+mf}{135034.233017947}
 \PYG{n}{footway}                                          \PYG{o}{\textbar{}} \PYG{l+m+mf}{71798.4878378096}
 \PYG{n}{service}                                          \PYG{o}{\textbar{}}  \PYG{l+m+mf}{28337.635038596}
 \PYG{n}{trunk}                                            \PYG{o}{\textbar{}} \PYG{l+m+mf}{20353.5819826076}
 \PYG{n}{cycleway}                                         \PYG{o}{\textbar{}} \PYG{l+m+mf}{8863.75144825929}
 \PYG{n}{pedestrian}                                       \PYG{o}{\textbar{}} \PYG{l+m+mf}{4867.05032825026}
 \PYG{n}{construction}                                     \PYG{o}{\textbar{}} \PYG{l+m+mf}{4803.08162103562}
 \PYG{n}{residential}\PYG{p}{;} \PYG{n}{motorway\PYGZus{}link}                       \PYG{o}{\textbar{}} \PYG{l+m+mf}{3661.57506293745}
 \PYG{n}{trunk\PYGZus{}link}                                       \PYG{o}{\textbar{}} \PYG{l+m+mf}{3202.18981240201}
 \PYG{n}{primary\PYGZus{}link}                                     \PYG{o}{\textbar{}} \PYG{l+m+mf}{2492.57457083536}
 \PYG{n}{living\PYGZus{}street}                                    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1894.63905457332}
 \PYG{n}{primary}\PYG{p}{;} \PYG{n}{residential}\PYG{p}{;} \PYG{n}{motorway\PYGZus{}link}\PYG{p}{;} \PYG{n}{residential} \PYG{o}{\textbar{}} \PYG{l+m+mf}{1367.76576941335}
 \PYG{n}{undefined}                                        \PYG{o}{\textbar{}}  \PYG{l+m+mf}{380.53861910346}
 \PYG{n}{steps}                                            \PYG{o}{\textbar{}} \PYG{l+m+mf}{282.745221342127}
 \PYG{n}{motorway\PYGZus{}link}\PYG{p}{;} \PYG{n}{residential}                       \PYG{o}{\textbar{}}  \PYG{l+m+mf}{215.07778911517}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{ORDER BY length DESC}} clause sorts the result by length in descending order. The result is that most prevalent types are first in the list.
\end{sphinxadmonition}

\end{itemize}


\section{Spatial Relationships}
\label{\detokenize{basic:spatial-relationships}}\label{\detokenize{basic:id9}}
So far we have only used spatial functions that measure (\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Length}}), serialize (\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML}}), and deserialize (\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText}}) geometries. What these functions have in common is that they only work on one geometry at a time.

Spatial databases are powerful because they not only store geometry, they also have the ability to compare \sphinxstyleemphasis{relationships between geometries}.

Questions like “Which are the closest bike racks to a park?” or “Where are the intersections of subway lines and streets?” can only be answered by comparing geometries representing the bike racks, streets, and subway lines.

The OGC standard defines the following set of methods to compare geometries.


\subsection{ST\_Equals}
\label{\detokenize{basic:st-equals}}
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Equals(geometry A, geometry B)}} tests the spatial equality of two geometries.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_equals}.png}
\end{figure}

ST\_Equals returns TRUE if two geometries of the same type have identical x,y coordinate values, i.e. if the second shape is equal (identical) to the first shape.

First, let’s retrieve a representation of a point from our \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} table. We’ll take just the entry for ‘Broad St’.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{name}   \PYG{o}{\textbar{}}                      \PYG{n}{geom}                          \PYG{o}{\textbar{}}      \PYG{n}{st\PYGZus{}astext}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Broad} \PYG{n}{St} \PYG{o}{\textbar{}} \PYG{l+m+mi}{0101000020266900000}\PYG{n}{EEBD4CF27CF2141BC17D69516315141} \PYG{o}{\textbar{}} \PYG{n}{POINT}\PYG{p}{(}\PYG{l+m+mi}{583571} \PYG{l+m+mi}{4506714}\PYG{p}{)}
\end{sphinxVerbatim}

Then, plug the geometry representation back into an \sphinxstyleliteralstrong{\sphinxupquote{ST\_Equals}} test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Equals}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0101000020266900000EEBD4CF27CF2141BC17D69516315141\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Broad} \PYG{n}{St}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The representation of the point was not very human readable (\sphinxcode{\sphinxupquote{0101000020266900000EEBD4CF27CF2141BC17D69516315141}}) but it was an exact representation of the coordinate values. For a test like equality, using the exact coordinates is necessary.
\end{sphinxadmonition}


\subsection{ST\_Intersects, ST\_Disjoint, ST\_Crosses and ST\_Overlaps}
\label{\detokenize{basic:st-intersects-st-disjoint-st-crosses-and-st-overlaps}}
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Crosses}}, and \sphinxstyleliteralstrong{\sphinxupquote{ST\_Overlaps}} test whether the interiors of the geometries intersect.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_intersects}.png}
\end{figure}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry A, geometry B)}} returns t (TRUE) if the two shapes have any space in common, i.e., if their boundaries or interiors intersect.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_disjoint}.png}
\end{figure}

The opposite of ST\_Intersects is \sphinxstyleliteralstrong{\sphinxupquote{ST\_Disjoint(geometry A , geometry B)}}. If two geometries are disjoint, they do not intersect, and vice-versa. In fact, it is often more efficient to test “not intersects” than to test “disjoint” because the intersects tests can be spatially indexed, while the disjoint test cannot.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_crosses}.png}
\end{figure}

For multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Crosses(geometry A, geometry B)}} returns t (TRUE) if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_overlaps}.png}
\end{figure}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Overlaps(geometry A, geometry B)}} compares two geometries of the same dimension and returns TRUE if their intersection set results in a geometry different from both but of the same dimension.

Let’s take our Broad Street subway station and determine its neighborhood using the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POINT}\PYG{p}{(}\PYG{l+m+mi}{583571} \PYG{l+m+mi}{4506714}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(583571 4506714)\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYG{n}{name}        \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Financial} \PYG{n}{District} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
\end{sphinxVerbatim}


\subsection{ST\_Touches}
\label{\detokenize{basic:st-touches}}
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Touches}} tests whether two geometries touch at their boundaries, but do not intersect in their interiors

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_touches}.png}
\end{figure}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Touches(geometry A, geometry B)}} returns TRUE if either of the geometries’ boundaries intersect or if only one of the geometry’s interiors intersects the other’s boundary.


\subsection{ST\_Within and ST\_Contains}
\label{\detokenize{basic:st-within-and-st-contains}}
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Within}} and \sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains}} test whether one geometry is fully within the other.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_within}.png}
\end{figure}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Within(geometry A , geometry B)}} returns TRUE if the first geometry is completely within the second geometry. ST\_Within tests for the exact opposite result of ST\_Contains.

\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains(geometry A, geometry B)}} returns TRUE if the second geometry is completely contained by the first geometry.


\subsection{ST\_Distance and ST\_DWithin}
\label{\detokenize{basic:st-distance-and-st-dwithin}}
An extremely common GIS question is “find all the stuff within distance X of this other stuff”.

The \sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geometry A, geometry B)}} calculates the \sphinxstyleemphasis{shortest} distance between two geometries and returns it as a float. This is useful for actually reporting back the distance between objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(0 5)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(\PYGZhy{}2 2, 2 2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

For testing whether two objects are within a distance of one another, the \sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin}} function provides an index-accelerated true/false test. This is useful for questions like “how many trees are within a 500 meter buffer of the road?”. You don’t have to calculate an actual buffer, you just have to test the distance relationship.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{st_dwithin}.png}
\end{figure}

Using our Broad Street subway station again, we can find the streets nearby (within 10 meters of) the subway stop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}
        \PYG{n}{geom}\PYG{p}{,}
        \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(583571 4506714)\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
        \PYG{l+m+mi}{10}
      \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
     \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
   \PYG{n}{Wall} \PYG{n}{St}
   \PYG{n}{Broad} \PYG{n}{St}
   \PYG{n}{Nassau} \PYG{n}{St}
\end{sphinxVerbatim}

And we can verify the answer on a map. The Broad St station is actually at the intersection of Wall, Broad and Nassau Streets.

\noindent\sphinxincludegraphics{{broad_st}.jpg}


\subsection{Function List}
\label{\detokenize{basic:id10}}
\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Contains.html}{ST\_Contains(geometry A, geometry B)}: Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Crosses.html}{ST\_Crosses(geometry A, geometry B)}: Returns TRUE if the supplied geometries have some, but not all, interior points in common.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Disjoint.html}{ST\_Disjoint(geometry A , geometry B)}: Returns TRUE if the Geometries do not “spatially intersect” - if they do not share any space together.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Distance.html}{ST\_Distance(geometry A, geometry B)}: Returns the 2-dimensional cartesian minimum distance (based on spatial ref) between two geometries in projected units.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_DWithin.html}{ST\_DWithin(geometry A, geometry B, radius)}: Returns true if the geometries are within the specified distance (radius) of one another.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Equals.html}{ST\_Equals(geometry A, geometry B)}: Returns true if the given geometries represent the same geometry. Directionality is ignored.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Intersects.html}{ST\_Intersects(geometry A, geometry B)}: Returns TRUE if the Geometries/Geography “spatially intersect” - (share any portion of space) and FALSE if they don’t (they are Disjoint).

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Overlaps.html}{ST\_Overlaps(geometry A, geometry B)}: Returns TRUE if the Geometries share space, are of the same dimension, but are not completely contained by each other.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Touches.html}{ST\_Touches(geometry A, geometry B)}: Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Within.html}{ST\_Within(geometry A , geometry B)}: Returns true if the geometry A is completely inside geometry B


\section{Spatial Relationships Exercises}
\label{\detokenize{basic:spatial-relationships-exercises}}\label{\detokenize{basic:id11}}
Here’s a reminder of the functions we saw in the last section. They should be useful for the exercises!
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sum(expression)}} aggregate to return a sum for a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{count(expression)}} aggregate to return the size of a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains(geometry A, geometry B)}} returns true if geometry A contains geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Crosses(geometry A, geometry B)}} returns true if geometry A crosses geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Disjoint(geometry A , geometry B)}} returns true if the geometries do not “spatially intersect”

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geometry A, geometry B)}} returns the minimum distance between geometry A and geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin(geometry A, geometry B, radius)}} returns true if geometry A is radius distance or less from geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Equals(geometry A, geometry B)}} returns true if geometry A is the same as geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry A, geometry B)}} returns true if geometry A intersects geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Overlaps(geometry A, geometry B)}} returns true if geometry A and geometry B share space, but are not completely contained by each other.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Touches(geometry A, geometry B)}} returns true if the boundary of geometry A touches geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Within(geometry A, geometry B)}} returns true if geometry A is within geometry B

\end{itemize}

Also remember the tables we have available:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nyc\_census\_blocks}}
\begin{itemize}
\item {} 
blkid, popn\_total, boroname, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_streets}}
\begin{itemize}
\item {} 
name, type, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_subway\_stations}}
\begin{itemize}
\item {} 
name, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_neighborhoods}}
\begin{itemize}
\item {} 
name, boroname, geom

\end{itemize}

\end{itemize}


\subsection{Exercises}
\label{\detokenize{basic:id12}}\begin{itemize}
\item {} 
\sphinxstylestrong{“What is the geometry value for the street named ‘Atlantic Commons’?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
  \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Atlantic Commons\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MULTILINESTRING}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{586781.701577724} \PYG{l+m+mf}{4504202.15314339}\PYG{p}{,}\PYG{l+m+mf}{586863.51964484} \PYG{l+m+mf}{4504215.9881701}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What neighborhood and borough is Atlantic Commons in?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}
  \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{name}    \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Fort} \PYG{n}{Green} \PYG{o}{\textbar{}} \PYG{n}{Brooklyn}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What streets does Atlantic Commons join with?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}
  \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
  \PYG{l+m+mi}{0}\PYG{p}{.}\PYG{l+m+mi}{1}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
     \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Cumberland} \PYG{n}{St}
 \PYG{n}{Atlantic} \PYG{n}{Commons}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{atlantic_commons}.jpg}

\item {} 
\sphinxstylestrong{“Approximately how many people live on (within 50 meters of) Atlantic Commons?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
  \PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}
   \PYG{n}{geom}\PYG{p}{,}
   \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586782 4504202,586864 4504216)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
   \PYG{l+m+mi}{50}
  \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1438}
\end{sphinxVerbatim}

\end{itemize}


\section{Spatial Joins}
\label{\detokenize{basic:spatial-joins}}\label{\detokenize{basic:joins}}
Spatial joins are the bread-and-butter of spatial databases.  They allow you to combine information from different tables by using spatial relationships as the join key.  Much of what we think of as “standard GIS analysis” can be expressed as spatial joins.

To review how joins work, here’s a step-by-step look at joining the neighborhoods and subway stations tables and then subsequently adding a simple where clause.  Joining two small tables effectively multiplies the number of rows into a much larger dataset with all possible combinations of the two tables.  Then we use a where clause (or two) to narrow our focus.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}129 neighborhoods}
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{boroname} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}491 subway stations}
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{borough} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}join produces 63339 rows (129 * 491)}
\PYG{k}{SELECT} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}\PYG{p}{,}
       \PYG{n}{s}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{borough}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{n}\PYG{p}{,} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}a simple where clause narrows this to 11058 rows}
\PYG{k}{SELECT} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}\PYG{p}{,}
       \PYG{n}{s}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{borough}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{n}\PYG{p}{,} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
 \PYG{k}{WHERE} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname} \PYG{o}{=} \PYG{n}{s}\PYG{p}{.}\PYG{n}{borough}
\end{sphinxVerbatim}

In the previous section, we explored spatial relationships using a two-step process: first we extracted a subway station point for ‘Broad St’; then, we used that point to ask further questions such as “what neighborhood is the ‘Broad St’ station in?”

Using a spatial join, we can answer the question in one step, retrieving information about the subway station and the neighborhood that contains it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{n}{subways}\PYG{p}{.}\PYG{n}{name} \PYG{k}{AS} \PYG{n}{subway\PYGZus{}name}\PYG{p}{,}
  \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{name} \PYG{k}{AS} \PYG{n}{neighborhood\PYGZus{}name}\PYG{p}{,}
  \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{boroname} \PYG{k}{AS} \PYG{n}{borough}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{neighborhoods}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{subways}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Contains}\PYG{p}{(}\PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{subway\PYGZus{}name} \PYG{o}{\textbar{}} \PYG{n}{neighborhood\PYGZus{}name}  \PYG{o}{\textbar{}}  \PYG{n}{borough}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Broad} \PYG{n}{St}    \PYG{o}{\textbar{}} \PYG{n}{Financial} \PYG{n}{District} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
\end{sphinxVerbatim}

We could have joined every subway station to its containing neighborhood, but in this case we wanted information about just one.  Any function that provides a true/false relationship between two tables can be used to drive a spatial join, but the most commonly used ones are: \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains}}, and \sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin}}.


\subsection{Join and Summarize}
\label{\detokenize{basic:join-and-summarize}}
The combination of a \sphinxcode{\sphinxupquote{JOIN}} with a \sphinxcode{\sphinxupquote{GROUP BY}} provides the kind of analysis that is usually done in a GIS system.

For example: \sphinxstylestrong{“What is the population and racial make-up of the neighborhoods of Manhattan?”} Here we have a question that combines information from about population from the census with the boundaries of neighborhoods, with a restriction to just one borough of Manhattan.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{name} \PYG{k}{AS} \PYG{n}{neighborhood\PYGZus{}name}\PYG{p}{,}
  \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{population}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{popn\PYGZus{}white}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{white\PYGZus{}pct}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{popn\PYGZus{}black}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{black\PYGZus{}pct}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{neighborhoods}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{AS} \PYG{n}{census}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{census}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{boroname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Manhattan\PYGZsq{}}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{name}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{white\PYGZus{}pct} \PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n}{neighborhood\PYGZus{}name}  \PYG{o}{\textbar{}} \PYG{n}{population} \PYG{o}{\textbar{}} \PYG{n}{white\PYGZus{}pct} \PYG{o}{\textbar{}} \PYG{n}{black\PYGZus{}pct}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Carnegie} \PYG{n}{Hill}       \PYG{o}{\textbar{}}      \PYG{l+m+mi}{18763} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{90.1} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{1.4}
 \PYG{n}{North} \PYG{n}{Sutton} \PYG{n}{Area}   \PYG{o}{\textbar{}}      \PYG{l+m+mi}{22460} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{87.6} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{1.6}
 \PYG{n}{West} \PYG{n}{Village}        \PYG{o}{\textbar{}}      \PYG{l+m+mi}{26718} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{87.6} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{2.2}
 \PYG{n}{Upper} \PYG{n}{East} \PYG{n}{Side}     \PYG{o}{\textbar{}}     \PYG{l+m+mi}{203741} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{85.0} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{2.7}
 \PYG{n}{Soho}                \PYG{o}{\textbar{}}      \PYG{l+m+mi}{15436} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{84.6} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{2.2}
 \PYG{n}{Greenwich} \PYG{n}{Village}   \PYG{o}{\textbar{}}      \PYG{l+m+mi}{57224} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{82.0} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{2.4}
 \PYG{n}{Central} \PYG{n}{Park}        \PYG{o}{\textbar{}}      \PYG{l+m+mi}{46600} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{79.5} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{8.0}
 \PYG{n}{Tribeca}             \PYG{o}{\textbar{}}      \PYG{l+m+mi}{20908} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{79.1} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.5}
 \PYG{n}{Gramercy}            \PYG{o}{\textbar{}}     \PYG{l+m+mi}{104876} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{75.5} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{4.7}
 \PYG{n}{Murray} \PYG{n}{Hill}         \PYG{o}{\textbar{}}      \PYG{l+m+mi}{29655} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{75.0} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{2.5}
 \PYG{n}{Chelsea}             \PYG{o}{\textbar{}}      \PYG{l+m+mi}{61340} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{74.8} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{6.4}
 \PYG{n}{Upper} \PYG{n}{West} \PYG{n}{Side}     \PYG{o}{\textbar{}}     \PYG{l+m+mi}{214761} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{74.6} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{9.2}
 \PYG{n}{Midtown}             \PYG{o}{\textbar{}}      \PYG{l+m+mi}{76840} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{72.6} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{5.2}
 \PYG{n}{Battery} \PYG{n}{Park}        \PYG{o}{\textbar{}}      \PYG{l+m+mi}{17153} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{71.8} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.4}
 \PYG{n}{Financial} \PYG{n}{District}  \PYG{o}{\textbar{}}      \PYG{l+m+mi}{34807} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{69.9} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.8}
 \PYG{n}{Clinton}             \PYG{o}{\textbar{}}      \PYG{l+m+mi}{32201} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{65.3} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{7.9}
 \PYG{n}{East} \PYG{n}{Village}        \PYG{o}{\textbar{}}      \PYG{l+m+mi}{82266} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{63.3} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{8.8}
 \PYG{n}{Garment} \PYG{n}{District}    \PYG{o}{\textbar{}}      \PYG{l+m+mi}{10539} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{55.2} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{7.1}
 \PYG{n}{Morningside} \PYG{n}{Heights} \PYG{o}{\textbar{}}      \PYG{l+m+mi}{42844} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{52.7} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{19.4}
 \PYG{n}{Little} \PYG{n}{Italy}        \PYG{o}{\textbar{}}      \PYG{l+m+mi}{12568} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{49.0} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{1.8}
 \PYG{n}{Yorkville}           \PYG{o}{\textbar{}}      \PYG{l+m+mi}{58450} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{35.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{29.7}
 \PYG{n}{Inwood}              \PYG{o}{\textbar{}}      \PYG{l+m+mi}{50047} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{35.2} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{16.8}
 \PYG{n}{Washington} \PYG{n}{Heights}  \PYG{o}{\textbar{}}     \PYG{l+m+mi}{169013} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{34.9} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{16.8}
 \PYG{n}{Lower} \PYG{n}{East} \PYG{n}{Side}     \PYG{o}{\textbar{}}      \PYG{l+m+mi}{96156} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{33.5} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{9.1}
 \PYG{n}{East} \PYG{n}{Harlem}         \PYG{o}{\textbar{}}      \PYG{l+m+mi}{60576} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{26.4} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{40.4}
 \PYG{n}{Hamilton} \PYG{n}{Heights}    \PYG{o}{\textbar{}}      \PYG{l+m+mi}{67432} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{23.9} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{35.8}
 \PYG{n}{Chinatown}           \PYG{o}{\textbar{}}      \PYG{l+m+mi}{16209} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{15.2} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.8}
 \PYG{n}{Harlem}              \PYG{o}{\textbar{}}     \PYG{l+m+mi}{134955} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{15.1} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{67.1}
\end{sphinxVerbatim}

What’s going on here? Notionally (the actual evaluation order is optimized under the covers by the database) this is what happens:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The \sphinxcode{\sphinxupquote{JOIN}} clause creates a virtual table that includes columns from both the neighborhoods and census tables.

\item {} 
The \sphinxcode{\sphinxupquote{WHERE}} clause filters our virtual table to just rows in Manhattan.

\item {} 
The remaining rows are grouped by the neighborhood name and fed through the aggregation function to \sphinxstyleliteralstrong{\sphinxupquote{Sum()}} the population values.

\item {} 
After a little arithmetic and formatting (e.g., \sphinxcode{\sphinxupquote{GROUP BY}}, \sphinxcode{\sphinxupquote{ORDER BY}}) on the final numbers, our query spits out the percentages.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{JOIN}} clause combines two \sphinxcode{\sphinxupquote{FROM}} items.  By default, we are using an \sphinxcode{\sphinxupquote{INNER JOIN}}, but there are four other types of joins. For further information see the \sphinxhref{http://www.postgresql.org/docs/9.1/interactive/sql-select.html\#SQL-FROM}{join\_type} definition in the PostgreSQL documentation.
\end{sphinxadmonition}

We can also use distance tests as a join key, to create summarized “all items within a radius” queries. Let’s explore the racial geography of New York using distance queries.

First, let’s get the baseline racial make-up of the city.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}white}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{white\PYGZus{}pct}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}black}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{black\PYGZus{}pct}\PYG{p}{,}
  \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{popn\PYGZus{}total}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{white\PYGZus{}pct}     \PYG{o}{\textbar{}}    \PYG{n}{black\PYGZus{}pct}     \PYG{o}{\textbar{}} \PYG{n}{popn\PYGZus{}total}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mf}{44.0039500762811} \PYG{o}{\textbar{}} \PYG{l+m+mf}{25.5465789002416} \PYG{o}{\textbar{}}    \PYG{l+m+mi}{8175032}
\end{sphinxVerbatim}

So, of the 8M people in New York, about 44\% are recorded as “white” and 26\% are recorded as “black”.

Duke Ellington once sang that “You / must take the A-train / To / go to Sugar Hill way up in Harlem.” As we saw earlier, Harlem has far and away the highest African-American population in Manhattan (80.5\%). Is the same true of Duke’s A-train?

First, note that the contents of the \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} table \sphinxcode{\sphinxupquote{routes}} field is what we are interested in to find the A-train. The values in there are a little complex.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{n}{routes} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{routes}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}

\PYG{n}{N}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{J}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{R}
\PYG{n}{D}\PYG{p}{,}\PYG{n}{F}\PYG{p}{,}\PYG{n}{N}\PYG{p}{,}\PYG{n}{Q}
\PYG{n}{J}\PYG{p}{,}\PYG{n}{M}
\PYG{n}{E}\PYG{p}{,}\PYG{n}{F}
\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{n}{N}
\PYG{n}{N}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{n}{E}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{D}
\PYG{n}{J}\PYG{p}{,}\PYG{n}{Z}
\PYG{l+m+mi}{6}
\PYG{l+m+mi}{2}
\PYG{n}{M}\PYG{p}{,}\PYG{n}{D}
\PYG{n}{N}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{L}\PYG{p}{,}\PYG{n}{N}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{F}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{M}
\PYG{l+m+mi}{4}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{D}\PYG{p}{,}\PYG{n}{M}
\PYG{n}{N}\PYG{p}{,}\PYG{n}{R}
\PYG{n}{N}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{S}\PYG{p}{,}\PYG{n}{W}\PYG{p}{,}\PYG{l+m+mi}{7}
\PYG{n}{D}
\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{n}{F}\PYG{p}{,}\PYG{n}{Q}
\PYG{n}{D}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{N}\PYG{p}{,}\PYG{n}{R}
\PYG{n}{Q}
\PYG{n}{E}
\PYG{n}{E}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{E}\PYG{p}{,}\PYG{n}{F}\PYG{p}{,}\PYG{n}{G}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}
\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}
\PYG{n}{E}\PYG{p}{,}\PYG{n}{J}\PYG{p}{,}\PYG{n}{Z}
\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}
\PYG{l+m+mi}{7}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{D}
\PYG{n}{G}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{N}\PYG{p}{,}\PYG{n}{W}\PYG{p}{,}\PYG{l+m+mi}{7}
\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}
\PYG{l+m+mi}{5}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{n}{F}\PYG{p}{,}\PYG{n}{N}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{V}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{S}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{E}\PYG{p}{,}\PYG{n}{L}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{F}
\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}
\PYG{n}{M}\PYG{p}{,}\PYG{n}{R}
\PYG{n}{R}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{S}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{Q}
\PYG{n}{C}
\PYG{n}{F}\PYG{p}{,}\PYG{n}{J}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{Z}
\PYG{n}{C}\PYG{p}{,}\PYG{n}{E}
\PYG{l+m+mi}{1}
\PYG{n}{F}
\PYG{n}{J}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{Z}
\PYG{n}{G}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{E}
\PYG{l+m+mi}{3}
\PYG{n}{B}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{n}{F}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{R}\PYG{p}{,}\PYG{n}{W}
\PYG{n}{S}
\PYG{n}{E}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{F}\PYG{p}{,}\PYG{n}{G}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{G}
\PYG{n}{A}
\PYG{n}{F}\PYG{p}{,}\PYG{n}{L}\PYG{p}{,}\PYG{n}{V}
\PYG{n}{L}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{DISTINCT}} keyword eliminates duplicate rows from the result.  Without the \sphinxcode{\sphinxupquote{DISTINCT}} keyword, the query above identifies 491 results instead of 73.
\end{sphinxadmonition}

So to find the A-train, we will want any row in \sphinxcode{\sphinxupquote{routes}} that has an ‘A’ in it. We can do this a number of ways, but today we will use the fact that \sphinxstyleliteralstrong{\sphinxupquote{strpos(routes,'A')}} will return a non-zero number only if ‘A’ is in the \sphinxcode{\sphinxupquote{routes}} field.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{n}{routes}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{subways}
\PYG{k}{WHERE} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{subways}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}A\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{D}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{E}\PYG{p}{,}\PYG{n}{L}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{F}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{S}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{E}
\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{G}
\PYG{n}{A}
\end{sphinxVerbatim}

Let’s summarize the racial make-up of within 200 meters of the A-train line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}white}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{white\PYGZus{}pct}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}black}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{black\PYGZus{}pct}\PYG{p}{,}
  \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{popn\PYGZus{}total}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{AS} \PYG{n}{census}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{subways}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{subways}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}A\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{white\PYGZus{}pct}     \PYG{o}{\textbar{}}    \PYG{n}{black\PYGZus{}pct}     \PYG{o}{\textbar{}} \PYG{n}{popn\PYGZus{}total}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mf}{45.5901255900202} \PYG{o}{\textbar{}} \PYG{l+m+mf}{22.0936235670937} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{189824}
\end{sphinxVerbatim}

So the racial make-up along the A-train isn’t radically different from the make-up of New York City as a whole.


\subsection{Advanced Join}
\label{\detokenize{basic:advanced-join}}
In the last section we saw that the A-train didn’t serve a population that differed much from the racial make-up of the rest of the city. Are there any trains that have a non-average racial make-up?

To answer that question, we’ll add another join to our query, so that we can simultaneously calculate the make-up of many subway lines at once. To do that, we’ll need to create a new table that enumerates all the lines we want to summarize.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{subway\PYGZus{}lines} \PYG{p}{(} \PYG{n}{route} \PYG{n+nb}{char}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{subway\PYGZus{}lines} \PYG{p}{(}\PYG{n}{route}\PYG{p}{)} \PYG{k}{VALUES}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}A\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}B\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}C\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}D\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}E\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}F\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}G\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}J\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}L\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}M\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}N\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Q\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}R\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}S\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Z\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}3\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}4\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}5\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}6\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}7\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now we can join the table of subway lines onto our original query.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{n}{lines}\PYG{p}{.}\PYG{n}{route}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}white}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{white\PYGZus{}pct}\PYG{p}{,}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}black}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{black\PYGZus{}pct}\PYG{p}{,}
  \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{popn\PYGZus{}total}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{AS} \PYG{n}{census}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{subways}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{k}{JOIN} \PYG{n}{subway\PYGZus{}lines} \PYG{k}{AS} \PYG{n}{lines}
\PYG{k}{ON} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{subways}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{n}{lines}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{lines}\PYG{p}{.}\PYG{n}{route}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{black\PYGZus{}pct} \PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{route} \PYG{o}{\textbar{}} \PYG{n}{white\PYGZus{}pct} \PYG{o}{\textbar{}} \PYG{n}{black\PYGZus{}pct} \PYG{o}{\textbar{}} \PYG{n}{popn\PYGZus{}total}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{S}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{39.8} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{46.5} \PYG{o}{\textbar{}}      \PYG{l+m+mi}{33301}
 \PYG{l+m+mi}{3}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{42.7} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{42.1} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{223047}
 \PYG{l+m+mi}{5}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{33.8} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{41.4} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{218919}
 \PYG{l+m+mi}{2}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{39.3} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{38.4} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{291661}
 \PYG{n}{C}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{46.9} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{30.6} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{224411}
 \PYG{l+m+mi}{4}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{37.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{27.4} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{174998}
 \PYG{n}{B}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{40.0} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{26.9} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{256583}
 \PYG{n}{A}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{45.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{22.1} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{189824}
 \PYG{n}{J}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{37.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{21.6} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{132861}
 \PYG{n}{Q}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{56.9} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{20.6} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{127112}
 \PYG{n}{Z}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{38.4} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{20.2} \PYG{o}{\textbar{}}      \PYG{l+m+mi}{87131}
 \PYG{n}{D}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{39.5} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{19.4} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{234931}
 \PYG{n}{L}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{57.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{16.8} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{110118}
 \PYG{n}{G}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{49.6} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{16.1} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{135012}
 \PYG{l+m+mi}{6}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{52.3} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{15.7} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{260240}
 \PYG{l+m+mi}{1}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{59.1} \PYG{o}{\textbar{}}      \PYG{l+m+mf}{11.3} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{327742}
 \PYG{n}{F}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{60.9} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{7.5} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{229439}
 \PYG{n}{M}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{56.5} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{6.4} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{174196}
 \PYG{n}{E}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{66.8} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{4.7} \PYG{o}{\textbar{}}      \PYG{l+m+mi}{90958}
 \PYG{n}{R}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{58.5} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{4.0} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{196999}
 \PYG{l+m+mi}{7}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{35.7} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.5} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{102401}
 \PYG{n}{N}     \PYG{o}{\textbar{}}      \PYG{l+m+mf}{59.7} \PYG{o}{\textbar{}}       \PYG{l+m+mf}{3.5} \PYG{o}{\textbar{}}     \PYG{l+m+mi}{147792}
\end{sphinxVerbatim}

As before, the joins create a virtual table of all the possible combinations available within the constraints of the \sphinxcode{\sphinxupquote{JOIN ON}} restrictions, and those rows are then fed into a \sphinxcode{\sphinxupquote{GROUP}} summary. The spatial magic is in the \sphinxcode{\sphinxupquote{ST\_DWithin}} function, that ensures only census blocks close to the appropriate subway stations are included in the calculation.


\subsection{Function List}
\label{\detokenize{basic:id13}}
\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Contains.html}{ST\_Contains(geometry A, geometry B)}: Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_DWithin.html}{ST\_DWithin(geometry A, geometry B, radius)}: Returns true if the geometries are within the specified distance of one another.

\sphinxhref{http://postgis.net/docs/manual-2.1/ST\_Intersects.html}{ST\_Intersects(geometry A, geometry B)}: Returns TRUE if the Geometries/Geography “spatially intersect” - (share any portion of space) and FALSE if they don’t (they are Disjoint).

\sphinxhref{http://www.postgresql.org/docs/current/interactive/functions-math.html}{round(v numeric, s integer)}: PostgreSQL math function that rounds to s decimal places

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-string.html}{strpos(string, substring)}: PostgreSQL string function that returns an integer location of a specified substring.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{sum(expression)}: PostgreSQL aggregate function that returns the sum of records in a set of records.


\section{Spatial Joins Exercises}
\label{\detokenize{basic:spatial-joins-exercises}}\label{\detokenize{basic:joins-exercises}}
Here’s a reminder of some of the functions we have seen.  Hint: they should be useful for the exercises!
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sum(expression)}}: aggregate to return a sum for a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{count(expression)}}: aggregate to return the size of a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}} returns the area of the polygons

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}} returns WKT \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains(geometry A, geometry B)}} returns the true if geometry A contains geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geometry A, geometry B)}} returns the minimum distance between geometry A and geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin(geometry A, geometry B, radius)}} returns the true if geometry A is radius distance or less from geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry A, geometry B)}} returns the true if geometry A intersects geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(linestring)}} returns the length of the linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Touches(geometry A, geometry B)}} returns the true if the boundary of geometry A touches geometry B

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Within(geometry A, geometry B)}} returns the true if geometry A is within geometry B

\end{itemize}

Also remember the tables we have available:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nyc\_census\_blocks}}
\begin{itemize}
\item {} 
name, popn\_total, boroname, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_streets}}
\begin{itemize}
\item {} 
name, type, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_subway\_stations}}
\begin{itemize}
\item {} 
name, routes, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_neighborhoods}}
\begin{itemize}
\item {} 
name, boroname, geom

\end{itemize}

\end{itemize}


\subsection{Exercises}
\label{\detokenize{basic:id18}}\begin{itemize}
\item {} 
\sphinxstylestrong{“What subway station is in ‘Little Italy’? What subway route is it on?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{s}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{n}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Contains}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Little Italy\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Recall: the function \sphinxcode{\sphinxupquote{AS}} is used to give a table another name by using an alias, which can make queries easier to read and write. In this case, \sphinxcode{\sphinxupquote{s}} is an alias for \sphinxcode{\sphinxupquote{nyc\_subway\_stations}}, \sphinxcode{\sphinxupquote{n}} is an alias for \sphinxcode{\sphinxupquote{nyc\_neighborhoods}}, \sphinxcode{\sphinxupquote{s.name}} refers to the name column in the \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} table, etc.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{name}    \PYG{o}{\textbar{}} \PYG{n}{routes}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Spring} \PYG{n}{St} \PYG{o}{\textbar{}} \PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What are all the neighborhoods served by the 6-train?”} (Hint: The \sphinxcode{\sphinxupquote{routes}} column in the \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} table has values like ‘B,D,6,V’ and ‘C,6’)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{AS} \PYG{n}{s}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{n}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Contains}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}6\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYG{n}{name}        \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Chinatown}          \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{East} \PYG{n}{Harlem}        \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Financial} \PYG{n}{District} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Gramercy}           \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Greenwich} \PYG{n}{Village}  \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Hunts} \PYG{n}{Point}        \PYG{o}{\textbar{}} \PYG{n}{The} \PYG{n}{Bronx}
 \PYG{n}{Little} \PYG{n}{Italy}       \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Midtown}            \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Mott} \PYG{n}{Haven}         \PYG{o}{\textbar{}} \PYG{n}{The} \PYG{n}{Bronx}
 \PYG{n}{Murray} \PYG{n}{Hill}        \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Parkchester}        \PYG{o}{\textbar{}} \PYG{n}{The} \PYG{n}{Bronx}
 \PYG{n}{Soundview}          \PYG{o}{\textbar{}} \PYG{n}{The} \PYG{n}{Bronx}
 \PYG{n}{South} \PYG{n}{Bronx}        \PYG{o}{\textbar{}} \PYG{n}{The} \PYG{n}{Bronx}
 \PYG{n}{Upper} \PYG{n}{East} \PYG{n}{Side}    \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
 \PYG{n}{Yorkville}          \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
We used the \sphinxcode{\sphinxupquote{DISTINCT}} keyword to remove duplicate values from our result set where there were more than one subway station in a neighborhood.
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{“After 9/11, the ‘Battery Park’ neighborhood was off limits for several days. How many people had to be evacuated?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{n}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{AS} \PYG{k}{c}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{k}{c}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Battery Park\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{17153}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What are the population density (people / km\textasciicircum{}2) of the ‘Upper West Side’ and ‘Upper East Side’?”} (Hint: There are 1000000 m\textasciicircum{}2 in one km\textasciicircum{}2.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,}
  \PYG{k}{Sum}\PYG{p}{(}\PYG{k}{c}\PYG{p}{.}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{1000000}\PYG{p}{.}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{popn\PYGZus{}per\PYGZus{}sqkm}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{AS} \PYG{k}{c}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{k}{AS} \PYG{n}{n}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{k}{c}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Upper West Side\PYGZsq{}}
\PYG{k}{OR} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Upper East Side\PYGZsq{}}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{name}       \PYG{o}{\textbar{}}  \PYG{n}{popn\PYGZus{}per\PYGZus{}sqkm}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Upper} \PYG{n}{East} \PYG{n}{Side} \PYG{o}{\textbar{}} \PYG{l+m+mf}{48524.4877489857}
 \PYG{n}{Upper} \PYG{n}{West} \PYG{n}{Side} \PYG{o}{\textbar{}} \PYG{l+m+mf}{40152.4896080024}
\end{sphinxVerbatim}

\end{itemize}


\section{Spatial Indexing}
\label{\detokenize{basic:spatial-indexing}}\label{\detokenize{basic:indexing}}
Recall that spatial index is one of the three key features of a spatial database. Indexes are what make using a spatial database for large data sets possible. Without indexing, any search for a feature would require a “sequential scan” of every record in the database. Indexing speeds up searching by organizing the data into a search tree which can be quickly traversed to find a particular record.

Spatial indices are one of the greatest assets of PostGIS.  In the previous example building spatial joins requires comparing whole tables with each other. This can get very costly: joining two tables of 10,000 records each without indexes would require 100,000,000 comparisons; with indexes the cost could be as low as 20,000 comparisons.

When we loaded the \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table, the QGIS DB Manager was set to automatically create a spatial index called \sphinxcode{\sphinxupquote{sidx\_nyc\_census\_blocks\_geom}}

To demonstrate how important indexes are for performance, let’s search \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} \sphinxstylestrong{without} our spatial index.

Our first step is to remove the index.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{DROP} \PYG{k}{INDEX} \PYG{n}{sidx\PYGZus{}nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}geom}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{DROP INDEX}} statement drops an existing index from the database system. For more information, see the PostgreSQL \sphinxhref{https://www.postgresql.org/docs/11/sql-dropindex.html}{documentation}.
\end{sphinxadmonition}

Now, watch the “Timing” meter at the lower right-hand corner of the pgAdmin query window and run the following. Our query searches through every single census block in order to identify the Broad Street entry.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{blocks}\PYG{p}{.}\PYG{n}{blkid}
 \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{blocks}
 \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subways}
 \PYG{k}{ON} \PYG{n}{ST\PYGZus{}Contains}\PYG{p}{(}\PYG{n}{blocks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
 \PYG{k}{WHERE} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{blkid}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{360610007001009}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table is very small (only a few thousand records) so even without an index, the query only takes \sphinxstylestrong{103 ms} on my test computer.

Now add the spatial index back in and run the query again.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{sidx\PYGZus{}nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}geom}
  \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
  \PYG{k}{USING} \PYG{n}{GIST} \PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{USING GIST}} clause tells PostgreSQL to use the generic index structure (GIST) when building the index.  If you receive an error that looks like \sphinxcode{\sphinxupquote{ERROR: index row requires 11340 bytes, maximum size is 8191}} when creating your index, you have likely neglected to add the \sphinxcode{\sphinxupquote{USING GIST}} clause.
\end{sphinxadmonition}

On my test computer the time drops to \sphinxstylestrong{66 ms}. The larger your table, the larger the relative speed improvement of an indexed query will be.


\subsection{How Spatial Indexes Work}
\label{\detokenize{basic:how-spatial-indexes-work}}
Standard database indexes create a hierarchical tree based on the values of the column being indexed. Spatial indexes are a little different \textendash{} they are unable to index the geometric features themselves  and instead index the bounding boxes of the features.

\noindent\sphinxincludegraphics{{bbox}.png}

In the figure above, the number of lines that intersect the yellow star is \sphinxstylestrong{one}, the red line. But the bounding boxes of features that intersect the yellow box is \sphinxstylestrong{two}, the red and blue ones.

The way the database efficiently answers the question “what lines intersect the yellow star” is to first answer the question “what boxes intersect the yellow box” using the index (which is very fast) and then do an exact calculation of “what lines intersect the yellow star” \sphinxstylestrong{only for those features returned by the first test}.

For a large table, this “two pass” system of evaluating the approximate index first, then carrying out an exact test can radically reduce the amount of calculations necessary to answer a query.

Both PostGIS and Oracle Spatial share the same “R-Tree” %
\begin{footnote}[2]\sphinxAtStartFootnote
\sphinxurl{http://postgis.org/support/rtree.pdf}
%
\end{footnote} spatial index structure. R-Trees break up data into rectangles, and sub-rectangles, and sub-sub rectangles, etc.  It is a self-tuning index structure that automatically handles variable data density and object size.

\noindent\sphinxincludegraphics{{index-01}.png}


\subsection{Index-Only Queries}
\label{\detokenize{basic:index-only-queries}}
Most of the commonly used functions in PostGIS (\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin}}, etc) include an index filter automatically. But some functions (e.g., \sphinxstyleliteralstrong{\sphinxupquote{ST\_Relate}}) do not include an index filter.

To do a bounding-box search using the index (and no filtering), make use of the \sphinxstyleliteralstrong{\sphinxupquote{\&\&}} operator. For geometries, the \sphinxstyleliteralstrong{\sphinxupquote{\&\&}} operator means “bounding boxes overlap or touch” in the same way that for number the \sphinxstyleliteralstrong{\sphinxupquote{=}} operator means “values are the same”.

Let’s compare an index-only query for the population of the ‘West Village’ to a more exact query. Using \sphinxstyleliteralstrong{\sphinxupquote{\&\&}} our index-only query looks like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{neighborhoods}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{blocks}
\PYG{k}{ON} \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{blocks}\PYG{p}{.}\PYG{n}{geom}
\PYG{k}{WHERE} \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}West Village\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{49821}
\end{sphinxVerbatim}

Now let’s do the same query using the more exact \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{neighborhoods}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{blocks}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{blocks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{neighborhoods}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}West Village\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{26718}
\end{sphinxVerbatim}

A much lower answer! The first query summed up every block that intersected the neighborhood’s bounding box; the second query only summed up those blocks that intersected the neighborhood itself.


\subsection{Analyzing}
\label{\detokenize{basic:analyzing}}
The PostgreSQL query planner intelligently chooses when to use or not to use indexes to evaluate a query. Counter-intuitively, it is not always faster to do an index search: if the search is going to return every record in the table, traversing the index tree to get each record will actually be slower than just linearly reading the whole table from the start.

In order to figure out what situation it is dealing with (reading a small part of the table versus reading a large portion of the table), PostgreSQL keeps statistics about the distribution of data in each indexed table column.  By default, PostgreSQL gathers statistics on a regular basis. However, if you dramatically change the make-up of your table within a short period of time, the statistics will not be up-to-date.

To ensure your statistics match your table contents, it is wise to run the \sphinxcode{\sphinxupquote{ANALYZE}} command after bulk data loads and deletes in your tables. This force the statistics system to gather data for all your indexed columns.

The \sphinxcode{\sphinxupquote{ANALYZE}} command asks PostgreSQL to traverse the table and update its internal statistics used for query plan estimation (query plan analysis will be discussed later).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ANALYZE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Vacuuming}
\label{\detokenize{basic:vacuuming}}
It’s worth stressing that just creating an index is not enough to allow PostgreSQL to use it effectively.  VACUUMing must be performed whenever a new index is created or after a large number of UPDATEs, INSERTs or DELETEs are issued against a table.  The \sphinxcode{\sphinxupquote{VACUUM}} command asks PostgreSQL to reclaim any unused space in the table pages left by updates or deletes to records.

Vacuuming is so critical for the efficient running of the database that PostgreSQL provides an “autovacuum” option.

Enabled by default, autovacuum both vacuums (recovers space) and analyzes (updates statistics) on your tables at sensible intervals determined by the level of activity.  While this is essential for highly transactional databases, it is not advisable to wait for an autovacuum run after adding indices or bulk-loading data.  If a large batch update is performed, you should manually run \sphinxcode{\sphinxupquote{VACUUM}}.

Vacuuming and analyzing the database can be performed separately as needed.  Issuing \sphinxcode{\sphinxupquote{VACUUM}} command will not update the database statistics; likewise issuing an \sphinxcode{\sphinxupquote{ANALYZE}} command will not recover unused table rows.  Both commands can be run against the entire database, a single table, or a single column.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{VACUUM} \PYG{k}{ANALYZE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Function List}
\label{\detokenize{basic:id20}}
\sphinxhref{https://postgis.net/docs/manual-1.5/ST\_Geometry\_Overlap.html}{geometry\_a \&\& geometry\_b}: Returns TRUE if A’s bounding box overlaps B’s.

\sphinxhref{https://postgis.net/docs/ST\_Geometry\_EQ.html}{geometry\_a = geometry\_b}: Returns TRUE if A’s bounding box is the same as B’s.

\sphinxhref{https://postgis.net/docs/ST\_Intersects.html}{ST\_Intersects(geometry\_a, geometry\_b)}: Returns TRUE if the Geometries/Geography “spatially intersect” - (share any portion of space) and FALSE if they don’t (they are Disjoint).


\section{Projecting Data}
\label{\detokenize{basic:projecting-data}}\label{\detokenize{basic:projection}}
The earth is not flat, and there is no simple way of putting it down on a flat paper map (or computer screen), so people have come up with all sorts of ingenious solutions, each with pros and cons. Some projections preserve area, so all objects have a relative size to each other; other projections preserve angles (conformal) like the Mercator projection; some projections try to find a good intermediate mix with only little distortion on several parameters. Common to all projections is that they transform the (spherical) world onto a flat Cartesian coordinate system, and which projection to choose depends on how you will be using the data.

We’ve already encountered projections when we \DUrole{xref,std,std-ref}{loaded our nyc data}.  (Recall that pesky SRID 26918).  Sometimes, however, you need to transform and re-project between spatial reference systems. PostGIS includes built-in support for changing the projection of data, using the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Transform(geometry, srid)}} function. For managing the spatial reference identifiers on geometries, PostGIS provides the \sphinxstyleliteralstrong{\sphinxupquote{ST\_SRID(geometry)}} and \sphinxstyleliteralstrong{\sphinxupquote{ST\_SetSRID(geometry, srid)}} functions.

We can confirm the SRID of our data with the \sphinxstyleliteralstrong{\sphinxupquote{ST\_SRID}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}SRID}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{26918}
\end{sphinxVerbatim}

And what is definition of “26918”? As we saw in “\DUrole{xref,std,std-ref}{loading data section}”, the definition is contained in the \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} table. In fact, \sphinxstylestrong{two} definitions are there. The “well-known text” ({\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}}) definition is in the \sphinxcode{\sphinxupquote{srtext}} column, and there is a second definition in “proj.4” format in the \sphinxcode{\sphinxupquote{proj4text}} column.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys} \PYG{k}{WHERE} \PYG{n}{srid} \PYG{o}{=} \PYG{l+m+mi}{26918}\PYG{p}{;}
\end{sphinxVerbatim}

In fact, for the internal PostGIS re-projection calculations, it is the contents of the \sphinxcode{\sphinxupquote{proj4text}} column that are used. For our 26918 projection, here is the proj.4 text:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{proj4text} \PYG{k}{FROM} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys} \PYG{k}{WHERE} \PYG{n}{srid} \PYG{o}{=} \PYG{l+m+mi}{26918}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{n}{proj}\PYG{o}{=}\PYG{n}{utm} \PYG{o}{+}\PYG{n}{zone}\PYG{o}{=}\PYG{l+m+mi}{18} \PYG{o}{+}\PYG{n}{ellps}\PYG{o}{=}\PYG{n}{GRS80} \PYG{o}{+}\PYG{n}{datum}\PYG{o}{=}\PYG{n}{NAD83} \PYG{o}{+}\PYG{n}{units}\PYG{o}{=}\PYG{n}{m} \PYG{o}{+}\PYG{n}{no\PYGZus{}defs}
\end{sphinxVerbatim}

In practice, both the \sphinxcode{\sphinxupquote{srtext}} and the \sphinxcode{\sphinxupquote{proj4text}} columns are important: the \sphinxcode{\sphinxupquote{srtext}} column is used by external programs like \sphinxhref{http://geoserver.org}{GeoServer}, \sphinxhref{udig.refractions.net}{uDig}, and \sphinxhref{http://www.safe.com/}{FME}  and others; the \sphinxcode{\sphinxupquote{proj4text}} column is used internally.


\subsection{Comparing Data}
\label{\detokenize{basic:comparing-data}}
Taken together, a coordinate and an SRID define a location on the globe. Without an SRID, a coordinate is just an abstract notion. A “Cartesian” coordinate plane is defined as a “flat” coordinate system placed on the surface of Earth. Because PostGIS functions work on such a plane, comparison operations require that both geometries be represented in the same SRID.

If you feed in geometries with differing SRIDs you will just get an error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Equals}\PYG{p}{(}
         \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{,}
         \PYG{n}{ST\PYGZus{}GeomFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{26918}\PYG{p}{)}
         \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ERROR}\PYG{p}{:}  \PYG{n}{Operation} \PYG{n}{on} \PYG{n}{mixed} \PYG{n}{SRID} \PYG{n}{geometries}
\PYG{n}{CONTEXT}\PYG{p}{:}  \PYG{n}{SQL} \PYG{n}{function} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{st\PYGZus{}equals}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{statement} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Be careful of getting too happy with using \sphinxstyleliteralstrong{\sphinxupquote{ST\_Transform}} for on-the-fly conversion. Spatial indexes are built using SRID of the stored geometries.  If comparison are done in a different SRID, spatial indexes are (often) not used. It is best practice to choose \sphinxstylestrong{one SRID} for all the tables in your database. Only use the transformation function when you are reading or writing data to external applications.
\end{sphinxadmonition}


\subsection{Transforming Data}
\label{\detokenize{basic:transforming-data}}
If we return to our proj4 definition for SRID 26918, we can see that our working projection is UTM (Universal Transverse Mercator) of zone 18, with meters as the unit of measurement.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{n}{proj}\PYG{o}{=}\PYG{n}{utm} \PYG{o}{+}\PYG{n}{zone}\PYG{o}{=}\PYG{l+m+mi}{18} \PYG{o}{+}\PYG{n}{ellps}\PYG{o}{=}\PYG{n}{GRS80} \PYG{o}{+}\PYG{n}{datum}\PYG{o}{=}\PYG{n}{NAD83} \PYG{o}{+}\PYG{n}{units}\PYG{o}{=}\PYG{n}{m} \PYG{o}{+}\PYG{n}{no\PYGZus{}defs}
\end{sphinxVerbatim}

Let’s convert some data from our working projection to geographic coordinates \textendash{} also known as “longitude/latitude”.

To convert data from one SRID to another, you must first verify that your geometry has a valid SRID. Since we have already confirmed a valid SRID, we next need the SRID of the projection to transform into. In other words, what is the SRID of geographic coordinates?

The most common SRID for geographic coordinates is 4326, which corresponds to “longitude/latitude on the WGS84 spheroid”. You can see the definition at the spatialreference.org site:
\begin{quote}

\sphinxurl{http://spatialreference.org/ref/epsg/4326/}
\end{quote}

You can also pull the definitions from the \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} table:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{srtext} \PYG{k}{FROM} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys} \PYG{k}{WHERE} \PYG{n}{srid} \PYG{o}{=} \PYG{l+m+mi}{4326}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{WGS 84}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{WGS\PYGZus{}1984}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{WGS 84}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{6378137}\PYG{p}{,}\PYG{l+m+mf}{298.257223563}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7030}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6326}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Greenwich}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8901}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{degree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.01745329251994328}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{9122}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4326}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

Let’s convert the coordinates of the ‘Broad St’ subway station into geographics:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POINT}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{74.0106714688735} \PYG{l+m+mf}{40.7071048155841}\PYG{p}{)}
\end{sphinxVerbatim}

If you load data or create a new geometry without specifying an SRID, the SRID value will be 0.  Recall in \DUrole{xref,std,std-ref}{geometries}, that when we created our \sphinxcode{\sphinxupquote{geometries}} table we didn’t specify an SRID. If we query our database, we should expect all the \sphinxcode{\sphinxupquote{nyc\_}} tables to have an SRID of 26918, while  the \sphinxcode{\sphinxupquote{geometries}} table defaulted to an SRID of 0.

To view a table’s SRID assignment, query the database’s \sphinxcode{\sphinxupquote{geometry\_columns}} table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{f\PYGZus{}table\PYGZus{}name} \PYG{k}{AS} \PYG{n}{name}\PYG{p}{,} \PYG{n}{srid}
\PYG{k}{FROM} \PYG{n}{geometry\PYGZus{}columns}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYG{n}{name}         \PYG{o}{\textbar{}} \PYG{n}{srid}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{26918}
 \PYG{n}{nyc\PYGZus{}neighborhoods}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{26918}
 \PYG{n}{nyc\PYGZus{}streets}         \PYG{o}{\textbar{}} \PYG{l+m+mi}{26918}
 \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{o}{\textbar{}} \PYG{l+m+mi}{26918}
 \PYG{n}{geometries}          \PYG{o}{\textbar{}}     \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

However, if you know what the SRID of the coordinates is supposed to be, you can set it post-facto, using \sphinxstyleliteralstrong{\sphinxupquote{ST\_SetSRID}} on the geometry. Then you will be able to transform the geometry into other systems.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}
 \PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}
   \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
 \PYG{l+m+mi}{4326}\PYG{p}{)}
\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{geometries}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Function List}
\label{\detokenize{basic:id23}}
\sphinxhref{http://postgis.net/docs/ST\_AsText.html}{ST\_AsText}: Returns the Well-Known Text (WKT) representation of the geometry/geography without SRID metadata.

\sphinxhref{http://postgis.net/docs/ST\_SetSRID.html}{ST\_SetSRID(geometry, srid)}: Sets the SRID on a geometry to a particular integer value.

\sphinxhref{http://postgis.net/docs/ST\_SRID.html}{ST\_SRID(geometry)}: Returns the spatial reference identifier for the ST\_Geometry as defined in spatial\_ref\_sys table.

\sphinxhref{http://postgis.net/docs/ST\_Transform.html}{ST\_Transform(geometry, srid)}: Returns a new geometry with its coordinates transformed to the SRID referenced by the integer parameter.


\section{Projection Exercises}
\label{\detokenize{basic:projection-exercises}}\label{\detokenize{basic:id25}}
Here’s a reminder of some of the functions we have seen.  Hint: they should be useful for the exercises!
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sum(expression)}} aggregate to return a sum for a set of records

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(linestring)}} returns the length of the linestring

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_SRID(geometry, srid)}} returns the SRID of the geometry

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Transform(geometry, srid)}} converts geometries into different spatial reference systems

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText(text)}} returns \sphinxcode{\sphinxupquote{geometry}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}} returns WKT \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geometry)}} returns GML \sphinxcode{\sphinxupquote{text}}

\end{itemize}

Remember the online resources that are available to you:
\begin{itemize}
\item {} 
\sphinxurl{http://spatialreference.org}

\item {} 
\sphinxurl{http://prj2epsg.org}

\end{itemize}

Also remember the tables we have available:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nyc\_census\_blocks}}
\begin{itemize}
\item {} 
name, popn\_total, boroname, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_streets}}
\begin{itemize}
\item {} 
name, type, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_subway\_stations}}
\begin{itemize}
\item {} 
name, geom

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nyc\_neighborhoods}}
\begin{itemize}
\item {} 
name, boroname, geom

\end{itemize}

\end{itemize}


\subsection{Exercises}
\label{\detokenize{basic:id26}}\begin{itemize}
\item {} 
\sphinxstylestrong{“What is the length of all streets in New York, as measured in UTM 18?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{10418904.7172}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What is the WKT definition of SRID 2831?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{srtext} \PYG{k}{FROM} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys}
\PYG{k}{WHERE} \PYG{n}{SRID} \PYG{o}{=} \PYG{l+m+mi}{2831}\PYG{p}{;}
\end{sphinxVerbatim}

Or, via \sphinxhref{http://prj2epsg.org/epsg/2831}{prj2epsg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PROJCS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAD83(HARN) / New York Long Island}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAD83(HARN)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAD83 (High Accuracy Regional Network)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GRS 1980}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{6378137.0}\PYG{p}{,} \PYG{l+m+mf}{298.257222101}\PYG{p}{,}
        \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{7019}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
      \PYG{n}{TOWGS84}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.991}\PYG{p}{,} \PYG{l+m+mf}{1.9072}\PYG{p}{,} \PYG{l+m+mf}{0.5129}\PYG{p}{,} \PYG{l+m+mf}{0.0257899075194932}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.009650098960270402}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.011659943232342112}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,}
      \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6152}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Greenwich}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,}
      \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{8901}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{degree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.017453292519943295}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Geodetic longitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{EAST}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Geodetic latitude}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NORTH}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4152}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PROJECTION}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lambert Conic Conformal (2SP)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{9802}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{central\PYGZus{}meridian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{74.0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latitude\PYGZus{}of\PYGZus{}origin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{40.166666666666664}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{standard\PYGZus{}parallel\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{41.03333333333333}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{false\PYGZus{}easting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{300000.0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{false\PYGZus{}northing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scale\PYGZus{}factor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{standard\PYGZus{}parallel\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{40.666666666666664}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Easting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{EAST}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AXIS}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Northing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{NORTH}\PYG{p}{]}\PYG{p}{,}
  \PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EPSG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2831}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{“What is the length of all streets in New York, as measured in SRID 2831?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Length}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{2831}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{10421993.7063767}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The difference between the UTM 18 and the State Plane Long Island measurements is (10421993 - 10418904)/10418904, or 0.02\%. Calculated on the spheroid using \DUrole{xref,std,std-ref}{geography} the total street length is 10421999, which is closer to the State Plane value. This is not surprising, since the State Plane Long Island projection is precisely calibrated for a very small area (New York City) while UTM 18 has to provide reasonable results for a large regional area.
\end{sphinxadmonition}

\item {} 
\sphinxstylestrong{“What is the KML representation of the point at ‘Broad St’ subway station?”}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsKML}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Point}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{coordinates}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{74.010671468873412}\PYG{p}{,}\PYG{l+m+mf}{40.707104815587613}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{coordinates}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Point}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Hey! The coordinates are in geographics even though we didn’t call \sphinxstyleliteralstrong{\sphinxupquote{ST\_Transform}}, why? Because the KML standard dictates that all coordinates \sphinxstyleemphasis{must} be in geographics (ESPG:4326, in fact) so the \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsKML}} function does the transformation automatically.

\end{itemize}


\section{Geography}
\label{\detokenize{basic:geography}}\label{\detokenize{basic:id27}}
It is very common to have data in which the coordinate are “geographics” or “latitude/longitude”.

Unlike coordinates in Mercator, UTM, or Stateplane, geographic coordinates are \sphinxstylestrong{not Cartesian coordinates}. Geographic coordinates do not represent a linear distance from an origin as plotted on a plane.  Rather, these \sphinxstylestrong{spherical coordinates} describe angular coordinates on a globe. In spherical coordinates a point is specified by the angle of rotation from a reference meridian (longitude), and the angle from the equator (latitude).

\noindent\sphinxincludegraphics{{cartesian_spherical}.jpg}

You can treat geographic coordinates as approximate Cartesian coordinates and continue to do spatial calculations. However, measurements of distance, length and area will be nonsensical. Since spherical coordinates measure \sphinxstylestrong{angular} distance, the units are in “degrees.” Further, the approximate results from indexes and true/false tests like intersects and contains can become terribly wrong. The distance between points get larger as problem areas like the poles or the international dateline are approached.

For example, here are the coordinates of Los Angeles and Paris.
\begin{itemize}
\item {} 
Los Angeles: \sphinxcode{\sphinxupquote{POINT(-118.4079 33.9434)}}

\item {} 
Paris: \sphinxcode{\sphinxupquote{POINT(2.3490 48.8533)}}

\end{itemize}

The following calculates the distance between Los Angeles and Paris using the standard PostGIS Cartesian \sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geometry, geometry)}}.  Note that the SRID of 4326 declares a geographic spatial reference system.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(\PYGZhy{}118.4079 33.9434)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Los Angeles (LAX)}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(2.5559 49.0083)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Paris (CDG)}
  \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{121.898285970107}
\end{sphinxVerbatim}

Aha! 121! But, what does that mean?

The units for spatial reference 4326 are degrees. So our answer is 121 degrees. But (again), what does that mean?

On a sphere, the size of one “degree square” is quite variable, becoming smaller as you move away from the equator. Think of the meridians (vertical lines) on the globe getting closer to each other as you go towards the poles. So, a distance of 121 degrees doesn’t \sphinxstyleemphasis{mean} anything. It is a nonsense number.

In order to calculate a meaningful distance, we must treat geographic coordinates not as approximate Cartesian coordinates but rather as true spherical coordinates.  We must measure the distances between points as true paths over a sphere \textendash{} a portion of a great circle.

Starting with version 1.5, PostGIS provides this functionality through the \sphinxcode{\sphinxupquote{geography}} type.

\begin{sphinxadmonition}{note}{Note:}
Different spatial databases have different approaches for “handling geographics”
\begin{itemize}
\item {} 
Oracle attempts to paper over the differences by transparently doing geographic calculations when the SRID is geographic.

\item {} 
SQL Server uses two spatial types, “STGeometry” for Cartesian data and “STGeography” for geographics.

\item {} 
Informix Spatial is a pure Cartesian extension to Informix, while Informix Geodetic is a pure geographic extension.

\item {} 
Similar to SQL Server, PostGIS uses two types, “geometry” and “geography”.

\end{itemize}
\end{sphinxadmonition}

Using the \sphinxcode{\sphinxupquote{geography}} instead of \sphinxcode{\sphinxupquote{geometry}} type, let’s try again to measure the distance between Los Angeles and Paris. Instead of \sphinxstyleliteralstrong{\sphinxupquote{ST\_GeometryFromText(text)}}, we will use \sphinxstyleliteralstrong{\sphinxupquote{ST\_GeographyFromText(text)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(\PYGZhy{}118.4079 33.9434)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Los Angeles (LAX)}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(2.5559 49.0083)\PYGZsq{}}\PYG{p}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Paris (CDG)}
  \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{9124665.27317673}
\end{sphinxVerbatim}

A big number! All return values from \sphinxcode{\sphinxupquote{geography}} calculations are in meters, so our answer is 9124km.

Older versions of PostGIS supported very basic calculations over the sphere using the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance\_Spheroid(point, point, measurement)}} function. However, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance\_Spheroid}} is substantially limited. The function only works on points and provides no support for indexing across the poles or international dateline.

The need to support non-point geometries becomes very clear when posing a question like “How close will a flight from Los Angeles to Paris come to Iceland?”

\noindent\sphinxincludegraphics{{lax_cdg}.jpg}

Working with geographic coordinates on a Cartesian plane (the purple line) yields a \sphinxstyleemphasis{very} wrong answer indeed! Using great circle routes (the red lines) gives the right answer. If we convert our LAX-CDG flight into a line string and calculate the distance to a point in Iceland using \sphinxcode{\sphinxupquote{geography}} we’ll get the right answer (recall) in meters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(\PYGZhy{}118.4079 33.9434, 2.5559 49.0083)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} LAX\PYGZhy{}CDG}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(\PYGZhy{}22.6056 63.9850)\PYGZsq{}}\PYG{p}{)}                        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Iceland (KEF)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{502454.90667289}
\end{sphinxVerbatim}

So the closest approach to Iceland (as measured from its international airport) on the LAX-CDG route is a relatively small 502km.

The Cartesian approach to handling geographic coordinates breaks down entirely for features that cross the international dateline. The shortest great-circle route from Los Angeles to Tokyo crosses the Pacific Ocean. The shortest Cartesian route crosses the Atlantic and Indian Oceans.

\noindent\sphinxincludegraphics{{lax_nrt}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Point(\PYGZhy{}118.4079 33.9434)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} LAX}
  \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Point(139.733 35.567)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} NRT (Tokyo/Narita)}
    \PYG{k}{AS} \PYG{n}{geometry\PYGZus{}distance}\PYG{p}{,}
\PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Point(\PYGZhy{}118.4079 33.9434)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} LAX}
  \PYG{n}{ST\PYGZus{}GeographyFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Point(139.733 35.567)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} NRT (Tokyo/Narita)}
    \PYG{k}{AS} \PYG{n}{geography\PYGZus{}distance}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{geometry\PYGZus{}distance} \PYG{o}{\textbar{}} \PYG{n}{geography\PYGZus{}distance}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
  \PYG{l+m+mf}{258.146005837336} \PYG{o}{\textbar{}}   \PYG{l+m+mf}{8833954.77277118}
\end{sphinxVerbatim}


\subsection{Using Geography}
\label{\detokenize{basic:using-geography}}
In order to load geometry data into a geography table, the geometry first needs to be projected into EPSG:4326 (longitude/latitude), then it needs to be changed into geography.  The \sphinxstyleliteralstrong{\sphinxupquote{ST\_Transform(geometry,srid)}} function converts coordinates to geographics and the \sphinxstyleliteralstrong{\sphinxupquote{Geography(geometry)}} function “casts” them from geometry to geography.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations\PYGZus{}geog} \PYG{k}{AS}
\PYG{k}{SELECT}
  \PYG{n}{Geography}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geog}\PYG{p}{,}
  \PYG{n}{name}\PYG{p}{,}
  \PYG{n}{routes}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}\PYG{p}{;}
\end{sphinxVerbatim}

Building a spatial index on a geography table is exactly the same as for geometry:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{sidx\PYGZus{}nyc\PYGZus{}subway\PYGZus{}stations\PYGZus{}geog}
\PYG{k}{ON} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations\PYGZus{}geog} \PYG{k}{USING} \PYG{n}{GIST} \PYG{p}{(}\PYG{n}{geog}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The difference is under the covers: the geography index type provides native support for spatial features represented on “geographic” coordinates (sometimes called “geodetic” coordinates, or “lat/lon”, or “lon/lat”). Geographic coordinates are spherical coordinates expressed in angular units (degrees) and will correctly handle queries that cover the poles or the international date-line, while the geometry one will not, since the basis for the PostGIS geometry type is a plane. The shortest path between two points on the plane is a straight line. That means calculations on geometries (areas, distances, lengths, intersections, etc) can be calculated using cartesian mathematics and straight line vectors. Not so useful for spherical (pole to pole distances).

There are only a small number of native functions for the geography type:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geography)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeographyFromText(text)}} returns \sphinxcode{\sphinxupquote{geography}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsBinary(geography)}} returns \sphinxcode{\sphinxupquote{bytea}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeogFromWKB(bytea)}} returns \sphinxcode{\sphinxupquote{geography}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsSVG(geography)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geography)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsKML(geography)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGeoJson(geography)}} returns \sphinxcode{\sphinxupquote{text}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geography, geography)}} returns \sphinxcode{\sphinxupquote{double}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin(geography, geography, float8)}} returns \sphinxcode{\sphinxupquote{boolean}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geography)}} returns \sphinxcode{\sphinxupquote{double}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(geography)}} returns \sphinxcode{\sphinxupquote{double}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Covers(geography, geography)}} returns \sphinxcode{\sphinxupquote{boolean}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_CoveredBy(geography, geography)}} returns \sphinxcode{\sphinxupquote{boolean}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geography, geography)}} returns \sphinxcode{\sphinxupquote{boolean}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Buffer(geography, float8)}} returns \sphinxcode{\sphinxupquote{geography}} %
\begin{footnote}[3]\sphinxAtStartFootnote
The buffer and intersection functions are actually wrappers on top of a cast to geometry, and are not carried out natively in spherical coordinates. As a result, they may fail to return correct results for objects with very large extents that cannot be cleanly converted to a planar representation.

For example, the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Buffer(geography,distance)}} function transforms the geography object into a “best” projection, buffers it, and then transforms it back to geographics. If there is no “best” projection (the object is too large), the operation can fail or return a malformed buffer.
%
\end{footnote}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersection(geography, geography)}} returns \sphinxcode{\sphinxupquote{geography}} \sphinxfootnotemark[3]

\end{itemize}


\subsection{Creating a Geography Table}
\label{\detokenize{basic:creating-a-geography-table}}
The SQL for creating a new table with a geography column is much like that for creating a geometry table. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{airports} \PYG{p}{(}
  \PYG{n}{code} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{geog} \PYG{n}{GEOGRAPHY}\PYG{p}{(}\PYG{n}{Point}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}

\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{airports} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LAX\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(\PYGZhy{}118.4079 33.9434)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{airports} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}CDG\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(2.5559 49.0083)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{airports} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}KEF\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(\PYGZhy{}22.6056 63.9850)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In the table definition, the \sphinxcode{\sphinxupquote{GEOGRAPHY(Point)}} specifies our airport data type as points. The new geography fields don’t get registered in the \sphinxcode{\sphinxupquote{geometry\_columns}} view. Instead, they are registered in a view called \sphinxcode{\sphinxupquote{geography\_columns}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{geography\PYGZus{}columns}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          \PYG{n}{f\PYGZus{}table\PYGZus{}name}    \PYG{o}{\textbar{}} \PYG{n}{f\PYGZus{}geography\PYGZus{}column} \PYG{o}{\textbar{}} \PYG{n}{srid} \PYG{o}{\textbar{}}   \PYG{n+nb}{type}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations\PYGZus{}geog} \PYG{o}{\textbar{}} \PYG{n}{geog}               \PYG{o}{\textbar{}}    \PYG{l+m+mi}{0} \PYG{o}{\textbar{}} \PYG{n}{Geometry}
 \PYG{n}{airports}                 \PYG{o}{\textbar{}} \PYG{n}{geog}               \PYG{o}{\textbar{}} \PYG{l+m+mi}{4326} \PYG{o}{\textbar{}} \PYG{n}{Point}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Some columns were omitted from the above output.
\end{sphinxadmonition}


\subsection{Casting to Geometry}
\label{\detokenize{basic:casting-to-geometry}}
While the basic functions for geography types can handle many use cases, there are times when you might need access to other functions only supported by the geometry type. Fortunately, you can convert objects back and forth from geography to geometry.

The PostgreSQL syntax convention for casting is to append \sphinxcode{\sphinxupquote{::typename}} to the end of the value you wish to cast. So, \sphinxcode{\sphinxupquote{2::text}} with convert a numeric two to a text string ‘2’. And \sphinxcode{\sphinxupquote{'POINT(0 0)'::geometry}} will convert the text representation of point into a geometry point.

The \sphinxstyleliteralstrong{\sphinxupquote{ST\_X(point)}} function only supports the geometry type. How can we read the X coordinate from our geographies?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{code}\PYG{p}{,} \PYG{n}{ST\PYGZus{}X}\PYG{p}{(}\PYG{n}{geog}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{longitude} \PYG{k}{FROM} \PYG{n}{airports}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{code} \PYG{o}{\textbar{}} \PYG{n}{longitude}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{LAX}  \PYG{o}{\textbar{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{118.4079}
 \PYG{n}{CDG}  \PYG{o}{\textbar{}}    \PYG{l+m+mf}{2.5559}
 \PYG{n}{KEF}  \PYG{o}{\textbar{}}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.6056}
\end{sphinxVerbatim}

By appending \sphinxcode{\sphinxupquote{::geometry}} to our geography value, we convert the object to a geometry with an SRID of 4326. From there we can use as many geometry functions as strike our fancy. But, remember \textendash{} now that our object is a geometry, the coordinates will be interpretted as Cartesian coordinates, not spherical ones.


\subsection{Why (Not) Use Geography}
\label{\detokenize{basic:why-not-use-geography}}
Geographics are universally accepted coordinates \textendash{} everyone understands what latitude/longitude mean, but very few people understand what UTM coordinates mean. Why not use geography all the time?
\begin{itemize}
\item {} 
First, as noted earlier, there are far fewer functions available (right now) that directly support the geography type. You may spend a lot of time working around geography type limitations.

\item {} 
Second, the calculations on a sphere are computationally far more expensive than Cartesian calculations. For example, the Cartesian formula for distance (Pythagoras) involves one call to sqrt(). The spherical formula for distance (Haversine) involves two sqrt() calls, an arctan() call, four sin() calls and two cos() calls. Trigonometric functions are very costly, and spherical calculations involve a lot of them.

\end{itemize}

The conclusion?

\sphinxstylestrong{If your data is geographically compact} (contained within a state, county or city), \sphinxstylestrong{use the geometry type with a Cartesian projection} that makes sense with your data. See the \sphinxurl{http://spatialreference.org} site and type in the name of your region for a selection of possible reference systems.

\sphinxstylestrong{If you need to measure distance with a dataset that is geographically dispersed} (covering much of the world), \sphinxstylestrong{use the geography type.} The application complexity you save by working in \sphinxcode{\sphinxupquote{geography}} will offset any performance issues. And casting to \sphinxcode{\sphinxupquote{geometry}} can offset most functionality limitations.


\subsection{Function List}
\label{\detokenize{basic:id30}}
\sphinxhref{http://postgis.net/docs/ST\_Distance.html}{ST\_Distance(geometry, geometry)}: For geometry type Returns the 2-dimensional Cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography type defaults to return spheroidal minimum distance between two geographies in meters.

\sphinxhref{http://postgis.net/docs/ST\_GeographyFromText.html}{ST\_GeographyFromText(text)}: Returns a specified geography value from Well-Known Text representation or extended (WKT).

\sphinxhref{http://postgis.net/docs/ST\_Transform.html}{ST\_Transform(geometry, srid)}: Returns a new geometry with its coordinates transformed to the SRID referenced by the integer parameter.

\sphinxhref{http://postgis.net/docs/ST\_X.html}{ST\_X(point)}: Returns the X coordinate of the point, or NULL if not available. Input must be a point.


\section{Geometry Constructing Functions}
\label{\detokenize{basic:geometry-constructing-functions}}\label{\detokenize{basic:geometry-returning}}
All the functions we have seen so far work with geometries “as they are” and returns
\begin{itemize}
\item {} 
analyses of the objects (\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(geometry)}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}}),

\item {} 
serializations of the objects (\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geometry)}}),

\item {} 
parts of the object (\sphinxstyleliteralstrong{\sphinxupquote{ST\_RingN(geometry,n)}}) or

\item {} 
true/false tests (\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains(geometry,geometry)}}, \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry,geometry)}}).

\end{itemize}

“Geometry constructing functions” take geometries as inputs and output new shapes.


\subsection{ST\_Centroid / ST\_PointOnSurface}
\label{\detokenize{basic:st-centroid-st-pointonsurface}}
A common need when composing a spatial query is to replace a polygon feature with a point representation of the feature. This is useful for spatial joins (as discussed in \DUrole{xref,std,std-ref}{polypolyjoins}) because using \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry,geometry)}} on two polygon layers often results in double-counting: a polygon on a boundary will intersect an object on both sides; replacing it with a point forces it to be on one side or the other, not both.
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Centroid(geometry)}} returns a point that is approximately on the center of mass of the input argument. This simple calculation is very fast, but sometimes not desirable, because the returned point is not necessarily in the feature itself. If the input feature has a convexity (imagine the letter ‘C’) the returned centroid might not be in the interior of the feature.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_PointOnSurface(geometry)}} returns a point that is guaranteed to be inside the input argument. It is substantially more computationally expensive than the centroid operation.

\end{itemize}

\noindent\sphinxincludegraphics{{centroid}.jpg}


\subsection{ST\_Buffer}
\label{\detokenize{basic:st-buffer}}
The buffering operation is common in GIS workflows, and is also available in PostGIS. \sphinxstyleliteralstrong{\sphinxupquote{ST\_Buffer(geometry,distance)}} takes in a buffer distance and geometry type and outputs a polygon with a boundary the buffer distance away from the input geometry.

\noindent\sphinxincludegraphics{{st_buffer}.png}

For example, if the US Park Service wanted to enforce a marine traffic zone around Liberty Island, they might build a 500 meter buffer polygon around the island. Liberty Island is a single census block in our \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table, so we can easily extract and buffer it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Make a new table with a Liberty Island 500m buffer zone}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{liberty\PYGZus{}island\PYGZus{}zone} \PYG{k}{AS}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{(}\PYG{n}{Polygon}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
\PYG{k}{WHERE} \PYG{n}{blkid} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}360610001001001\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{liberty_positive}.jpg}

The \sphinxstyleliteralstrong{\sphinxupquote{ST\_Buffer}} function also accepts negative distances and builds inscribed polygons within polygonal inputs. For lines and points you will just get an empty return.

\noindent\sphinxincludegraphics{{liberty_negative}.jpg}


\subsection{ST\_Intersection}
\label{\detokenize{basic:st-intersection}}
Another classic GIS operation \textendash{} the “overlay” \textendash{} creates a new coverage by calculating the intersection of two superimposed polygons. The resultant has the property that any polygon in either of the parents can be built by merging polygons in the resultant.

The \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersection(geometry A, geometry B)}} function returns the spatial area (or line, or point) that both arguments have in common. If the arguments are disjoint, the function returns an empty geometry.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} What is the area these two circles have in common?}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using ST\PYGZus{}Buffer to make the circles!}

\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Intersection}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(3 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{intersection}.jpg}


\subsection{ST\_Union}
\label{\detokenize{basic:st-union}}
In the previous example we intersected geometries, creating a new geometry that had lines from both the inputs. The \sphinxstyleliteralstrong{\sphinxupquote{ST\_Union}} does the reverse; it takes inputs and removes common lines. There are two forms of the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Union}} function:
\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Union(geometry, geometry)}}: A two-argument version that takes in two geometries and returns the merged union.  For example, our two-circle example from the previous section looks like this when you replace the intersection with a union.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} What is the total area these two circles cover?}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Using ST\PYGZus{}Buffer to make the circles!}

\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Union}\PYG{p}{(}
  \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(0 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POINT(3 0)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{union}.jpg}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ST\_Union({[}geometry{]})}}: An aggregate version that takes in a set of geometries and returns the merged geometry for the entire group. The aggregate ST\_Union can be used with the \sphinxcode{\sphinxupquote{GROUP BY}} SQL statement to create carefully merged subsets of basic geometries. It is very powerful,

\end{itemize}

As an example of \sphinxstyleliteralstrong{\sphinxupquote{ST\_Union}} aggregation, consider our \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table. Census geography is carefully constructed so that larger geographies can be built up from smaller ones. So, we can create a census tracts map by merging the blocks that form each tract (as we do later in \DUrole{xref,std,std-ref}{creatingtractstable}). Or, we can create a county map by merging blocks that fall within each county.

To carry out the merge, note that the unique key \sphinxcode{\sphinxupquote{blkid}} actually embeds information about the higher level geographies. Here are the parts of the key for Liberty Island we used earlier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{360610001001001} \PYG{o}{=} \PYG{l+m+mi}{36} \PYG{l+m+mi}{061} \PYG{l+m+mi}{000100} \PYG{l+m+mi}{1} \PYG{l+m+mi}{001}

\PYG{l+m+mi}{36}     \PYG{o}{=} \PYG{n}{State} \PYG{n}{of} \PYG{n}{New} \PYG{n}{York}
\PYG{l+m+mi}{061}    \PYG{o}{=} \PYG{n}{New} \PYG{n}{York} \PYG{n}{County} \PYG{p}{(}\PYG{n}{Manhattan}\PYG{p}{)}
\PYG{l+m+mi}{000100} \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Tract}
\PYG{l+m+mi}{1}      \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Block} \PYG{n}{Group}
\PYG{l+m+mi}{001}    \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Block}
\end{sphinxVerbatim}

So, we can create a county map by merging all geometries that share the same first 5 digits of their \sphinxcode{\sphinxupquote{blkid}}. Be patient; this is computationally expensive and can take a minute or two.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Create a nyc\PYGZus{}census\PYGZus{}counties table by merging census blocks}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}counties} \PYG{k}{AS}
\PYG{k}{SELECT}
  \PYG{n}{ST\PYGZus{}Union}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Geometry}\PYG{p}{(}\PYG{n}{MultiPolygon}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{SubStr}\PYG{p}{(}\PYG{n}{blkid}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{countyid}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{countyid}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{union_counties}.png}

An area test can confirm that our union operation did not lose any geometry. First, we calculate the area of each individual census block, and sum those areas grouping by census county id.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{SubStr}\PYG{p}{(}\PYG{n}{blkid}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{countyid}\PYG{p}{,} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{area}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{countyid}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{countyid}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{countyid} \PYG{o}{\textbar{}}       \PYG{n}{area}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{36005}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{110196022.906506}
 \PYG{l+m+mi}{36047}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{181927497.678368}
 \PYG{l+m+mi}{36061}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{59091860.6261323}
 \PYG{l+m+mi}{36081}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{283194473.613692}
 \PYG{l+m+mi}{36085}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{150758328.111199}
\end{sphinxVerbatim}

Then we calculate the area of each of our new county polygons from the county table:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{countyid}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{area}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}counties}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{countyid} \PYG{o}{\textbar{}}       \PYG{n}{area}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{36005}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{110196022.906507}
 \PYG{l+m+mi}{36047}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{181927497.678367}
 \PYG{l+m+mi}{36061}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{59091860.6261324}
 \PYG{l+m+mi}{36081}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{283194473.593646}
 \PYG{l+m+mi}{36085}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{150758328.111199}
\end{sphinxVerbatim}

The same answer! We have successfully built an NYC county table from our census blocks data.


\subsection{Function List}
\label{\detokenize{basic:id32}}
\sphinxhref{http://postgis.net/docs/ST\_AsText.html}{ST\_AsText(text)}: Returns the Well-Known Text (WKT) representation of the geometry/geography without SRID metadata.

\sphinxhref{http://postgis.net/docs/ST\_Buffer.html}{ST\_Buffer(geometry, distance)}: For geometry: Returns a geometry that represents all points whose distance from this Geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry. For geography: Uses a planar transform wrapper.

\sphinxhref{http://postgis.net/docs/ST\_Intersection.html}{ST\_Intersection(geometry A, geometry B)}: Returns a geometry that represents the shared portion of geomA and geomB. The geography implementation does a transform to geometry to do the intersection and then transform back to WGS84.

\sphinxhref{http://postgis.net/docs/ST\_Union.html}{ST\_Union()}: Returns a geometry that represents the point set union of the Geometries.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-string.html}{substring(string {[}from int{]} {[}for int{]})}: PostgreSQL string function to extract substring matching SQL regular expression.

\sphinxhref{http://www.postgresql.org/docs/current/static/functions-aggregate.html\#FUNCTIONS-AGGREGATE-TABLE}{sum(expression)}: PostgreSQL aggregate function that returns the sum of records in a set of records.


\chapter{Advanced PostGIS}
\label{\detokenize{advanced:advanced-postgis}}\label{\detokenize{advanced::doc}}

\section{More Spatial Joins}
\label{\detokenize{advanced:more-spatial-joins}}\label{\detokenize{advanced:joins-advanced}}
In the last section we saw the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Centroid(geometry)}} and \sphinxstyleliteralstrong{\sphinxupquote{ST\_Union({[}geometry{]})}} functions, and some simple examples. In this section we will do some more elaborate things with them.


\subsection{Creating a Census Tracts Table}
\label{\detokenize{advanced:creating-a-census-tracts-table}}\label{\detokenize{advanced:creatingtractstable}}
In the course \sphinxcode{\sphinxupquote{\textbackslash{}data\textbackslash{}}} directory, is a file that includes attribute data, but no geometry, \sphinxcode{\sphinxupquote{nyc\_census\_sociodata.sql}}. The table includes interesting socioeconomic data about New York: commute times, incomes, and education attainment. There is just one problem. The data are summarized by “census tract” and we have no census tract spatial data!

In this section we will
\begin{itemize}
\item {} 
Load the \sphinxcode{\sphinxupquote{nyc\_census\_sociodata.sql}} table

\item {} 
Create a spatial table for census tracts

\item {} 
Join the attribute data to the spatial data

\item {} 
Carry out some analysis using our new data

\end{itemize}


\subsubsection{Loading nyc\_census\_sociodata.sql}
\label{\detokenize{advanced:loading-nyc-census-sociodata-sql}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Open the SQL query window in PgAdmin

\item {} 
Select \sphinxstylestrong{File-\textgreater{}Open} from the menu and browse to the \sphinxcode{\sphinxupquote{nyc\_census\_sociodata.sql}} file

\item {} 
(\sphinxstyleemphasis{Alternative}) In case your postgres user does not have access to access the files in the directory you can use a text editor to open the \sphinxcode{\sphinxupquote{nyc\_census\_sociodata.sql}} file and copy its content into the pgAdmin query window

\item {} 
Press the “Run Query” button

\item {} 
If you press the “Refresh” button in pgAdmin, the list of tables should now include at \sphinxcode{\sphinxupquote{nyc\_census\_sociodata}} table

\end{enumerate}


\subsubsection{Creating a Census Tracts Table}
\label{\detokenize{advanced:id1}}
As we saw in the previous section, we can build up higher level geometries from the census block by summarizing on substrings of the \sphinxcode{\sphinxupquote{blkid}} key. In order to get census tracts, we need to summarize grouping on the first 11 characters of the \sphinxcode{\sphinxupquote{blkid}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{360610001001001} \PYG{o}{=} \PYG{l+m+mi}{36} \PYG{l+m+mi}{061} \PYG{l+m+mi}{000100} \PYG{l+m+mi}{1} \PYG{l+m+mi}{001}

\PYG{l+m+mi}{36}     \PYG{o}{=} \PYG{n}{State} \PYG{n}{of} \PYG{n}{New} \PYG{n}{York}
\PYG{l+m+mi}{061}    \PYG{o}{=} \PYG{n}{New} \PYG{n}{York} \PYG{n}{County} \PYG{p}{(}\PYG{n}{Manhattan}\PYG{p}{)}
\PYG{l+m+mi}{000100} \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Tract}
\PYG{l+m+mi}{1}      \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Block} \PYG{n}{Group}
\PYG{l+m+mi}{001}    \PYG{o}{=} \PYG{n}{Census} \PYG{n}{Block}
\end{sphinxVerbatim}

Create the new table using the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Union}} aggregate:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Make the tracts table}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tract\PYGZus{}geoms} \PYG{k}{AS}
\PYG{k}{SELECT}
  \PYG{n}{ST\PYGZus{}Union}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{SubStr}\PYG{p}{(}\PYG{n}{blkid}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{tractid}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{tractid}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Index the tractid}
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{idx\PYGZus{}nyc\PYGZus{}census\PYGZus{}tract\PYGZus{}geoms\PYGZus{}tractid}
  \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tract\PYGZus{}geoms} \PYG{p}{(}\PYG{n}{tractid}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Join the Attributes to the Spatial Data}
\label{\detokenize{advanced:join-the-attributes-to-the-spatial-data}}
Join the table of tract geometries to the table of tract attributes with a standard attribute join

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Make the tracts table}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tracts} \PYG{k}{AS}
\PYG{k}{SELECT}
  \PYG{k}{g}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{a}\PYG{p}{.}\PYG{o}{*}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tract\PYGZus{}geoms} \PYG{k}{g}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}sociodata} \PYG{n}{a}
\PYG{k}{ON} \PYG{k}{g}\PYG{p}{.}\PYG{n}{tractid} \PYG{o}{=} \PYG{n}{a}\PYG{p}{.}\PYG{n}{tractid}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Index the geometries}
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{sidx\PYGZus{}nyc\PYGZus{}census\PYGZus{}tract}
  \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tracts} \PYG{k}{USING} \PYG{n}{GIST} \PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Answer an Interesting Question}
\label{\detokenize{advanced:answer-an-interesting-question}}\label{\detokenize{advanced:interestingquestion}}
Answer an interesting question! “List top 10 New York neighborhoods ordered by the proportion of people who have graduate degrees.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}graduate\PYGZus{}dipl}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{graduate\PYGZus{}pct}\PYG{p}{,}
  \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{n}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tracts} \PYG{n}{t}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{t}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}total} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{graduate\PYGZus{}pct} \PYG{k}{DESC}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}

We sum up the statistics we are interested, then divide them together at the end. In order to avoid divide-by-zero errors, we don’t bother bringing in tracts that have a population count of zero.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{graduate\PYGZus{}pct} \PYG{o}{\textbar{}}       \PYG{n}{name}        \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
         \PYG{l+m+mf}{47.6} \PYG{o}{\textbar{}} \PYG{n}{Carnegie} \PYG{n}{Hill}     \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{42.2} \PYG{o}{\textbar{}} \PYG{n}{Upper} \PYG{n}{West} \PYG{n}{Side}   \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{41.1} \PYG{o}{\textbar{}} \PYG{n}{Battery} \PYG{n}{Park}      \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{39.6} \PYG{o}{\textbar{}} \PYG{n}{Flatbush}          \PYG{o}{\textbar{}} \PYG{n}{Brooklyn}
         \PYG{l+m+mf}{39.3} \PYG{o}{\textbar{}} \PYG{n}{Tribeca}           \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{39.2} \PYG{o}{\textbar{}} \PYG{n}{North} \PYG{n}{Sutton} \PYG{n}{Area} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{38.7} \PYG{o}{\textbar{}} \PYG{n}{Greenwich} \PYG{n}{Village} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{38.6} \PYG{o}{\textbar{}} \PYG{n}{Upper} \PYG{n}{East} \PYG{n}{Side}   \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{37.9} \PYG{o}{\textbar{}} \PYG{n}{Murray} \PYG{n}{Hill}       \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{37.4} \PYG{o}{\textbar{}} \PYG{n}{Central} \PYG{n}{Park}      \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
New York geographers will be wondering at the presence of “Flatbush” in this list of over-educated neighborhoods. The answer is discussed in the next section.
\end{sphinxadmonition}


\subsection{Polygon/Polygon Joins}
\label{\detokenize{advanced:polygon-polygon-joins}}\label{\detokenize{advanced:polypolyjoins}}
In our interesting query (in \DUrole{xref,std,std-ref}{interestingquestion}) we used the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry\_a, geometry\_b)}} function to determine which census tract polygons to include in each neighborhood summary. Which leads to the question: what if a tract falls on the border between two neighborhoods? It will intersect both, and so will be included in the summary statistics for \sphinxstylestrong{both}.

\noindent\sphinxincludegraphics{{centroid_neighborhood}.png}

To avoid this kind of double counting there are two methods:
\begin{itemize}
\item {} 
The simple method is to ensure that each tract only falls in \sphinxstylestrong{one} summary area (using \sphinxstyleliteralstrong{\sphinxupquote{ST\_Centroid(geometry)}})

\item {} 
The complex method is to divide crossing tracts at the borders (using \sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersection(geometry,geometry)}})

\end{itemize}

Here is an example of using the simple method to avoid double counting in our graduate education query:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
  \PYG{l+m+mi}{100}\PYG{p}{.}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}graduate\PYGZus{}dipl}\PYG{p}{)} \PYG{o}{/} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}total}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{graduate\PYGZus{}pct}\PYG{p}{,}
  \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods} \PYG{n}{n}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}census\PYGZus{}tracts} \PYG{n}{t}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}Contains}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Centroid}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{t}\PYG{p}{.}\PYG{n}{edu\PYGZus{}total} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}
\PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{n}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{n}\PYG{p}{.}\PYG{n}{boroname}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{graduate\PYGZus{}pct} \PYG{k}{DESC}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the query takes longer to run now, because the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Centroid}} function  has to be run on every census tract.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{graduate\PYGZus{}pct} \PYG{o}{\textbar{}}        \PYG{n}{name}         \PYG{o}{\textbar{}} \PYG{n}{boroname}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
         \PYG{l+m+mf}{48.0} \PYG{o}{\textbar{}} \PYG{n}{Carnegie} \PYG{n}{Hill}       \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{44.2} \PYG{o}{\textbar{}} \PYG{n}{Morningside} \PYG{n}{Heights} \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{42.1} \PYG{o}{\textbar{}} \PYG{n}{Greenwich} \PYG{n}{Village}   \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{42.0} \PYG{o}{\textbar{}} \PYG{n}{Upper} \PYG{n}{West} \PYG{n}{Side}     \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{41.4} \PYG{o}{\textbar{}} \PYG{n}{Tribeca}             \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{40.7} \PYG{o}{\textbar{}} \PYG{n}{Battery} \PYG{n}{Park}        \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{39.5} \PYG{o}{\textbar{}} \PYG{n}{Upper} \PYG{n}{East} \PYG{n}{Side}     \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{39.3} \PYG{o}{\textbar{}} \PYG{n}{North} \PYG{n}{Sutton} \PYG{n}{Area}   \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
         \PYG{l+m+mf}{37.4} \PYG{o}{\textbar{}} \PYG{n}{Cobble} \PYG{n}{Hill}         \PYG{o}{\textbar{}} \PYG{n}{Brooklyn}
         \PYG{l+m+mf}{37.4} \PYG{o}{\textbar{}} \PYG{n}{Murray} \PYG{n}{Hill}         \PYG{o}{\textbar{}} \PYG{n}{Manhattan}
\end{sphinxVerbatim}

Avoiding double counting changes the results!


\subsubsection{What about Flatbush?}
\label{\detokenize{advanced:what-about-flatbush}}
In particular, the Flatbush neighborhood has dropped off the list. The reason why can be seen by looking more closely at the map of the Flatbush neighborhood in our table.

\noindent\sphinxincludegraphics{{nyc_tracts_flatbush}.jpg}

As defined by our data source, Flatbush is not really a neighborhood in the conventional sense, since it just covers the area of Prospect Park. The census tract for that area records, naturally, zero residents. However, the neighborhood boundary does scrape one of the expensive census tracts bordering the north side of the park (in the gentrified Park Slope neighborhood). When using polygon/polygon tests, this single tract was added to the otherwise empty Flatbush, resulting in the very high score for that query.


\subsection{Large Radius Distance Joins}
\label{\detokenize{advanced:large-radius-distance-joins}}\label{\detokenize{advanced:largeradiusjoins}}
A query that is fun to ask is “How do the commute times of people near (within 500 meters) subway stations differ from those of people far away from subway stations?”

However, the question runs into some problems of double counting: many people will be within 500 meters of multiple subway stations. Compare the population of New York:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8175032}
\end{sphinxVerbatim}

With the population of the people in New York within 500 meters of a subway station:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{census}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subway}
\PYG{k}{ON} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subway}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{10855873}
\end{sphinxVerbatim}

There’s more people close to the subway than there are people! Clearly, our simple SQL is making a big double-counting error. You can see the problem looking at the picture of the buffered subways.

\noindent\sphinxincludegraphics{{subways_buffered}.png}

The solution is to ensure that we have only distinct census blocks before passing them into the summarization portion of the query. We can do that by breaking our query up into a subquery that finds the distinct blocks, wrapped in a summarization query that returns our answer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{n}{distinct\PYGZus{}blocks} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{ON} \PYG{p}{(}\PYG{n}{blkid}\PYG{p}{)} \PYG{n}{popn\PYGZus{}total}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{census}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subway}
  \PYG{k}{ON} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{census}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subway}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{k}{Sum}\PYG{p}{(}\PYG{n}{popn\PYGZus{}total}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{distinct\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5005743}
\end{sphinxVerbatim}

That’s better! So a bit over half the population of New York is within 500m (about a 5-7 minute walk) of the subway.


\section{Validity}
\label{\detokenize{advanced:validity}}\label{\detokenize{advanced:id2}}
In 90\% of the cases the answer to the question, “why is my query giving me a ‘TopologyException’ error” is “one or more of the inputs are invalid”.  Which begs the question: what does it mean to be invalid, and why should we care?


\subsection{What is Validity}
\label{\detokenize{advanced:what-is-validity}}
Validity is most important for polygons, which define bounded areas and require a good deal of structure. Lines are very simple and cannot be invalid, nor can points.

Some of the rules of polygon validity feel obvious, and others feel arbitrary (and in fact, are arbitrary).
\begin{itemize}
\item {} 
Polygon rings must close.

\item {} 
Rings that define holes should be inside rings that define exterior boundaries.

\item {} 
Rings may not self-intersect (they may neither touch nor cross one another).

\item {} 
Rings may not touch other rings, except at a point.

\end{itemize}

The last two rules are in the arbitrary category. There are other ways to define polygons that are equally self-consistent but the rules above are the ones used by the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} standard that PostGIS conforms to.

The reason the rules are important is because algorithms for geometry calculations depend on consistent structure in the inputs. It is possible to build algorithms that have no structural assumptions, but those routines tend to be very slow, because the first step in any structure-free routine is to \sphinxstyleemphasis{analyze the inputs and build structure into them}.

Here’s an example of why structure matters. This polygon is invalid:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can see the invalidity a little more clearly in this diagram:

\noindent\sphinxincludegraphics{{figure_eight}.png}

The outer ring is actually a figure-eight, with a self-intersection in the middle. Note that the graphic routines successfully render the polygon fill, so that visually it is appears to be an “area”: two one-unit squares, so a total area of two units of area.

Let’s see what the database thinks the area of our polygon is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Area}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))\PYGZsq{}}
       \PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{st\PYGZus{}area}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
       \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

What’s going on here? The algorithm that calculates area assumes that rings to not self-intersect. A well-behaved ring will always have the area that is bounded (the interior) on one side of the bounding line (it doesn’t matter which side, just that it is on \sphinxstyleemphasis{one} side). However, in our (poorly behaved) figure-eight, the bounded area is to the right of the line for one lobe and to the left for the other. This causes the areas calculated for each lobe to cancel out (one comes out as 1, the other as -1) hence the “zero area” result.


\subsection{Detecting Validity}
\label{\detokenize{advanced:detecting-validity}}
In the previous example we had one polygon that we \sphinxstylestrong{knew} was invalid. How do we detect invalidity in a table with millions of geometries? With the \sphinxstyleliteralstrong{\sphinxupquote{ST\_IsValid(geometry)}} function. Used against our figure-eight, we get a quick answer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}IsValid}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))\PYGZsq{}}
       \PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}
\end{sphinxVerbatim}

Now we know that the feature is invalid, but we don’t know why. We can use the \sphinxstyleliteralstrong{\sphinxupquote{ST\_IsValidReason(geometry)}} function to find out the source of the invalidity:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}IsValidReason}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))\PYGZsq{}}
       \PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Self}\PYG{o}{\PYGZhy{}}\PYG{n}{intersection}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

Note that in addition to the reason (self-intersection) the location of the invalidity (coordinate (1 1)) is also returned.

We can use the \sphinxstyleliteralstrong{\sphinxupquote{ST\_IsValid(geometry)}} function to test our tables too:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Find all the invalid polygons and what their problem is}
\PYG{k}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{boroname}\PYG{p}{,} \PYG{n}{ST\PYGZus{}IsValidReason}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{k}{NOT} \PYG{n}{ST\PYGZus{}IsValid}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          \PYG{n}{name}           \PYG{o}{\textbar{}}   \PYG{n}{boroname}    \PYG{o}{\textbar{}}                     \PYG{n}{st\PYGZus{}isvalidreason}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Howard} \PYG{n}{Beach}            \PYG{o}{\textbar{}} \PYG{n}{Queens}        \PYG{o}{\textbar{}} \PYG{n}{Self}\PYG{o}{\PYGZhy{}}\PYG{n}{intersection}\PYG{p}{[}\PYG{l+m+mf}{597264.083368305} \PYG{l+m+mf}{4499924.54228856}\PYG{p}{]}
 \PYG{n}{Corona}                  \PYG{o}{\textbar{}} \PYG{n}{Queens}        \PYG{o}{\textbar{}} \PYG{n}{Self}\PYG{o}{\PYGZhy{}}\PYG{n}{intersection}\PYG{p}{[}\PYG{l+m+mf}{595483.058764138} \PYG{l+m+mf}{4513817.95350787}\PYG{p}{]}
 \PYG{n}{Red} \PYG{n}{Hook}                \PYG{o}{\textbar{}} \PYG{n}{Brooklyn}      \PYG{o}{\textbar{}} \PYG{n}{Self}\PYG{o}{\PYGZhy{}}\PYG{n}{intersection}\PYG{p}{[}\PYG{l+m+mf}{584306.820375986} \PYG{l+m+mf}{4502360.51774956}\PYG{p}{]}
 \PYG{n}{Steinway}                \PYG{o}{\textbar{}} \PYG{n}{Queens}        \PYG{o}{\textbar{}} \PYG{n}{Self}\PYG{o}{\PYGZhy{}}\PYG{n}{intersection}\PYG{p}{[}\PYG{l+m+mf}{593545.572199759} \PYG{l+m+mf}{4514735.20870587}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Repairing Invalidity}
\label{\detokenize{advanced:repairing-invalidity}}
First the bad news: there is no 100\% guaranteed way to fix invalid geometries. The worst case scenario is identifying them with the \sphinxstyleliteralstrong{\sphinxupquote{ST\_IsValid(geometry)}} function, moving them to a side table, exporting that table, and repairing them externally.

Here’s an example of SQL to move invalid geometries out of the main table into a side table suitable for dumping to an external cleaning process.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Side table of invalids}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}neighborhoods\PYGZus{}invalid} \PYG{k}{AS}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{k}{NOT} \PYG{n}{ST\PYGZus{}IsValid}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Remove them from the main table}
\PYG{k}{DELETE} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}neighborhoods}
\PYG{k}{WHERE} \PYG{k}{NOT} \PYG{n}{ST\PYGZus{}IsValid}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A good tool for visually repairing invalid geometry is QGIS (\sphinxurl{https://qgis.org/en/site/}) which includes a validation tool under \sphinxstylestrong{Vector-\textgreater{}Geometry Tools-\textgreater{}Check Validity…}.

Now the good news: a large proportion of invalidities \sphinxstylestrong{can be fixed inside the database} using either:
\begin{itemize}
\item {} 
the \sphinxstyleliteralstrong{\sphinxupquote{ST\_MakeValid}} function or,

\item {} 
the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Buffer}} function.

\end{itemize}


\subsubsection{ST\_MakeValid}
\label{\detokenize{advanced:st-makevalid}}
\sphinxstyleliteralstrong{\sphinxupquote{ST\_MakeValid}} attempts to repair invalidities without only minimal alterations to the input geometries. No vertices are dropped or moved, the structure of the object is simply re-arranged. This is a good thing for clean, but invalid data, and a bad thing for messy and invalid data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Fix the invalid figure\PYGZhy{}8 polygon}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}MakeValid}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))\PYGZsq{}}
       \PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MULTIPOLYGON}\PYG{p}{(}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleliteralstrong{\sphinxupquote{ST\_MakeValid}} successfully converts the figure-8 into a multi-polygon that represents the same area.


\subsubsection{ST\_Buffer}
\label{\detokenize{advanced:st-buffer}}
Cleaning using the buffer trick takes advantage of the way buffers are built: a buffered geometry is a brand new geometry, constructed by offsetting lines from the original geometry. If you offset the original lines by \sphinxstylestrong{nothing} (zero) then the new geometry will be structurally identical to the original one, but because it is built using the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} topology rules, it will be valid.

For example, here’s a classic invalidity \textendash{} the “banana polygon” \textendash{} a single ring that encloses an area but bends around to touch itself, leaving a “hole” which is not actually a hole.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{banana}.png}

Running the zero-offset buffer on the polygon returns a valid {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} polygon, consisting of an outer and inner ring that touch at one point.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}
         \PYG{n}{ST\PYGZus{}Buffer}\PYG{p}{(}
           \PYG{n}{ST\PYGZus{}GeometryFromText}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}POLYGON((0 0, 2 0, 1 1, 2 2, 3 1, 2 0, 4 0, 4 4, 0 4, 0 0))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
           \PYG{l+m+mi}{0}\PYG{p}{.}\PYG{l+m+mi}{0}
         \PYG{p}{)}
       \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POLYGON}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The “banana polygon” (or “inverted shell”) is a case where the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} topology model for valid geometry and the model used internally by ESRI differ. The ESRI model considers rings that touch to be invalid, and prefers the banana form for this kind of shape. The OGC model is the reverse. Neither is “correct”, they are just different ways to model the same situation.
\end{sphinxadmonition}


\section{Equality}
\label{\detokenize{advanced:equality}}\label{\detokenize{advanced:id3}}

\subsection{Equality}
\label{\detokenize{advanced:id4}}
Determining equality when dealing with geometries can be tricky.  PostGIS supports three different functions that can be used to determine different levels of equality, though for clarity we will use the definitions below.  To illustrate these functions, we will use the following polygons.

\noindent\sphinxincludegraphics{{polygon-table}.png}

These polygons are loaded using the following commands.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{polygons} \PYG{p}{(}\PYG{n}{id} \PYG{n+nb}{integer}\PYG{p}{,} \PYG{n}{name} \PYG{n+nb}{varchar}\PYG{p}{,} \PYG{n}{poly} \PYG{n}{geometry}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{polygons} \PYG{k}{VALUES}
  \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Polygon 1\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((\PYGZhy{}1 1.732,1 1.732,2 0,1 \PYGZhy{}1.732,}
\PYG{l+s+s1}{      \PYGZhy{}1 \PYGZhy{}1.732,\PYGZhy{}2 0,\PYGZhy{}1 1.732))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Polygon 2\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((\PYGZhy{}1 1.732,\PYGZhy{}2 0,\PYGZhy{}1 \PYGZhy{}1.732,1 \PYGZhy{}1.732,}
\PYG{l+s+s1}{      2 0,1 1.732,\PYGZhy{}1 1.732))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Polygon 3\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((1 \PYGZhy{}1.732,2 0,1 1.732,\PYGZhy{}1 1.732,}
\PYG{l+s+s1}{      \PYGZhy{}2 0,\PYGZhy{}1 \PYGZhy{}1.732,1 \PYGZhy{}1.732))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Polygon 4\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((\PYGZhy{}1 1.732,0 1.732, 1 1.732,1.5 0.866,}
\PYG{l+s+s1}{      2 0,1.5 \PYGZhy{}0.866,1 \PYGZhy{}1.732,0 \PYGZhy{}1.732,\PYGZhy{}1 \PYGZhy{}1.732,\PYGZhy{}1.5 \PYGZhy{}0.866,}
\PYG{l+s+s1}{      \PYGZhy{}2 0,\PYGZhy{}1.5 0.866,\PYGZhy{}1 1.732))\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Polygon 5\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POLYGON((\PYGZhy{}2 \PYGZhy{}1.732,2 \PYGZhy{}1.732,2 1.732,}
\PYG{l+s+s1}{      \PYGZhy{}2 1.732,\PYGZhy{}2 \PYGZhy{}1.732))\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{start13}.png}

Exact equality is determined by comparing two geometries, vertex by vertex, in order, to ensure they are identical in position.  The following examples show how this method can be limited in its effectiveness.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{a}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{k}{CASE} \PYG{k}{WHEN} \PYG{n}{ST\PYGZus{}OrderingEquals}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{poly}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{poly}\PYG{p}{)}
    \PYG{k}{THEN} \PYG{l+s+s1}{\PYGZsq{}Exactly Equal\PYGZsq{}} \PYG{k}{ELSE} \PYG{l+s+s1}{\PYGZsq{}Not Exactly Equal\PYGZsq{}} \PYG{k}{end}
  \PYG{k}{FROM} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{a}\PYG{p}{,} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{name}    \PYG{o}{\textbar{}}   \PYG{n}{name}    \PYG{o}{\textbar{}}       \PYG{n}{case}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Exactly} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Exactly} \PYG{n}{Equal}
\end{sphinxVerbatim}

In this example, the polygons are only equal to themselves, not to other seemingly equivalent polygons (as in the case of Polygons 1 through 3).  In the case of Polygons 1, 2, and 3, the vertices are in identical positions but are defined in differing orders.  Polygon 4 has colinear (and thus redundant) vertices on the hexagon edges causing inequality with Polygon 1.

As we saw above, exact equality does not take into account the spatial nature of the geometries.  There is an function, aptly named \sphinxstyleliteralstrong{\sphinxupquote{ST\_Equals}}, available to test the spatial equality or equivalence of geometries.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{a}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{k}{CASE} \PYG{k}{WHEN} \PYG{n}{ST\PYGZus{}Equals}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{poly}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{poly}\PYG{p}{)}
    \PYG{k}{THEN} \PYG{l+s+s1}{\PYGZsq{}Spatially Equal\PYGZsq{}} \PYG{k}{ELSE} \PYG{l+s+s1}{\PYGZsq{}Not Equal\PYGZsq{}} \PYG{k}{end}
  \PYG{k}{FROM} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{a}\PYG{p}{,} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{name}    \PYG{o}{\textbar{}}   \PYG{n}{name}    \PYG{o}{\textbar{}}      \PYG{n}{case}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Not} \PYG{n}{Equal}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Spatially} \PYG{n}{Equal}
\end{sphinxVerbatim}

These results are more in line with our intuitive understanding of equality.  Polygons 1 through 4 are considered equal, since they enclose the same area.  Note that neither the direction of the polygon is drawn, the starting point for defining the polygon, nor the number of points used are important here.  What is important is that the polygons contain the same space.

Exact equality requires, in the worst case, comparison of each and every vertex in the geometry to determine equality.  This can be slow, and may not be appropriate for comparing huge numbers of geometries.  To allow for speedier comparison, the equal bounds operator, \sphinxstyleliteralstrong{\sphinxupquote{=}}, is provided.  This operates only on the bounding box (rectangle), ensuring that the geometries occupy the same two dimensional extent, but not necessarily the same space.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{a}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{k}{CASE} \PYG{k}{WHEN} \PYG{n}{a}\PYG{p}{.}\PYG{n}{poly} \PYG{o}{=} \PYG{n}{b}\PYG{p}{.}\PYG{n}{poly}
    \PYG{k}{THEN} \PYG{l+s+s1}{\PYGZsq{}Equal Bounds\PYGZsq{}} \PYG{k}{ELSE} \PYG{l+s+s1}{\PYGZsq{}Non\PYGZhy{}equal Bounds\PYGZsq{}} \PYG{k}{end}
  \PYG{k}{FROM} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{a}\PYG{p}{,} \PYG{n}{polygons} \PYG{k}{as} \PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{name}    \PYG{o}{\textbar{}}   \PYG{n}{name}    \PYG{o}{\textbar{}}       \PYG{n}{case}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}} \PYG{n}{Non}\PYG{o}{\PYGZhy{}}\PYG{n}{equal} \PYG{n}{Bounds}
 \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Polygon} \PYG{l+m+mi}{5} \PYG{o}{\textbar{}} \PYG{n}{Equal} \PYG{n}{Bounds}
\end{sphinxVerbatim}

As you can see, all of our spatially equal geometries also have equal bounds.  Unfortunately, Polygon 5 is also returned as equal under this test, because it shares the same bounding box as the other geometries.  Why is this useful, then?  Although this will be covered in detail later, the shot answer is that this enables the use of spatial indexing that can quickly reduce huge comparison sets into more manageable blocks when joining or filtering data.


\section{Linear Referencing}
\label{\detokenize{advanced:linear-referencing}}\label{\detokenize{advanced:id5}}
Linear referencing is a means of representing features that are can be described by referencing a base set of linear features. Common examples of features that are modelled using linear referencing are:
\begin{itemize}
\item {} 
Highway assets, which are referenced using miles along a highway network

\item {} 
Road maintenance operations, which are referenced as occurring along a road network between a pair of mile measurements.

\item {} 
Aquatic inventories, where fish presence is recorded as existing between a pair of mileage-upstream measurements.

\item {} 
Hydrologic characterizations (“reaches”) of streams, recorded with a from- and to- mileage.

\end{itemize}

The benefit of linear referencing models is that the dependent spatial observations do not need to be separately recorded from the base observations, and updates to the base observation layer can be carried out knowing that the dependent observations will automatically track the new geometry.

\begin{sphinxadmonition}{note}{Note:}
The ESRI convention for linear referencing is to have a base table of linear spatial features, and a non-spatial table of “events” which includes a foreign key reference to the spatial feature and a measure along the referenced feature. We will use the term “event table” to refer to the non-spatial tables we build.
\end{sphinxadmonition}


\subsection{Creating Linear References}
\label{\detokenize{advanced:creating-linear-references}}
If you have an existing point table that you want to reference to a linear network, use the \sphinxstyleliteralstrong{\sphinxupquote{ST\_LineLocatePoint}} function, which takes a line and point, and returns the proportion along the line that the point can be found.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Simple example of locating a point half\PYGZhy{}way along a line}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}LineLocatePoint}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0, 2 2)\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(1 1)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer 0.5}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} What if the point is not on the line? It projects to closest point}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}LineLocatePoint}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0, 2 2)\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}POINT(0 2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer 0.5}
\end{sphinxVerbatim}

We can convert the \sphinxstylestrong{nyc\_subway\_stations} into an “event table” relative to the streets by using \sphinxstyleliteralstrong{\sphinxupquote{ST\_LineLocatePoint}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} All the SQL below is in aid of creating the new event table}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}station\PYGZus{}events} \PYG{k}{AS}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} We first need to get a candidate set of maybe\PYGZhy{}closest}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} streets, ordered by id and distance...}
\PYG{k}{WITH} \PYG{n}{ordered\PYGZus{}nearest} \PYG{k}{AS} \PYG{p}{(}
\PYG{k}{SELECT}
  \PYG{n}{ST\PYGZus{}GeometryN}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{streets\PYGZus{}geom}\PYG{p}{,}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id} \PYG{k}{AS} \PYG{n}{streets\PYGZus{}id}\PYG{p}{,}
  \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom} \PYG{k}{AS} \PYG{n}{subways\PYGZus{}geom}\PYG{p}{,}
  \PYG{n}{subways}\PYG{p}{.}\PYG{n}{id} \PYG{k}{AS} \PYG{n}{subways\PYGZus{}id}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{distance}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subways}
  \PYG{k}{ON} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{subways\PYGZus{}id}\PYG{p}{,} \PYG{n}{distance} \PYG{k}{ASC}
\PYG{p}{)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} We use the \PYGZsq{}distinct on\PYGZsq{} PostgreSQL feature to get the first}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} street (the nearest) for each unique street gid. We can then}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} pass that one street into ST\PYGZus{}LineLocatePoint along with}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} its candidate subway station to calculate the measure.}
\PYG{k}{SELECT}
  \PYG{k}{DISTINCT} \PYG{k}{ON} \PYG{p}{(}\PYG{n}{subways\PYGZus{}id}\PYG{p}{)}
  \PYG{n}{subways\PYGZus{}id}\PYG{p}{,}
  \PYG{n}{streets\PYGZus{}id}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}LineLocatePoint}\PYG{p}{(}\PYG{n}{streets\PYGZus{}geom}\PYG{p}{,} \PYG{n}{subways\PYGZus{}geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{measure}\PYG{p}{,}
  \PYG{n}{distance}
\PYG{k}{FROM} \PYG{n}{ordered\PYGZus{}nearest}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Primary keys are useful for visualization softwares}
\PYG{k}{ALTER} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}station\PYGZus{}events} \PYG{k}{ADD} \PYG{k}{PRIMARY} \PYG{k}{KEY} \PYG{p}{(}\PYG{n}{subways\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Once we have an event table, it’s fun to turn it back into a spatial view, so we can visualize the events relative to the original points they were derived from.

To go from a measure to a point, we use the \sphinxstyleliteralstrong{\sphinxupquote{ST\_LineInterpolatePoint}} function. Here’s our previous simple examples reversed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Simple example of locating a point half\PYGZhy{}way along a line}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}LineInterpolatePoint}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0, 2 2)\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{.}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer POINT(1 1)}
\end{sphinxVerbatim}

And we can join the \sphinxstylestrong{nyc\_subway\_station\_events} tables back to the \sphinxstylestrong{nyc\_streets} table and use the \sphinxstylestrong{measure} attribute to generate the spatial event points, without referencing the original \sphinxstylestrong{nyc\_subway\_stations} table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} New view that turns events back into spatial objects}
\PYG{k}{CREATE} \PYG{k}{OR} \PYG{k}{REPLACE} \PYG{k}{VIEW} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations\PYGZus{}lrs} \PYG{k}{AS}
\PYG{k}{SELECT}
  \PYG{n}{events}\PYG{p}{.}\PYG{n}{subways\PYGZus{}id}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}LineInterpolatePoint}\PYG{p}{(}\PYG{n}{ST\PYGZus{}GeometryN}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{events}\PYG{p}{.}\PYG{n}{measure}\PYG{p}{)}\PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,}
  \PYG{n}{events}\PYG{p}{.}\PYG{n}{streets\PYGZus{}id}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}station\PYGZus{}events} \PYG{n}{events}
\PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
\PYG{k}{ON} \PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{id} \PYG{o}{=} \PYG{n}{events}\PYG{p}{.}\PYG{n}{streets\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Viewing the original (red star) and event (blue circle) points with the streets, you can see how the events are snapped directly to the closest street lines.

\noindent\sphinxincludegraphics{{lrs1}.jpg}

\begin{sphinxadmonition}{note}{Note:}
One surprising use of the linear referencing functions has nothing to do with linear referencing models. As shown above, it’s possible to use the functions to snap points to linear features. For use cases like GPS tracks or other inputs that are expected to reference a linear network, snapping is a handy feature to have available.
\end{sphinxadmonition}


\subsection{Function List}
\label{\detokenize{advanced:function-list}}\begin{itemize}
\item {} 
\sphinxhref{http://postgis.net/docs/ST\_LineInterpolatePoint.html}{ST\_LineInterpolatePoint(geometry A, double measure)}: Returns a point interpolated along a line.

\item {} 
\sphinxhref{http://postgis.net/docs/ST\_LineLocatePoint.html}{ST\_LineLocatePoint(geometry A, geometry B)}: Returns a float between 0 and 1 representing the location of the closest point on LineString to the given Point.

\item {} 
\sphinxhref{http://www.postgis.org/docs/ST\_Line\_Substring.html}{ST\_Line\_Substring(geometry A, double from, double to)}: Return a linestring being a substring of the input one starting and ending at the given fractions of total 2d length.

\item {} 
\sphinxhref{https://postgis.net/docs/ST\_LocateAlong.html}{ST\_LocateAlong(geometry A, double measure, double offset)}: Return a derived geometry collection value with elements that match the specified measure.

\item {} 
\sphinxhref{https://postgis.net/docs/ST\_LocateBetween.html}{ST\_Locate\_Between(geometry A, double from, double to, double offset)}: Return a derived geometry collection value with elements that match the specified range of measures inclusively.

\item {} 
\sphinxhref{http://postgis.net/docs/ST\_AddMeasure.html}{ST\_AddMeasure(geometry A, double from, double to)}: Return a derived geometry with measure elements linearly interpolated between the start and end points. If the geometry has no measure dimension, one is added.

\end{itemize}


\section{Dimensionally Extended 9-Intersection Model}
\label{\detokenize{advanced:dimensionally-extended-9-intersection-model}}\label{\detokenize{advanced:de9im}}
The “\sphinxhref{http://en.wikipedia.org/wiki/DE-9IM}{Dimensionally Extended 9-Intersection Model}” (DE9IM) is a framework for modelling how two spatial objects interact.

First, every spatial object has:
\begin{itemize}
\item {} 
An interior

\item {} 
A boundary

\item {} 
An exterior

\end{itemize}

For polygons, the interior, boundary and exterior are obvious:

\noindent\sphinxincludegraphics{{de9im1}.jpg}

The interior is the part bounded by the rings; the boundary is the rings themselves; the exterior is everything else in the plane.

For linear features, the interior, boundary and exterior are less well-known:

\noindent\sphinxincludegraphics{{de9im2}.jpg}

The interior is the part of the line bounded by the ends; the boundary is the ends of the linear feature, and the exterior is everything else in the plane.

For points, things are even stranger: the interior is the point; the boundary is the empty set and the exterior is everything else in the plane.

Using these definitions of interior, exterior and boundary, the relationships between any pair of spatial features can be characterized using the dimensionality of the nine possible intersections between the interiors/boundaries/exteriors of a pair of objects.

\noindent\sphinxincludegraphics{{de9im3}.jpg}

For the polygons in the example above, the intersection of the interiors is a 2-dimensional area, so that portion of the matrix is filled out with a “2”. The boundaries only intersect at points, which are zero-dimensional, so that portion of the matrix is filled out with a 0.

When there is no intersection between components, the square the matrix is filled out with an “F”.

Here’s another example, of a linestring partially entering a polygon:

\noindent\sphinxincludegraphics{{de9im4}.jpg}

The DE9IM matrix for the interaction is this:

\noindent\sphinxincludegraphics{{de9im5}.jpg}

Note that the boundaries of the two objects don’t actually intersect at all (the end point of the line interacts with the interior of the polygon, not the boundary, and vice versa), so the B/B cell is filled in with an “F”.

While it’s fun to visually fill out DE9IM matrices, it would be nice if a computer could do it, and that’s what the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Relate}} function is for.

The previous example can be simplified using a simple box and line, with the same spatial relationship as our polygon and linestring:

\noindent\sphinxincludegraphics{{de9im6}.jpg}

And we can generate the DE9IM information in SQL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Relate}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}LINESTRING(0 0, 2 0)\PYGZsq{}}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}POLYGON((1 \PYGZhy{}1, 1 1, 3 1, 3 \PYGZhy{}1, 1 \PYGZhy{}1))\PYGZsq{}}
       \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The answer (1010F0212) is the same as we calculated visually, but returned as a 9-character string, with the first row, second row and third row of the table appended together.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{101}
\PYG{l+m+mi}{0}\PYG{n}{F0}
\PYG{l+m+mi}{212}
\end{sphinxVerbatim}

However, the power of DE9IM matrices is not in generating them, but in using them as a matching key to find geometries with very specific relationships to one another.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{lakes} \PYG{p}{(} \PYG{n}{id} \PYG{n+nb}{serial} \PYG{k}{primary} \PYG{k}{key}\PYG{p}{,} \PYG{n}{geom} \PYG{n}{geometry}\PYG{p}{(}\PYG{n}{POLYGON}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{docks} \PYG{p}{(} \PYG{n}{id} \PYG{n+nb}{serial} \PYG{k}{primary} \PYG{k}{key}\PYG{p}{,} \PYG{n}{good} \PYG{n+nb}{boolean}\PYG{p}{,} \PYG{n}{geom} \PYG{n}{geometry}\PYG{p}{(}\PYG{n}{LINESTRING}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{lakes} \PYG{p}{(} \PYG{n}{geom} \PYG{p}{)}
  \PYG{k}{VALUES} \PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}POLYGON ((100 200, 140 230, 180 310, 280 310, 390 270, 400 210, 320 140, 215 141, 150 170, 100 200))\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{docks} \PYG{p}{(} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{good} \PYG{p}{)}
  \PYG{k}{VALUES}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (170 290, 205 272)\PYGZsq{}}\PYG{p}{,}\PYG{k}{true}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (120 215, 176 197)\PYGZsq{}}\PYG{p}{,}\PYG{k}{true}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (290 260, 340 250)\PYGZsq{}}\PYG{p}{,}\PYG{k}{false}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (350 300, 400 320)\PYGZsq{}}\PYG{p}{,}\PYG{k}{false}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (370 230, 420 240)\PYGZsq{}}\PYG{p}{,}\PYG{k}{false}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (370 180, 390 160)\PYGZsq{}}\PYG{p}{,}\PYG{k}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Suppose we have a data model that includes \sphinxstylestrong{Lakes} and \sphinxstylestrong{Docks}, and suppose further that Docks must be inside lakes, and must touch the boundary of their containing lake at one end. Can we find all the docks in our database that obey that rule?

\noindent\sphinxincludegraphics{{de9im7}.jpg}

Our legal docks have the following characteristics:
\begin{itemize}
\item {} 
Their interiors have a linear (1D) intersection with the lake interior

\item {} 
Their boundaries have a point (0D) intersection with the lake interior

\item {} 
Their boundaries \sphinxstylestrong{also} have a point (0D) intersection with the lake boundary

\item {} 
Their interiors have no intersection (F) with the lake exterior

\end{itemize}

So their DE9IM matrix looks like this:

\noindent\sphinxincludegraphics{{de9im8}.jpg}

So to find all the legal docks, we would want to find all the docks that intersect lakes (a super-set of \sphinxstylestrong{potential} candidates we use for our join key), and then find all the docks in that set which have the legal relate pattern.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{docks}\PYG{p}{.}\PYG{o}{*}
\PYG{k}{FROM} \PYG{n}{docks} \PYG{k}{JOIN} \PYG{n}{lakes} \PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{docks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{lakes}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Relate}\PYG{p}{(}\PYG{n}{docks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{lakes}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}1FF00F212\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer: our two good docks}
\end{sphinxVerbatim}

Note the use of the three-parameter version of \sphinxstyleliteralstrong{\sphinxupquote{ST\_Relate}}, which returns true if the pattern matches or false if it does not. For a fully-defined pattern like this one, the three-parameter version is not needed \textendash{} we could have just used a string equality operator.

However, for looser pattern searches, the three-parameter allows substitution characters in the pattern string:
\begin{itemize}
\item {} 
“*” means “any value in this cell is acceptable”

\item {} 
“T” means “any non-false value (0, 1 or 2) is acceptable”

\end{itemize}

So for example, one possible dock we did not include in our example graphic is a dock with a two-dimensional intersection with the lake boundary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{docks} \PYG{p}{(} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{good} \PYG{p}{)}
  \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING (140 230, 150 250, 210 230)\PYGZsq{}}\PYG{p}{,}\PYG{k}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{de9im9}.jpg}

If we are to include this case in our set of “legal” docks, we need to change the relate pattern in our query. In particular, the intersection of the dock interior lake boundary can now be either 1 (our new case) or F (our original case). So we use the “*” catchall in the pattern.

\noindent\sphinxincludegraphics{{de9im10}.jpg}

And the SQL looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{docks}\PYG{p}{.}\PYG{o}{*}
\PYG{k}{FROM} \PYG{n}{docks} \PYG{k}{JOIN} \PYG{n}{lakes} \PYG{k}{ON} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{docks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{lakes}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Relate}\PYG{p}{(}\PYG{n}{docks}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{lakes}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}1*F00F212\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer: our (now) three good docks}
\end{sphinxVerbatim}

Confirm that the stricter SQL from the previous example does \sphinxstyleemphasis{not} return the new dock.

The TIGER data is carefully quality controlled when it is prepared, so we expect our data to meet strict standards. For example: no census block should overlap any other census block. Can we test for that?

\noindent\sphinxincludegraphics{{de9im11}.jpg}

Sure!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{a}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{id}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{a}\PYG{p}{,} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{b}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{AND} \PYG{n}{ST\PYGZus{}Relate}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}2********\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{AND} \PYG{n}{a}\PYG{p}{.}\PYG{n}{id} \PYG{o}{!}\PYG{o}{=} \PYG{n}{b}\PYG{p}{.}\PYG{n}{id}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer: 10, there\PYGZsq{}s some funny business}
\end{sphinxVerbatim}

Similarly, we would expect that the roads data is all end-noded. That is, we expect that intersections only occur at the ends of lines, not at the mid-points.

\noindent\sphinxincludegraphics{{de9im12}.jpg}

We can test for that by looking for streets that intersect (so we have a join) but where the intersection between the boundaries is not zero-dimensional (that is, the end points don’t touch):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{a}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{id}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{a}\PYG{p}{,} \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{b}
\PYG{k}{WHERE} \PYG{n}{ST\PYGZus{}Intersects}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
  \PYG{k}{AND} \PYG{k}{NOT} \PYG{n}{ST\PYGZus{}Relate}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}****0****\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{AND} \PYG{n}{a}\PYG{p}{.}\PYG{n}{id} \PYG{o}{!}\PYG{o}{=} \PYG{n}{b}\PYG{p}{.}\PYG{n}{id}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Answer: 10, this happens, so the data is not end\PYGZhy{}noded.}
\end{sphinxVerbatim}


\subsection{Function List}
\label{\detokenize{advanced:id7}}
\sphinxhref{http://postgis.net/docs/ST\_Relate.html}{ST\_Relate(geometry A, geometry B)}: Returns a text string representing the DE9IM relationship between the geometries.


\section{Clustering on Indices}
\label{\detokenize{advanced:clustering-on-indices}}\label{\detokenize{advanced:clusterindex}}
Databases can only retrieve information as fast as they can get it off of disk. Small databases will float up entirely into RAM cache, and get away from physical disk limitations, but for large databases, access to the physical disk will be a limiting stop in disk access speed.

Data is written to disk opportunistically, so there is not necessarily any correlation between the order data is stored on the disk and the way it will be accessed or organized by applications. With the advent of Solid State Disks (SSD) this is changing to improve performance, \sphinxhref{https://postgis.net/docs/using\_postgis\_dbmanagement.html\#idm2461}{in the postgis Data Management and Queries} is mentioned the configuration for an index on an SSD.

\noindent\sphinxincludegraphics{{clustering1}.jpg}

One way to speed up access to data is to ensure that records which is likely to be retrieved together in the same result set are located in similar physical locations on the hard disk platters. This is called “clustering”.

The right clustering scheme to use can be tricky, but a general rule applies: indexes define a natural ordering scheme for data which is similar to the access pattern that will be used in retrieving the data.

\noindent\sphinxincludegraphics{{clustering2}.jpg}

Because of this, ordering the data on the disk in the same order as the index can provide a speed advantage in some cases.


\subsection{Clustering on the R-Tree}
\label{\detokenize{advanced:clustering-on-the-r-tree}}
Spatial data tends to be accessed in spatially correlated windows: think of the map window in a web or desktop application. All the data in the windows has similar location value (or it wouldn’t be in the window!)

So, clustering based on a spatial index makes sense for spatial data that is going to be accessed with spatial queries: similar things tend to have similar locations.

Let’s cluster our \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} based on their spatial index:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Cluster the blocks based on their spatial index}
\PYG{k}{CLUSTER} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{USING} \PYG{n}{sidx\PYGZus{}nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}geom}\PYG{p}{;}
\end{sphinxVerbatim}

The command re-writes the \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} in the order defined by the spatial index \sphinxcode{\sphinxupquote{sidx\_nyc\_census\_blocks\_geom}}. Can you perceive a speed difference? Probably not, because the table is quite small and easily fits into memory, so disk access overhead doesn’t affect performance.

One of the surprises of the R-Tree is that an R-Tree built incrementally on spatial data might not have high spatial coherence of the leaves. For example, see this visualization of the spatial index leaves of an index on roads in the province of British Columbia.

\noindent\sphinxincludegraphics{{clustering3}.jpg}

We would prefer to cluster using a more spatially compact tree, like this balanced R-Tree.

\noindent\sphinxincludegraphics{{clustering4}.jpg}

We don’t have a balanced R-Tree algorithm available in PostGIS, but we do have a useful proxy that puts spatial data into a spatially autocorrelated order, the \sphinxstylestrong{ST\_GeoHash()} function.


\subsection{Clustering on GeoHash}
\label{\detokenize{advanced:clustering-on-geohash}}
To cluster on the ST\_GeoHash() function, you first need to have a geohash index on your data. Fortunately, they are easy to build.

Geohash is a public domain geocode system invented in 2008 by Gustavo Niemeyer, it encodes a geographic location into a short string of letters and digits. The first step is decoding it from a variant of base 32 using all digits 0-9 and almost all lower case letters except a, i, l and o, here is an example following the \sphinxhref{https://en.wikipedia.org/wiki/Geohash}{hash ezs42}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Decimal} \PYG{o}{\textbar{}} \PYG{n}{Base} \PYG{l+m+mi}{32}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{l+m+mi}{0}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{0}
    \PYG{l+m+mi}{1}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{1}
    \PYG{l+m+mi}{2}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{2}
    \PYG{l+m+mi}{3}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{3}
    \PYG{l+m+mi}{4}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{4}
    \PYG{l+m+mi}{5}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{5}
    \PYG{l+m+mi}{6}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{6}
    \PYG{l+m+mi}{7}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{7}
    \PYG{l+m+mi}{8}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{8}
    \PYG{l+m+mi}{9}   \PYG{o}{\textbar{}} \PYG{l+m+mi}{9}
    \PYG{l+m+mi}{10}  \PYG{o}{\textbar{}} \PYG{n}{b}
    \PYG{l+m+mi}{11}  \PYG{o}{\textbar{}} \PYG{n}{c}
    \PYG{l+m+mi}{12}  \PYG{o}{\textbar{}} \PYG{n}{d}
    \PYG{l+m+mi}{13}  \PYG{o}{\textbar{}} \PYG{n}{e}
    \PYG{l+m+mi}{14}  \PYG{o}{\textbar{}} \PYG{n}{f}
    \PYG{l+m+mi}{15}  \PYG{o}{\textbar{}} \PYG{n}{g}
    \PYG{l+m+mi}{16}  \PYG{o}{\textbar{}} \PYG{n}{h}
    \PYG{l+m+mi}{17}  \PYG{o}{\textbar{}} \PYG{n}{j}
    \PYG{l+m+mi}{18}  \PYG{o}{\textbar{}} \PYG{n}{k}
    \PYG{l+m+mi}{19}  \PYG{o}{\textbar{}} \PYG{n}{m}
    \PYG{l+m+mi}{20}  \PYG{o}{\textbar{}} \PYG{n}{n}
    \PYG{l+m+mi}{21}  \PYG{o}{\textbar{}} \PYG{n}{p}
    \PYG{l+m+mi}{22}  \PYG{o}{\textbar{}} \PYG{n}{q}
    \PYG{l+m+mi}{23}  \PYG{o}{\textbar{}} \PYG{n}{r}
    \PYG{l+m+mi}{24}  \PYG{o}{\textbar{}} \PYG{n}{s}
    \PYG{l+m+mi}{25}  \PYG{o}{\textbar{}} \PYG{n}{t}
    \PYG{l+m+mi}{26}  \PYG{o}{\textbar{}} \PYG{n}{u}
    \PYG{l+m+mi}{27}  \PYG{o}{\textbar{}} \PYG{n}{v}
    \PYG{l+m+mi}{28}  \PYG{o}{\textbar{}} \PYG{n}{w}
    \PYG{l+m+mi}{29}  \PYG{o}{\textbar{}} \PYG{n}{y}
    \PYG{l+m+mi}{30}  \PYG{o}{\textbar{}} \PYG{n}{z}
\end{sphinxVerbatim}

This operation results in the bits 01101 11111 11000 00100 00010. Assuming that counting starts at 0 in the left side, the even bits are taken for the longitude code (0111110000000), while the odd bits are taken for the latitude code (101111001001).

Each binary code is then used in a series of divisions, considering one bit at a time, again from the left to the right side. For the latitude value, the interval -90 to +90 is divided by 2, producing two intervals: -90 to 0, and 0 to +90. Since the first bit is 1, the higher interval is chosen, and becomes the current interval. The procedure is repeated for all bits in the code. Finally, the latitude value is the center of the resulting interval. Longitudes are processed in an equivalent way, keeping in mind that the initial interval is -180 to +180.

The geohash algorithm only works on data in geographic (longitude/latitude) coordinates, so we need to transform the geometries (to EPSG:4326, which is longitude/latitude) at the same time as we hash them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{geohash\PYGZus{}nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{p}{(}\PYG{n}{ST\PYGZus{}GeoHash}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Once you have a geohash index, clustering on it uses the same syntax as the R-Tree clustering.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CLUSTER} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{USING} \PYG{n}{geohash\PYGZus{}nyc\PYGZus{}census\PYGZus{}blocks}\PYG{p}{;}
\end{sphinxVerbatim}

Now your data is nicely arranged in spatially correlated order!


\subsection{Function List}
\label{\detokenize{advanced:id8}}
\sphinxhref{http://postgis.net/docs/ST\_GeoHash.html}{ST\_GeoHash(geometry A)}: Returns a text string representing the GeoHash of the bounds of the object.


\section{3-D}
\label{\detokenize{advanced:d}}\label{\detokenize{advanced:id9}}
\begin{sphinxadmonition}{note}{Note:}
This section refers to many features that are only available with PostGIS 2.0 and higher.
\end{sphinxadmonition}


\subsection{3-D Geometries}
\label{\detokenize{advanced:d-geometries}}
So far, we have been working with 2-D geometries, with only X and Y coordinates. But PostGIS supports additional dimensions on all geometry types, a “Z” dimension to add height information and a “M” dimension for additional dimensional information (commonly time, or road-mile, or upstream-distance information) for each coordinate.

For 3-D and 4-D geometries, the extra dimensions are added as extra coordinates for each vertex in the geometry, and the geometry type is enhanced to indicate how to interpret the extra dimensions. Adding the extra dimensions results in three extra possible geometry types for each geometry primitive:
\begin{itemize}
\item {} 
Point (a 2-D type)i is joined by PointZ, PointM and PointZM types.

\item {} 
Linestring (a 2-D type) is joined by LinestringZ, LinestringM and LinestringZM types.

\item {} 
Polygon (a 2-D type) is joined by PolygonZ, PolygonM and PolygonZM types.

\item {} 
And so on.

\end{itemize}

For well-known text ({\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}}) representation, the format for higher dimensional geometries is given by the ISO SQL/MM specification. The extra dimensionality information is simply added to the text string after the type name, and the extra coordinates added after the X/Y information. For example:
\begin{itemize}
\item {} 
POINT ZM (1 2 3 4)

\item {} 
LINESTRING M (1 1 0, 1 2 0, 1 3 1, 2 2 0)

\item {} 
POLYGON Z ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0))

\end{itemize}

The ST\_AsText() function will return the above representations when dealing with 3-D and 4-D geometries.

For well-known binary ({\hyperref[\detokenize{glossary:term-wkb}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKB}}}}) representation, the format for higher dimensional geometries is given by the ISO SQL/MM specification. The BNF form of the format is available from \sphinxurl{http://svn.osgeo.org/postgis/trunk/doc/bnf-wkb.txt}.

In addition to higher-dimensional forms of the standard types, PostGIS includes a few new types that make sense in a 3-D space:
\begin{itemize}
\item {} 
The TIN type allows you to model triangular meshes as rows in your database.

\item {} 
The POLYHEDRALSURFACE allows you to model volumetric objects in your database.

\end{itemize}

Since both these types are for modelling 3-D objects, it only really makes sense to use the Z variants.  An example of a POLYHEDRALSURFACE Z would be the 1 unit cube:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POLYHEDRALSURFACE} \PYG{n}{Z} \PYG{p}{(}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
  \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{3-D Functions}
\label{\detokenize{advanced:d-functions}}
There are a number of functions built to calculate relationships between 3-D objects:
\begin{itemize}
\item {} 
ST\_3DClosestPoint — Returns the 3-dimensional point on g1 that is closest to g2. This is the first point of the 3D shortest line.

\item {} 
ST\_3DDistance — For geometry type Returns the 3-dimensional cartesian minimum distance (based on spatial ref) between two geometries in projected units.

\item {} 
ST\_3DDWithin — For 3d (z) geometry type Returns true if two geometries 3d distance is within number of units.

\item {} 
ST\_3DDFullyWithin — Returns true if all of the 3D geometries are within the specified distance of one another.

\item {} 
ST\_3DIntersects — Returns TRUE if the Geometries “spatially intersect” in 3d - only for points and linestrings

\item {} 
ST\_3DLongestLine — Returns the 3-dimensional longest line between two geometries

\item {} 
ST\_3DMaxDistance — For geometry type Returns the 3-dimensional cartesian maximum distance (based on spatial ref) between two geometries in projected units.

\item {} 
ST\_3DShortestLine — Returns the 3-dimensional shortest line between two geometries

\end{itemize}

For example, we can calculate the distance between our unit cube and a point using the ST\_3DDistance function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} This is really the distance between the top corner}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} and the point.}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}3DDistance}\PYG{p}{(}
  \PYG{l+s+s1}{\PYGZsq{}POLYHEDRALSURFACE Z (}
\PYG{l+s+s1}{    ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),}
\PYG{l+s+s1}{    ((0 0 0, 0 1 0, 0 1 1, 0 0 1, 0 0 0)),}
\PYG{l+s+s1}{    ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),}
\PYG{l+s+s1}{    ((1 1 1, 1 0 1, 0 0 1, 0 1 1, 1 1 1)),}
\PYG{l+s+s1}{    ((1 1 1, 1 0 1, 1 0 0, 1 1 0, 1 1 1)),}
\PYG{l+s+s1}{    ((1 1 1, 1 1 0, 0 1 0, 0 1 1, 1 1 1))}
\PYG{l+s+s1}{  )\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}POINT Z (2 2 2)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} So here\PYGZsq{}s a shorter form.}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}3DDistance}\PYG{p}{(}
  \PYG{l+s+s1}{\PYGZsq{}POINT Z (1 1 1)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}POINT Z (2 2 2)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Both return 1.73205080756888 == sqrt(3) as expected}
\end{sphinxVerbatim}


\subsection{N-D Indexes}
\label{\detokenize{advanced:n-d-indexes}}
Once you have data in higher dimensions it may make sense to index it. However, you should think carefully about the distribution of your data in all dimensions before applying a multi-dimensional index.

Indexes are only useful when they allow the database to drastically reduce the number of return rows as a result of a WHERE condition. For a higher dimension index to be useful, the data must cover a wide range of that dimension, relative to the kinds of queries you are constructing.
\begin{itemize}
\item {} 
A set of DEM points would probably be a \sphinxstyleemphasis{poor} candidate for a 3-D index, since the queries would usually be extracting a 2-D box of points, and rarely attempting to select a Z-slice of points.

\item {} 
A set of GPS traces in X/Y/T space might be a \sphinxstyleemphasis{good} candidate for a 3-D index, if the GPS tracks overlapped each other frequently in all dimensions (for example, driving the same route over and over at different times), since there would be large variability in all dimensions of the data set.

\end{itemize}

You can create a multi-dimensional index on data of any dimensionality (even mixed dimensionality). For example, to create a multi-dimensional index on the \sphinxcode{\sphinxupquote{nyc\_streets}} table,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{INDEX} \PYG{n}{sidx\PYGZus{}nd\PYGZus{}nyc\PYGZus{}streets} \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{USING} \PYG{n}{GIST} \PYG{p}{(}\PYG{n}{geom} \PYG{n}{gist\PYGZus{}geometry\PYGZus{}ops\PYGZus{}nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{gist\_geometry\_ops\_nd}} parameter tells PostGIS to use the N-D index instead of the standard 2-D index.

Once you have the index built, you can use it in queries with the \sphinxcode{\sphinxupquote{\&\&\&}} index operator. \sphinxcode{\sphinxupquote{\&\&\&}} has the same semantics as \sphinxcode{\sphinxupquote{\&\&}}, “bounding boxes interact”, but applies those semantics using all the dimensions of the input geometries. Geometries with mis-matching dimensionality do not interact.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Returns true (both 3\PYGZhy{}D on the zero plane)}
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}POINT Z (1 1 0)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{l+s+s1}{\PYGZsq{}POLYGON ((0 0 0, 0 2 0, 2 2 0, 2 0 0, 0 0 0))\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Returns false (one 2\PYGZhy{}D one 3\PYGZhy{}D)}
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}POINT Z (1 1 1)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{l+s+s1}{\PYGZsq{}POLYGON ((0 0, 0 2, 2 2, 2 0, 0 0))\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Returns true (the volume around the linestring interacts with the point)}
\PYG{k}{SELECT} \PYG{l+s+s1}{\PYGZsq{}LINESTRING Z(0 0 0, 1 1 1)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
       \PYG{l+s+s1}{\PYGZsq{}POINT(0 1 1)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{;}
\end{sphinxVerbatim}

To search the \sphinxcode{\sphinxupquote{nyc\_streets}} table using the N-D index, just replace the usual \sphinxcode{\sphinxupquote{\&\&}} 2-D index operator with the \sphinxcode{\sphinxupquote{\&\&\&}} operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} N\PYGZhy{}D index operator}
\PYG{k}{SELECT} \PYG{n}{id}\PYG{p}{,} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{WHERE} \PYG{n}{geom} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
      \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586785 4492901,587561 4493037)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 2\PYGZhy{}D index operator}
\PYG{k}{SELECT} \PYG{n}{id}\PYG{p}{,} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{WHERE} \PYG{n}{geom} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
      \PYG{n}{ST\PYGZus{}SetSRID}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}LINESTRING(586785 4492901,587561 4493037)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The results should be the same. In general the N-D index is very slightly slower than the 2-D index, so only use the N-D index where you are certain that N-D queries will improve the selectivity of your queries.


\section{Nearest-Neighbour Searching}
\label{\detokenize{advanced:nearest-neighbour-searching}}\label{\detokenize{advanced:knn}}
\begin{sphinxadmonition}{note}{Note:}
This section refers to a feature that is only available with PostGIS 2.0 and higher.
\end{sphinxadmonition}


\subsection{What is a Nearest Neighbour Search?}
\label{\detokenize{advanced:what-is-a-nearest-neighbour-search}}
A frequently posed spatial query is: “what is the nearest \textless{}candidate feature\textgreater{} to \textless{}query feature\textgreater{}?”

Unlike a distance search, the “nearest neighbour” search doesn’t include any measurement restricting how far away candidate geometries might be, features of any distance away will be accepted, as long as they are the \sphinxstyleemphasis{nearest}. This poses a problem for traditional index-assisted queries, that require a search box, and therefore need some kind of measurement value to build the box.

The naive way to carry out a nearest neighbour query is to order the candidate table by distance from the query geometry, and then take the record with the smallest distance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Closest street to Broad Street station is Wall St}
\PYG{k}{SELECT} \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}
\PYG{k}{FROM}
  \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}\PYG{p}{,}
  \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subways}
\PYG{k}{WHERE} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{ASC}
\PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

The trouble with this approach is that it forces the database to calculate the distance between the query geometry and \sphinxstyleemphasis{every} feature in the table of candidate features, then sort them all. For a large table of  candidate features, it is not a reasonable approach.

One way to improve performance is to add an index constraint to the search. This requires a magic number: what’s the smallest box we could search around the query geometry, and still come up with at least one candidate geometry?

If you turn on timing, you can see the performance difference between the box-assisted query below and the simple query above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Closest street to Broad Street station is Wall St}
\PYG{k}{SELECT} \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}
\PYG{k}{FROM}
  \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}\PYG{p}{,}
  \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{subways}
\PYG{k}{WHERE} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}
\PYG{k}{AND} \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ST\PYGZus{}Expand}\PYG{p}{(}\PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Magic number: 200m}
\PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{subways}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{ASC}
\PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

The problem with this approach is the magic number of 200 meters. What if there had not happened to be any roads within 200m? We would have failed to come up with a result: there is always a nearest neighbour, it just might not be within 200m.


\subsection{Index-based KNN}
\label{\detokenize{advanced:index-based-knn}}
“KNN” stands for “K nearest neighbours”, where “K” is the number of neighbours you are looking for.

KNN is a pure index based nearest neighbour search. By walking up and down the index, the search can find the nearest candidate geometries without using any magical search radius numbers, so the technique is suitable and high performance even for very large tables with highly variable data densities.

\begin{sphinxadmonition}{note}{Note:}
The KNN feature is only available on PostGIS 2.0 with PostgreSQL 9.1 or greater.
\end{sphinxadmonition}

The KNN system works by evaluating distances between bounding boxes inside the PostGIS R-Tree index.

Because the index is built using the bounding boxes of geometries, the distances between any geometries that are not points will be inexact: they will be the distances between the bounding boxes of geometries.

The syntax of the index-based KNN query places a special “index-based distance operator” in the ORDER BY clause of the query, in this case “\textless{}-\textgreater{}”. There are two index-based distance operators,
\begin{itemize}
\item {} 
\sphinxstylestrong{\textless{}-\textgreater{}} means “distance between geometries”

\item {} 
\sphinxstylestrong{\textless{}\#\textgreater{}} means “distance between bounding boxes”

\end{itemize}

One side of the index-based distance operator must be a literal geometry value. We can get away with a subquery that returns as single geometry, or we could include a {\hyperref[\detokenize{glossary:term-wkt}]{\sphinxtermref{\DUrole{xref,std,std-term}{WKT}}}} geometry instead.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Closest 10 streets to Broad Street station are ?}
\PYG{k}{SELECT}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}
\PYG{k}{FROM}
  \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
\PYG{k}{ORDER} \PYG{k}{BY}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
  \PYG{p}{(}\PYG{k}{SELECT} \PYG{n}{geom} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{)}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Same query using a geometry EWKT literal}

\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsEWKT}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Broad St\PYGZsq{}}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} SRID=26918;POINT(583571 4506714)}

\PYG{k}{SELECT}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,}
  \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}
    \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}SRID=26918;POINT(583571.905921312 4506714.34119218)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
    \PYG{p}{)} \PYG{k}{AS} \PYG{n}{distance}
\PYG{k}{FROM}
  \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
\PYG{k}{ORDER} \PYG{k}{BY}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+s+s1}{\PYGZsq{}SRID=26918;POINT(583571.905921312 4506714.34119218)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n+nb}{id}   \PYG{o}{\textbar{}}    \PYG{n}{name}     \PYG{o}{\textbar{}}     \PYG{n}{distance}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{17394} \PYG{o}{\textbar{}} \PYG{n}{Wall} \PYG{n}{St}     \PYG{o}{\textbar{}} \PYG{l+m+mf}{0.714202224374917}
 \PYG{l+m+mi}{17399} \PYG{o}{\textbar{}} \PYG{n}{Broad} \PYG{n}{St}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{0.872022763400183}
 \PYG{l+m+mi}{17445} \PYG{o}{\textbar{}} \PYG{n}{Nassau} \PYG{n}{St}   \PYG{o}{\textbar{}}  \PYG{l+m+mf}{1.29928727926582}
 \PYG{l+m+mi}{17357} \PYG{o}{\textbar{}} \PYG{n}{New} \PYG{n}{St}      \PYG{o}{\textbar{}}  \PYG{l+m+mf}{63.9499165490674}
 \PYG{l+m+mi}{17411} \PYG{o}{\textbar{}} \PYG{n}{Pine} \PYG{n}{St}     \PYG{o}{\textbar{}}  \PYG{l+m+mf}{75.8461038368021}
 \PYG{l+m+mi}{17367} \PYG{o}{\textbar{}} \PYG{n}{Exchange} \PYG{n}{Pl} \PYG{o}{\textbar{}}    \PYG{l+m+mf}{101.6241843136}
 \PYG{l+m+mi}{17322} \PYG{o}{\textbar{}} \PYG{n}{Broadway}    \PYG{o}{\textbar{}}  \PYG{l+m+mf}{112.049824188021}
 \PYG{l+m+mi}{17296} \PYG{o}{\textbar{}} \PYG{n}{Rector} \PYG{n}{St}   \PYG{o}{\textbar{}}  \PYG{l+m+mf}{114.442000781044}
 \PYG{l+m+mi}{17478} \PYG{o}{\textbar{}} \PYG{n}{William} \PYG{n}{St}  \PYG{o}{\textbar{}}  \PYG{l+m+mf}{126.934064759446}
 \PYG{l+m+mi}{17354} \PYG{o}{\textbar{}} \PYG{n}{Cedar} \PYG{n}{St}    \PYG{o}{\textbar{}}  \PYG{l+m+mf}{133.009278387597}
\end{sphinxVerbatim}

Remember that all the calculations are being done using geometries. Here’s what the map looks like for the results of the query:

\noindent\sphinxincludegraphics{{knn0}.png}

We can see that the station falls right on the Wall Street line so the \sphinxstylestrong{\textless{}-\textgreater{}} operator computes the distance between geometries giving the proper answer. Moreover, the \sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance}} is in alignment with the order provided by the \sphinxstylestrong{\textless{}-\textgreater{}} operator, proving the knn functionality works!

\begin{sphinxadmonition}{note}{Note:}
For versions of PostgreSQL below 9.5 the \sphinxstylestrong{\textless{}-\textgreater{}} operator would compute distances using the centroid of the bounding boxes of the geometries, producing sometimes approximations that don’t match a nearest neighbour search between geometries.
\end{sphinxadmonition}

What about the \sphinxstylestrong{\textless{}\#\textgreater{}} operator? If we calculate the distance between box edges, the station would fall \sphinxstylestrong{inside} the Wall Street box, giving it a distance of zero and the first entry in the list, right?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Closest 10 streets to Broad Street station are ?}
\PYG{k}{SELECT}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}
\PYG{k}{FROM}
  \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
\PYG{k}{ORDER} \PYG{k}{BY}
  \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZsh{}}\PYG{o}{\PYGZgt{}}
  \PYG{l+s+s1}{\PYGZsq{}SRID=26918;POINT(583571.905921312 4506714.34119218)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
\PYG{k}{LIMIT} \PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}

Unfortunately, no.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n+nb}{id}   \PYG{o}{\textbar{}}                               \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{17315} \PYG{o}{\textbar{}} \PYG{n}{Pearl} \PYG{n}{St}
 \PYG{l+m+mi}{17364} \PYG{o}{\textbar{}} \PYG{n}{South} \PYG{n}{St}
 \PYG{l+m+mi}{17394} \PYG{o}{\textbar{}} \PYG{n}{Wall} \PYG{n}{St}
 \PYG{l+m+mi}{17411} \PYG{o}{\textbar{}} \PYG{n}{Pine} \PYG{n}{St}
 \PYG{l+m+mi}{17378} \PYG{o}{\textbar{}} \PYG{n}{FDR} \PYG{n}{Dr}
 \PYG{l+m+mi}{17236} \PYG{o}{\textbar{}}
 \PYG{l+m+mi}{17241} \PYG{o}{\textbar{}} \PYG{n}{West} \PYG{n}{Side} \PYG{n}{Highway}\PYG{p}{;} \PYG{n}{West} \PYG{n}{St}\PYG{p}{;} \PYG{n}{West} \PYG{n}{Side} \PYG{n}{Highway}\PYG{p}{;} \PYG{n}{West} \PYG{n}{Side} \PYG{n}{Highway}
 \PYG{l+m+mi}{17322} \PYG{o}{\textbar{}} \PYG{n}{Broadway}
 \PYG{l+m+mi}{17382} \PYG{o}{\textbar{}} \PYG{n}{FDR} \PYG{n}{Dr}
 \PYG{l+m+mi}{17399} \PYG{o}{\textbar{}} \PYG{n}{Broad} \PYG{n}{St}
\end{sphinxVerbatim}

There are a number of large street features with big boxes that \sphinxstylestrong{also} overlap the station and yield a box distance of zero.

\noindent\sphinxincludegraphics{{knn3}.jpg}

This may not give the results we were expecting but since it operates on bounding boxes, it provides better performance than the query using \sphinxstylestrong{\textless{}-\textgreater{}}. In case we had a very large table we could enhance the query processing by limiting our search first using the operator \sphinxstylestrong{\textless{}\#\textgreater{}} and then use the operator \sphinxstylestrong{\textless{}-\textgreater{}} in the resulting subset to get the accurate nearest neighbours:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZdq{}Closest\PYGZdq{} 100 streets to Broad Street station are?}
\PYG{k}{WITH} \PYG{n}{closest\PYGZus{}candidates} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT}
    \PYG{n}{streets}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,}
    \PYG{n}{streets}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,}
    \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom}
  \PYG{k}{FROM}
    \PYG{n}{nyc\PYGZus{}streets} \PYG{n}{streets}
  \PYG{k}{ORDER} \PYG{k}{BY}
    \PYG{n}{streets}\PYG{p}{.}\PYG{n}{geom} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZsh{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+s+s1}{\PYGZsq{}SRID=26918;POINT(583571.905921312 4506714.34119218)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
  \PYG{k}{LIMIT} \PYG{l+m+mi}{100}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{n}{id}\PYG{p}{,} \PYG{n}{name}
\PYG{k}{FROM} \PYG{n}{closest\PYGZus{}candidates}
\PYG{k}{ORDER} \PYG{k}{BY}
  \PYG{n}{geom} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{l+s+s1}{\PYGZsq{}SRID=26918;POINT(583571.905921312 4506714.34119218)\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{geometry}
\PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n+nb}{id}   \PYG{o}{\textbar{}}  \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{17394} \PYG{o}{\textbar{}} \PYG{n}{Wall} \PYG{n}{St}
\end{sphinxVerbatim}

\sphinxhref{http://postgis.net/docs/geometry\_distance\_knn.html}{knn \textless{}-\textgreater{}}: returns the 2D distance between two geometries.

\sphinxhref{http://postgis.net/docs/geometry\_distance\_box.html}{knn \textless{}\#\textgreater{}}: returns the distance between two bounding boxes.


\section{Tracking Edit History using Triggers}
\label{\detokenize{advanced:tracking-edit-history-using-triggers}}\label{\detokenize{advanced:history-tracking}}
A common requirement for production databases is the ability to track history: how has the data changed between two dates, who made the changes, and where did they occur? Some GIS systems track changes by including change management in the client interface, but that adds a lot of complexity to editing tools.

Using the database and the trigger system, it’s possible to add history tracking to any table, while maintaining simple “direct edit” access to the primary table.

History tracking works by keeping a history table that records, for every edit:
\begin{itemize}
\item {} 
If a record was created, when it was added and by whom.

\item {} 
If a record was deleted, when it was deleted and by whom.

\item {} 
If a record was updated, adding a deletion record (for the old state) and a creation record (for the new state).

\end{itemize}

Using this information it is possible to reconstruct the state of the edit table at any point in time. In this example, we will add history tracking to our \sphinxstylestrong{nyc\_streets} table.
\begin{itemize}
\item {} 
First, add a new \sphinxstylestrong{nyc\_streets\_history} table. This is the table we will use to store all the historical edit information. In addition to all the fields from \sphinxstylestrong{nyc\_streets}, we add five more fields.
\begin{itemize}
\item {} 
\sphinxstylestrong{hid} the primary key for the history table

\item {} 
\sphinxstylestrong{created} the date/time the history record was created

\item {} 
\sphinxstylestrong{created\_by} the database user that caused the record to be created

\item {} 
\sphinxstylestrong{deleted} the date/time the history record was marked as deleted

\item {} 
\sphinxstylestrong{deleted\_by} the database user that caused the record to be marked as deleted

\end{itemize}

Note that we don’t actually delete any records in the history table, we just mark the time they ceased to be part of the current state of the edit table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}history} \PYG{p}{(}
  \PYG{n}{hid} \PYG{n+nb}{SERIAL} \PYG{k}{PRIMARY} \PYG{k}{KEY}\PYG{p}{,}
  \PYG{n}{id} \PYG{n}{FLOAT8}\PYG{p}{,}
  \PYG{n}{name} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{oneway} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}
  \PYG{k}{type} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{geom} \PYG{n}{GEOMETRY}\PYG{p}{(}\PYG{n}{MultiLinestring}\PYG{p}{,}\PYG{l+m+mi}{26918}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{created} \PYG{k}{TIMESTAMP}\PYG{p}{,}
  \PYG{n}{created\PYGZus{}by} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{deleted} \PYG{k}{TIMESTAMP}\PYG{p}{,}
  \PYG{n}{deleted\PYGZus{}by} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Next, we import the current state of the active table, \sphinxstylestrong{nyc\_streets} into the history table, so we have a starting point to trace history from. Note that we fill in the creation time and creation user, but leave the deletion records NULL.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}history}
  \PYG{p}{(}\PYG{n}{id}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{oneway}\PYG{p}{,} \PYG{k}{type}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{created}\PYG{p}{,} \PYG{n}{created\PYGZus{}by}\PYG{p}{)}
   \PYG{k}{SELECT} \PYG{n}{id}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{oneway}\PYG{p}{,} \PYG{k}{type}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{k}{current\PYGZus{}user}
   \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Now we need three triggers on the active table, for INSERT, DELETE and UPDATE actions. First we create the trigger functions, then bind them to the table as triggers.

For an insert, we just add a new record into the history table with the creation time/user:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE FUNCTION nyc\PYGZus{}streets\PYGZus{}insert() RETURNS trigger AS
\PYGZdl{}\PYGZdl{}
  BEGIN
    INSERT INTO nyc\PYGZus{}streets\PYGZus{}history
      (id, name, oneway, type, geom, created, created\PYGZus{}by)
    VALUES
      (NEW.id, NEW.name, NEW.oneway, NEW.type, NEW.geom,
       current\PYGZus{}timestamp, current\PYGZus{}user);
    RETURN NEW;
  END;
\PYGZdl{}\PYGZdl{}
LANGUAGE plpgsql;

CREATE TRIGGER nyc\PYGZus{}streets\PYGZus{}insert\PYGZus{}trigger
AFTER INSERT ON nyc\PYGZus{}streets
  FOR EACH ROW EXECUTE PROCEDURE nyc\PYGZus{}streets\PYGZus{}insert();
\end{sphinxVerbatim}

For a deletion, we just mark the currently active history record (the one with a NULL deletion time) as deleted:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE FUNCTION nyc\PYGZus{}streets\PYGZus{}delete() RETURNS trigger AS
\PYGZdl{}\PYGZdl{}
  BEGIN
    UPDATE nyc\PYGZus{}streets\PYGZus{}history
      SET deleted = current\PYGZus{}timestamp, deleted\PYGZus{}by = current\PYGZus{}user
      WHERE deleted IS NULL and id = OLD.id;
    RETURN NULL;
  END;
\PYGZdl{}\PYGZdl{}
LANGUAGE plpgsql;

CREATE TRIGGER nyc\PYGZus{}streets\PYGZus{}delete\PYGZus{}trigger
AFTER DELETE ON nyc\PYGZus{}streets
  FOR EACH ROW EXECUTE PROCEDURE nyc\PYGZus{}streets\PYGZus{}delete();
\end{sphinxVerbatim}

For an update, we first mark the active history record as deleted, then insert a new record for the updated state:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE FUNCTION nyc\PYGZus{}streets\PYGZus{}update() RETURNS trigger AS
\PYGZdl{}\PYGZdl{}
  BEGIN

    UPDATE nyc\PYGZus{}streets\PYGZus{}history
      SET deleted = current\PYGZus{}timestamp, deleted\PYGZus{}by = current\PYGZus{}user
      WHERE deleted IS NULL and id = OLD.id;

    INSERT INTO nyc\PYGZus{}streets\PYGZus{}history
      (id, name, oneway, type, geom, created, created\PYGZus{}by)
    VALUES
      (NEW.id, NEW.name, NEW.oneway, NEW.type, NEW.geom,
       current\PYGZus{}timestamp, current\PYGZus{}user);

    RETURN NEW;

  END;
\PYGZdl{}\PYGZdl{}
LANGUAGE plpgsql;

CREATE TRIGGER nyc\PYGZus{}streets\PYGZus{}update\PYGZus{}trigger
AFTER UPDATE ON nyc\PYGZus{}streets
  FOR EACH ROW EXECUTE PROCEDURE nyc\PYGZus{}streets\PYGZus{}update();
\end{sphinxVerbatim}

\end{itemize}

Now that the history table is enabled, we can make edits on the main table and watch the log entries appear in the history table.

Note the power of this database-backed approach to history: \sphinxstylestrong{no matter what tool is used to make the edits, whether the SQL command line, a web-based JDBC tool, or a desktop tool like QGIS, the history is consistently tracked.}


\subsection{SQL Edits}
\label{\detokenize{advanced:sql-edits}}
Let’s turn the two streets named “Cumberland Walk” to the more stylish “Cumberland Wynde”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{UPDATE} \PYG{n}{nyc\PYGZus{}streets}
\PYG{k}{SET} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Cumberland Wynde\PYGZsq{}}
\PYG{k}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Cumberland Walk\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

Updating the two streets will cause the original streets to be marked as deleted in the history table, with a deletion time of now, and two new streets with the new name added, with an addition time of now. You can inspect the historical records:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{WHERE} \PYG{n}{name} \PYG{k}{LIKE} \PYG{l+s+s1}{\PYGZsq{}Cumberland W\PYGZpc{}\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

The results will look like:
\begin{quote}

\noindent\sphinxincludegraphics{{history01}.png}
\end{quote}


\subsubsection{Querying the History Table}
\label{\detokenize{advanced:querying-the-history-table}}
Now that we have a history table, what use is it? It’s useful for time travel! To travel to a particular time \sphinxstylestrong{T}, you need to construct a query that includes:
\begin{itemize}
\item {} 
All records created before T, and not yet deleted; and also

\item {} 
All records created before T, but deleted \sphinxstylestrong{after} T.

\end{itemize}

We can use this logic to create a query, or a view, of the state of the data in the past. Since presumably all your test edits have happened in the past couple minutes, let’s create a view of the history table that shows the state of the table 10 minutes ago, \sphinxstylestrong{before you started editing} (so, the original data).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} State of history 10 minutes ago}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Records must have been created at least 10 minute ago and}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} either be visible now (deleted is null) or deleted in the last hour}

\PYG{k}{CREATE} \PYG{k}{OR} \PYG{k}{REPLACE} \PYG{k}{VIEW} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}ten\PYGZus{}min\PYGZus{}ago} \PYG{k}{AS}
  \PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}history}
    \PYG{k}{WHERE} \PYG{n}{created} \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+s+s1}{\PYGZsq{}10min\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{interval}\PYG{p}{)}
    \PYG{k}{AND} \PYG{p}{(} \PYG{n}{deleted} \PYG{k}{IS} \PYG{k}{NULL} \PYG{k}{OR} \PYG{n}{deleted} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+s+s1}{\PYGZsq{}10min\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{interval}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We can also create views that show just what a particular user has added, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{OR} \PYG{k}{REPLACE} \PYG{k}{VIEW} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}postgres} \PYG{k}{AS}
  \PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets\PYGZus{}history}
    \PYG{k}{WHERE} \PYG{n}{created\PYGZus{}by} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}postgres\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{See Also}
\label{\detokenize{advanced:see-also}}\begin{itemize}
\item {} 
\sphinxhref{http://qgis.org}{QGIS open source GIS}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/plpgsql-trigger.html}{PostgreSQL Triggers}

\end{itemize}


\section{Advanced Geometry Constructions}
\label{\detokenize{advanced:advanced-geometry-constructions}}\label{\detokenize{advanced:advanced-geometry-construction}}
The \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} layer has provided us with lots of interesting examples so far, but there is something striking about it:

\noindent\sphinxincludegraphics{{adv_geom0}.png}

Although it is a database of all the stations, it doesn’t allow easy visualization of routes! In this chapter we will use advanced features of PostgreSQL and PostGIS to build up a new linear routes layer from the point layer of subway stations.

Our task is made especially difficult by two issues:
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{routes}} column of \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} has multiple route identifiers in each row, so a station that might appear in multiple routes appears only once in the table.

\item {} 
Related to the previous issue, there is no route ordering information in the stations table, so while it is possible to find all the stations in a particular route, it’s not possible using the attributes to determine what the order in which trains travel through the stations.

\end{itemize}

The second problem is the harder one: given an unordered set of points in a route, how do we order them to match the actual route.

Here are the stops for the ‘Q’ train:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}
\PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
\PYG{k}{WHERE} \PYG{p}{(}\PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Q\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this picture, the stops are labelled with their unique \sphinxcode{\sphinxupquote{id}} primary key.

\noindent\sphinxincludegraphics[height=700\sphinxpxdimen]{{adv_geom01}.png}

If we start at one of the end stations, the next station on the line seems to always be the closest. We can repeat the process each time as long as we exclude all the previously found stations from our search.

There are two ways to run such an iterative routine in a database:
\begin{itemize}
\item {} 
Using a procedural language, like \sphinxhref{http://www.postgresql.org/docs/current/static/plpgsql.html}{PL/PgSQL}.

\item {} 
Using recursive \sphinxhref{http://www.postgresql.org/docs/current/static/queries-with.html}{common table expressions}.

\end{itemize}

Common table expressions (CTE) have the virtue of not requiring a function definition to run. Here’s the CTE to calculate the route line of the ‘Q’ train, starting from the northernmost stop (where \sphinxcode{\sphinxupquote{id}} is 365).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{k}{RECURSIVE} \PYG{n}{next\PYGZus{}stop}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{idlist}\PYG{p}{)} \PYG{k}{AS} \PYG{p}{(}
    \PYG{p}{(}\PYG{k}{SELECT}
      \PYG{n}{geom}\PYG{p}{,}
      \PYG{n+nb}{ARRAY}\PYG{p}{[}\PYG{n}{id}\PYG{p}{]} \PYG{k}{AS} \PYG{n}{idlist}
    \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
    \PYG{k}{WHERE} \PYG{n}{id} \PYG{o}{=} \PYG{l+m+mi}{365}\PYG{p}{)}
    \PYG{k}{UNION} \PYG{k}{ALL}
    \PYG{p}{(}\PYG{k}{SELECT}
      \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}
      \PYG{n}{array\PYGZus{}append}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{idlist}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{idlist}
    \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}\PYG{p}{,} \PYG{n}{next\PYGZus{}stop} \PYG{n}{n}
    \PYG{k}{WHERE} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Q\PYGZsq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{AND} \PYG{k}{NOT} \PYG{n}{n}\PYG{p}{.}\PYG{n}{idlist} \PYG{o}{@}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{ARRAY}\PYG{p}{[}\PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{]}
    \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{ASC}
    \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{idlist} \PYG{k}{FROM} \PYG{n}{next\PYGZus{}stop}\PYG{p}{;}
\end{sphinxVerbatim}

The CTE consists of two halves, unioned together:
\begin{itemize}
\item {} 
The first half establishes a start point for the expression. We get the initial geometry and initialize the array of visited identifiers, using the record of “id” 365 (the end of the line).

\item {} 
The second half iterates until it finds no further records. At each iteration it takes in the value at the previous iteration via the self-reference to “next\_stop”. We search every stop on the Q line (\sphinxstylestrong{strpos(s.routes,’Q’)}) that we have not already added to our visited list (\sphinxstylestrong{NOT n.idlist @\textgreater{} ARRAY{[}s.gid{]}}) and order them by their distance from the previous point, taking just the first one (the nearest).

\end{itemize}

Beyond the recursive CTE itself, there are a number of advanced PostgreSQL array features being used here:
\begin{itemize}
\item {} 
We are using ARRAY! PostgreSQL supports arrays of any type. In this case we have an array of integers, but we could also build an array of geometries, or any other PostgreSQL type.

\item {} 
We are using \sphinxstylestrong{array\_append} to build up our array of visited identifiers.

\item {} 
We are using the \sphinxstylestrong{@\textgreater{}} array operator (“array contains”) to find which of the Q train stations we have already visited. The \sphinxstylestrong{@\textgreater{}} operators requires ARRAY values on both sides, so we have to turn the individual “id” numbers into single-entry arrays using the ARRAY{[}{]} syntax.

\end{itemize}

When you run the query, you get each geometry in the order it is found (which is the route order), as well as the list of identifiers already visited. Wrapping the geometries into the PostGIS \sphinxhref{http://postgis.net/docs/ST\_MakeLine.html}{ST\_MakeLine} aggregate function turns the set of geometries into a single linear output, constructed in the provided order.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{k}{RECURSIVE} \PYG{n}{next\PYGZus{}stop}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{idlist}\PYG{p}{)} \PYG{k}{AS} \PYG{p}{(}
    \PYG{p}{(}\PYG{k}{SELECT}
      \PYG{n}{geom}\PYG{p}{,}
      \PYG{n+nb}{ARRAY}\PYG{p}{[}\PYG{n}{gid}\PYG{p}{]} \PYG{k}{AS} \PYG{n}{idlist}
    \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations}
    \PYG{k}{WHERE} \PYG{n}{gid} \PYG{o}{=} \PYG{l+m+mi}{304}\PYG{p}{)}
    \PYG{k}{UNION} \PYG{k}{ALL}
    \PYG{p}{(}\PYG{k}{SELECT}
      \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}
      \PYG{n}{array\PYGZus{}append}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{idlist}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{gid}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{idlist}
    \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}\PYG{p}{,} \PYG{n}{next\PYGZus{}stop} \PYG{n}{n}
    \PYG{k}{WHERE} \PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Q\PYGZsq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{AND} \PYG{k}{NOT} \PYG{n}{n}\PYG{p}{.}\PYG{n}{idlist} \PYG{o}{@}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{ARRAY}\PYG{p}{[}\PYG{n}{s}\PYG{p}{.}\PYG{n}{gid}\PYG{p}{]}
    \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{n}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{ASC}
    \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}MakeLine}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom} \PYG{k}{FROM} \PYG{n}{next\PYGZus{}stop}\PYG{p}{;}
\end{sphinxVerbatim}

Which looks like this:

\noindent\sphinxincludegraphics[height=700\sphinxpxdimen]{{adv_geom03}.png}

\sphinxstyleemphasis{Success!}

Except, two problems:
\begin{itemize}
\item {} 
We are only calculating one subway route here, we want to calculate all the routes.

\item {} 
Our query includes a piece of \sphinxstyleemphasis{a priori} knowledge, the initial station identifier that serves as the seed for the search algorithm that builds the route.

\end{itemize}

Let’s tackle the hard problem first, figuring out the first station on a route without manually eyeballing the set of stations that make up the route.

Our ‘Q’ train stops can serve as a starting point. What characterizes the end stations of the route?

\noindent\sphinxincludegraphics[height=700\sphinxpxdimen]{{adv_geom01}.png}

One answer is “they are the most northerly and southerly stations”. However, imagine if the ‘Q’ train ran from east to west. Would the condition still hold?

A less directional characterization of the end stations is “they are the furthest stations from the middle of the route”. With this characterization it doesn’t matter if the route runs north/south or east/west, just that it run in more-or-less one direction, particularly at the ends.

Since there is no 100\% heuristic to figure out the end points, let’s try this second rule out.

\begin{sphinxadmonition}{note}{Note:}
An obvious failure mode of the “furthest from middle” rule is a circular line, like the Circle Line in London, UK. Fortunately, New York doesn’t have any such lines!
\end{sphinxadmonition}

To work out the end stations of every route, we first have to work out what routes there are! We find the distinct routes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{n}{routes} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{unnest}\PYG{p}{(}\PYG{n}{string\PYGZus{}to\PYGZus{}array}\PYG{p}{(}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{routes}\PYG{p}{;}
\end{sphinxVerbatim}

Note the use of two advanced PostgreSQL ARRAY functions:
\begin{itemize}
\item {} 
\sphinxstylestrong{string\_to\_array} takes in a string and splits it into an array using a separator character. \sphinxhref{http://www.postgresql.org/docs/current/static/arrays.html}{PostgreSQL supports arrays} of any type, so it’s possible to build arrays of strings, as in this case, but also of geometries and geographies as we’ll see later in this example.

\item {} 
\sphinxstylestrong{unnest} takes in an array and builds a new row for each entry in the array. The effect is to take a “horizontal” array embedded in a single row and turn it into a “vertical” array with a row for each value.

\end{itemize}

The result is a list of all the unique subway route identifiers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{route}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{1}
 \PYG{l+m+mi}{2}
 \PYG{l+m+mi}{3}
 \PYG{l+m+mi}{4}
 \PYG{l+m+mi}{5}
 \PYG{l+m+mi}{6}
 \PYG{l+m+mi}{7}
 \PYG{n}{A}
 \PYG{n}{B}
 \PYG{n}{C}
 \PYG{n}{D}
 \PYG{n}{E}
 \PYG{n}{F}
 \PYG{n}{G}
 \PYG{n}{J}
 \PYG{n}{L}
 \PYG{n}{M}
 \PYG{n}{N}
 \PYG{n}{Q}
 \PYG{n}{R}
 \PYG{n}{S}
 \PYG{n}{V}
 \PYG{n}{W}
 \PYG{n}{Z}
\PYG{p}{(}\PYG{l+m+mi}{24} \PYG{n}{rows}\PYG{p}{)}
\end{sphinxVerbatim}

We can build on this result by joining it back to the \sphinxcode{\sphinxupquote{nyc\_subway\_stations}} table to create a new table that has, for each route, a row for every station on that route.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{n}{routes} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{unnest}\PYG{p}{(}\PYG{n}{string\PYGZus{}to\PYGZus{}array}\PYG{p}{(}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{routes} \PYG{n}{r}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{stops}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n+nb}{id}  \PYG{o}{\textbar{}}                        \PYG{n}{geom}                        \PYG{o}{\textbar{}} \PYG{n}{route}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
   \PYG{l+m+mi}{2} \PYG{o}{\textbar{}} \PYG{l+m+mi}{010100002026690000}\PYG{n}{CBE327F938CD21415EDBE1572D315141} \PYG{o}{\textbar{}} \PYG{l+m+mi}{1}
   \PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{l+m+mi}{010100002026690000}\PYG{n}{C676635D10CD2141A0ECDB6975305141} \PYG{o}{\textbar{}} \PYG{l+m+mi}{1}
  \PYG{l+m+mi}{36} \PYG{o}{\textbar{}} \PYG{l+m+mi}{010100002026690000}\PYG{n}{AE59A3F82C132241D835BA14D1435141} \PYG{o}{\textbar{}} \PYG{l+m+mi}{1}
  \PYG{l+m+mi}{37} \PYG{o}{\textbar{}} \PYG{l+m+mi}{0101000020266900003495}\PYG{n}{A303D615224116DA56527D445141} \PYG{o}{\textbar{}} \PYG{l+m+mi}{1}

                            \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{etc}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

Now we can find the center point by collecting all the stations for each route into a single multi-point, and calculating the centroid of that multi-point.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{n}{routes} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{unnest}\PYG{p}{(}\PYG{n}{string\PYGZus{}to\PYGZus{}array}\PYG{p}{(}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{routes} \PYG{n}{r}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{centers} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Centroid}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Collect}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{stops}
  \PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{centers}\PYG{p}{;}
\end{sphinxVerbatim}

The center point of the collection of ‘Q’ train stops looks like this:

\noindent\sphinxincludegraphics[height=700\sphinxpxdimen]{{adv_geom04}.png}

So the northern most stop, the end point, appears to also be the stop furthest from the center. Let’s calculate the furthest point for every route.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WITH} \PYG{n}{routes} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{unnest}\PYG{p}{(}\PYG{n}{string\PYGZus{}to\PYGZus{}array}\PYG{p}{(}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{routes} \PYG{n}{r}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{centers} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Centroid}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Collect}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{stops}
  \PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{stops\PYGZus{}distance} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{o}{*}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{k}{c}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{distance}
  \PYG{k}{FROM} \PYG{n}{stops} \PYG{n}{s} \PYG{k}{JOIN} \PYG{n}{centers} \PYG{k}{c}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{route} \PYG{o}{=} \PYG{k}{c}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)}
  \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}\PYG{p}{,} \PYG{n}{distance} \PYG{k}{DESC}
\PYG{p}{)}\PYG{p}{,}
\PYG{n}{first\PYGZus{}stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{ON} \PYG{p}{(}\PYG{n}{route}\PYG{p}{)} \PYG{n}{stops\PYGZus{}distance}\PYG{p}{.}\PYG{o}{*}
  \PYG{k}{FROM} \PYG{n}{stops\PYGZus{}distance}
\PYG{p}{)}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{first\PYGZus{}stops}\PYG{p}{;}
\end{sphinxVerbatim}

We’ve added two sub-queries this time:
\begin{itemize}
\item {} 
\sphinxstylestrong{stops\_distance} joins the centers points back to the stations table and calculates the distance between the stations and center for each route. The result is ordered such that the records come out in batches for each route, with the furthest station as the first record of the batch.

\item {} 
\sphinxstylestrong{first\_stops} filters the \sphinxstylestrong{stops\_distance} output by only taking the first record for each distinct group. Because of the way we ordered \sphinxstylestrong{stops\_distance} the first record is the furthest record, which means it’s the station we want to use as our starting seed to build each subway route.

\end{itemize}

Now we know every route, and we know (approximately) what station each route starts from: we’re ready to generate the route lines!

But first, we need to turn our recursive CTE expression into a function we can call with parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE function walk\PYGZus{}subway(integer, text) returns geometry AS
\PYGZdl{}\PYGZdl{}
WITH RECURSIVE next\PYGZus{}stop(geom, idlist) AS (
    (SELECT
      geom AS geom,
      ARRAY[id] AS idlist
    FROM nyc\PYGZus{}subway\PYGZus{}stations
    WHERE id = \PYGZdl{}1)
    UNION ALL
    (SELECT
      s.geom AS geom,
      array\PYGZus{}append(n.idlist, s.id) AS idlist
    FROM nyc\PYGZus{}subway\PYGZus{}stations s, next\PYGZus{}stop n
    WHERE strpos(s.routes, \PYGZdl{}2) != 0
    AND NOT n.idlist @\PYGZgt{} ARRAY[s.id]
    ORDER BY ST\PYGZus{}Distance(n.geom, s.geom) ASC
    LIMIT 1)
)
SELECT ST\PYGZus{}MakeLine(geom) AS geom
FROM next\PYGZus{}stop;
\PYGZdl{}\PYGZdl{}
language \PYGZsq{}sql\PYGZsq{};
\end{sphinxVerbatim}

And now we are ready to go!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}lines} \PYG{k}{AS}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Distinct route identifiers!}
\PYG{k}{WITH} \PYG{n}{routes} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{unnest}\PYG{p}{(}\PYG{n}{string\PYGZus{}to\PYGZus{}array}\PYG{p}{(}\PYG{n}{routes}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Joined back to stops! Every route has all its stops!}
\PYG{n}{stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{routes} \PYG{n}{r}
  \PYG{k}{JOIN} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}stations} \PYG{n}{s}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{strpos}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{routes}\PYG{p}{,} \PYG{n}{r}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Collects stops by routes and calculate centroid!}
\PYG{n}{centers} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}Centroid}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Collect}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{route}
  \PYG{k}{FROM} \PYG{n}{stops}
  \PYG{k}{GROUP} \PYG{k}{BY} \PYG{n}{route}
\PYG{p}{)}\PYG{p}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Calculate stop/center distance for each stop in each route.}
\PYG{n}{stops\PYGZus{}distance} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{n}{s}\PYG{p}{.}\PYG{o}{*}\PYG{p}{,} \PYG{n}{ST\PYGZus{}Distance}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{k}{c}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{distance}
  \PYG{k}{FROM} \PYG{n}{stops} \PYG{n}{s} \PYG{k}{JOIN} \PYG{n}{centers} \PYG{k}{c}
  \PYG{k}{ON} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{route} \PYG{o}{=} \PYG{k}{c}\PYG{p}{.}\PYG{n}{route}\PYG{p}{)}
  \PYG{k}{ORDER} \PYG{k}{BY} \PYG{n}{route}\PYG{p}{,} \PYG{n}{distance} \PYG{k}{DESC}
\PYG{p}{)}\PYG{p}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Filter out just the furthest stop/center pairs.}
\PYG{n}{first\PYGZus{}stops} \PYG{k}{AS} \PYG{p}{(}
  \PYG{k}{SELECT} \PYG{k}{DISTINCT} \PYG{k}{ON} \PYG{p}{(}\PYG{n}{route}\PYG{p}{)} \PYG{n}{stops\PYGZus{}distance}\PYG{p}{.}\PYG{o}{*}
  \PYG{k}{FROM} \PYG{n}{stops\PYGZus{}distance}
\PYG{p}{)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Pass the route/stop information into the linear route generation function!}
\PYG{k}{SELECT}
  \PYG{n}{ascii}\PYG{p}{(}\PYG{n}{route}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{id}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} QGIS likes numeric primary keys}
  \PYG{n}{route}\PYG{p}{,}
  \PYG{n}{walk\PYGZus{}subway}\PYG{p}{(}\PYG{n}{id}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{Integer}\PYG{p}{,} \PYG{n}{route}\PYG{p}{)} \PYG{k}{AS} \PYG{n}{geom}
\PYG{k}{FROM} \PYG{n}{first\PYGZus{}stops}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Do some housekeeping too}
\PYG{k}{ALTER} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}subway\PYGZus{}lines} \PYG{k}{ADD} \PYG{k}{PRIMARY} \PYG{k}{KEY} \PYG{p}{(}\PYG{n}{id}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here’s what our final table looks like visualized in QGIS:

\noindent\sphinxincludegraphics{{adv_geom_6}.png}

As usual, there are some problems with our simple understanding of the data:
\begin{itemize}
\item {} 
there are actually two ‘S’ (short distance “shuttle”) trains, one in Manhattan and one in the Rockaways, and we join them together because they are both called ‘S’;

\item {} 
the ‘4’ train (and a few others) splits at the end of one line into two terminuses, so the “follow one line” assumption breaks and the result has a funny hook on the end.

\end{itemize}

Hopefully this example has provided a taste of some of the complex data manipulations that are possible combining the advanced features of PostgreSQL and PostGIS.


\subsection{See Also}
\label{\detokenize{advanced:id12}}\begin{itemize}
\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/arrays.html}{PostgreSQL Arrays}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/functions-array.html}{PostgreSQL Array Functions}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/queries-with.html}{PostgreSQL Recursive Common TABLE Expressions}

\item {} 
\sphinxhref{http://postgis.net/docs/ST\_MakeLine.html}{PostGIS ST\_MakeLine}

\end{itemize}


\chapter{Maintenance}
\label{\detokenize{maintenance:maintenance}}\label{\detokenize{maintenance::doc}}

\section{PostgreSQL Security}
\label{\detokenize{maintenance:postgresql-security}}\label{\detokenize{maintenance:security}}

\subsection{Authentication}
\label{\detokenize{maintenance:authentication}}
PostgreSQL supports many different \sphinxhref{http://www.postgresql.org/docs/current/static/auth-methods.html}{authentication methods}, to allow easy integration into existing enterprise architectures. For production purposes, the following methods are commonly used:
\begin{itemize}
\item {} 
\sphinxstylestrong{Password} is the basic system where the passwords are stored by the database, with MD5 encryption.

\item {} 
\sphinxhref{http://en.wikipedia.org/wiki/Kerberos\_(protocol)}{Kerberos} is a standard enterprise authentication method, which is used by both the \sphinxhref{\textless{}http://en.wikipedia.org/wiki/Generic\_Security\_Services\_Application\_Program\_Interface\textgreater{}}{GSSAPI} and \sphinxhref{http://msdn.microsoft.com/en-us/library/windows/desktop/aa380493(v=vs.85).aspx}{SSPI} schemes in PostgreSQL. Using \sphinxhref{http://msdn.microsoft.com/en-us/library/windows/desktop/aa380493(v=vs.85).aspx}{SSPI}, PostgreSQL can authenticate against Windows servers.

\item {} 
\sphinxhref{http://en.wikipedia.org/wiki/Lightweight\_Directory\_Access\_Protocol}{LDAP} is another common enterprise authentication method. The \sphinxhref{http://www.openldap.org/}{OpenLDAP} server bundled with most Linux distributions provides an open source implementation of \sphinxhref{http://en.wikipedia.org/wiki/Lightweight\_Directory\_Access\_Protocol}{LDAP}.

\item {} 
\sphinxstylestrong{Certificate} authentication is an option if you expect all client connections to be via SSL and are able to manage the distribution of keys.

\item {} 
\sphinxhref{http://en.wikipedia.org/wiki/Pluggable\_authentication\_module}{PAM} authentication is an option if you are on Linux or Solaris and use the \sphinxhref{http://en.wikipedia.org/wiki/Pluggable\_authentication\_module}{PAM} scheme for transparent authentication provision.

\end{itemize}

Authentication methods are controlled by the \sphinxcode{\sphinxupquote{pg\_hba.conf}} file. The “HBA” in the file name stands for “host based access”, because in addition to allowing you to specify the authentication method to use for each database, it allows you to limit host access using network addresses.

Here is an example \sphinxcode{\sphinxupquote{pg\_hba.conf}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TYPE  DATABASE    USER        CIDR\PYGZhy{}ADDRESS          METHOD}

\PYG{c+c1}{\PYGZsh{} \PYGZdq{}local\PYGZdq{} is for Unix domain socket connections only}
\PYG{n}{local}   \PYG{n+nb}{all}         \PYG{n+nb}{all}                               \PYG{n}{trust}
\PYG{c+c1}{\PYGZsh{} IPv4 local connections:}
\PYG{n}{host}    \PYG{n+nb}{all}         \PYG{n+nb}{all}         \PYG{l+m+mf}{127.0}\PYG{o}{.}\PYG{l+m+mf}{0.1}\PYG{o}{/}\PYG{l+m+mi}{32}          \PYG{n}{trust}
\PYG{c+c1}{\PYGZsh{} IPv6 local connections:}
\PYG{n}{host}    \PYG{n+nb}{all}         \PYG{n+nb}{all}         \PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{128}               \PYG{n}{trust}
\PYG{c+c1}{\PYGZsh{} remote connections for nyc database only}
\PYG{n}{host}    \PYG{n}{nyc}         \PYG{n+nb}{all}         \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{l+m+mi}{2}         \PYG{n}{ldap}
\end{sphinxVerbatim}

The file consists of five columns
\begin{itemize}
\item {} 
\sphinxstylestrong{TYPE} determines the kind of access, either “local” for connections from the same server or “host” for remote connections.

\item {} 
\sphinxstylestrong{DATABASE} specifies what database the configuration line refers to or “all” for all databases

\item {} 
\sphinxstylestrong{USER} specifies what users the line refers to or “all” for all users

\item {} 
\sphinxstylestrong{CIDR-ADDRESS} specifies the network limitations for remote connections, using network/netmask syntax

\item {} 
\sphinxstylestrong{METHOD} specifies the authentication protocol to use. “trust” skips authentication entirely and simply accepts any valid username without challenge. Other options are: “reject” which rejects the connection, “md5” which requires an md5 encrypted password, “password” which requires an unencrypted password, “gss” which uses GSSAPI to authenticate the user, “sspi” which uses SSPI to authenticate the user (only for Windows), “ident”, “peer” which obtains the client’s operating system user name from the operating system and check if it matches the requested database user name (for local connections), “ldap”, “radius”, “cert”, “pam”, and “bsd”. See the \sphinxhref{https://www.postgresql.org/docs/11/auth-pg-hba-conf.html}{pg\_hba.conf documentation for more info}.

\end{itemize}

It’s common for local connections to be trusted, since access to the server itself is usually privileged. Remote connections are disabled by default when PostgreSQL is installed: if you want to connect from remote machines, you’ll have to add an entry.

The line for \sphinxcode{\sphinxupquote{nyc}} in the example above is an example of a remote access entry. The \sphinxcode{\sphinxupquote{nyc}} example allows LDAP authenticated access only to machines on the local network (in this case the 192.168.1. network) and only to the nyc database. Depending on the security of your network, you will use more or less strict versions of these rules in your production set-up.


\subsection{Authorization}
\label{\detokenize{maintenance:authorization}}
PostgreSQL has a rich and flexible permissions system, with the ability to parcel out particular privileges to particular \sphinxhref{http://www.postgresql.org/docs/current/static/user-manag.html}{roles}, and provide users with the powers of one or more of those \sphinxhref{http://www.postgresql.org/docs/current/static/user-manag.html}{roles}.

In addition, the PostgreSQL server can use multiple different systems to authenticate users. This means that the database can use the same authentication infrastructure as other architecture components, simplifying password management.


\subsection{Users and Roles}
\label{\detokenize{maintenance:users-and-roles}}
In this chapter we will create two useful production users:
\begin{itemize}
\item {} 
A read-only user for use in a publishing application.

\item {} 
A read/write user for use by a developer in building a software or analyzing data.

\end{itemize}

Rather than creating users and granting them the necessary powers, we will create two roles with the right powers and then create two users and add them to the appropriate roles. That way we can easily reuse the roles when we create further users.


\subsubsection{Creating Roles}
\label{\detokenize{maintenance:creating-roles}}
A role is a user and a user is a role. The only difference is that a “user” can be said to be a role with the “login” privilege.

So functionally, the two SQL statements below are the same, they both create a “role with the login privilege”, which is to say, a “user”.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{ROLE} \PYG{n}{mrbean} \PYG{n}{LOGIN}\PYG{p}{;}
\PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{mrbean}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Read-only Users}
\label{\detokenize{maintenance:read-only-users}}
Our read-only user will be for a web application to use to query the \sphinxcode{\sphinxupquote{nyc\_streets}} table.

The application will have specific access to the \sphinxcode{\sphinxupquote{nyc\_streets}} table, but will also inherit the necessary system access for PostGIS operations from the \sphinxcode{\sphinxupquote{postgis\_reader}} role.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A user account for the web app}
\PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{app1}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Web app needs access to specific data tables}
\PYG{k}{GRANT} \PYG{k}{SELECT} \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{TO} \PYG{n}{app1}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A generic role for access to PostGIS functionality}
\PYG{k}{CREATE} \PYG{k}{ROLE} \PYG{n}{postgis\PYGZus{}reader} \PYG{n}{INHERIT}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Give that role to the web app}
\PYG{k}{GRANT} \PYG{n}{postgis\PYGZus{}reader} \PYG{k}{TO} \PYG{n}{app1}\PYG{p}{;}
\end{sphinxVerbatim}

Now, use the psql command line to login as as app1:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psql} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{nyc} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{n}{app1}
\end{sphinxVerbatim}
\end{quote}

Try the following queries:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} This works!}
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} This works too!}
\PYG{k}{SELECT} \PYG{n}{ST\PYGZus{}AsText}\PYG{p}{(}\PYG{n}{ST\PYGZus{}Transform}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{4326}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{FROM} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{INHERIT}} clause granted postgis\_reader with the privilegedges that all the roles in the database have. Now we have a nice generic \sphinxcode{\sphinxupquote{postgis\_reader}} role we can apply to any user that need to read from PostGIS tables.


\subsubsection{Read/write Users}
\label{\detokenize{maintenance:read-write-users}}
There are two kinds of read/write scenarios we need to consider:
\begin{itemize}
\item {} 
Web applications and others that need to write to existing data tables.

\item {} 
Developers or analysts that need to create new tables and geometry columns as part of their work.

\end{itemize}

For web applications that require write access to data tables, we just need to grant extra permissions to the tables themselves, and we can continue to use the \sphinxcode{\sphinxupquote{postgis\_reader}} role.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Add insert/update/delete abilities to our web application}
\PYG{k}{GRANT} \PYG{k}{INSERT}\PYG{p}{,}\PYG{k}{UPDATE}\PYG{p}{,}\PYG{k}{DELETE} \PYG{k}{ON} \PYG{n}{nyc\PYGZus{}streets} \PYG{k}{TO} \PYG{n}{app1}\PYG{p}{;}
\end{sphinxVerbatim}

These kinds of permissions would be required for a read/write WFS service, for example.

For developers and analysts, a little more access is needed to the main PostGIS metadata tables.  We will need a \sphinxcode{\sphinxupquote{postgis\_writer}} role that can edit the PostGIS metadata tables!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Make a postgis writer role}
\PYG{k}{CREATE} \PYG{k}{ROLE} \PYG{n}{postgis\PYGZus{}writer}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Start by giving it the postgis\PYGZus{}reader powers}
\PYG{k}{GRANT} \PYG{n}{postgis\PYGZus{}reader} \PYG{k}{TO} \PYG{n}{postgis\PYGZus{}writer}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Add insert/update/delete powers for the PostGIS tables}
\PYG{k}{GRANT} \PYG{k}{INSERT}\PYG{p}{,}\PYG{k}{UPDATE}\PYG{p}{,}\PYG{k}{DELETE} \PYG{k}{ON} \PYG{n}{spatial\PYGZus{}ref\PYGZus{}sys} \PYG{k}{TO} \PYG{n}{postgis\PYGZus{}writer}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Make app1 a PostGIS writer to see if it works!}
\PYG{k}{GRANT} \PYG{n}{postgis\PYGZus{}writer} \PYG{k}{TO} \PYG{n}{app1}\PYG{p}{;}
\end{sphinxVerbatim}

Now try the table creation SQL above as the app1 user and see how it goes!


\subsection{Encryption}
\label{\detokenize{maintenance:encryption}}
PostgreSQL provides a lot of \sphinxhref{http://www.postgresql.org/docs/current/static/encryption-options.html}{encryption facilities}, many of them optional, some of them on by default.
\begin{itemize}
\item {} 
By default, all passwords are MD5 encrypted. The client/server handshake double encrypts the MD5 password to prevent re-use of the hash by anyone who intercepts the password. It is also possible to use SCRAM which is an Internet standard.

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/libpq-ssl.html}{SSL connections} are optionally available between the client and server, to encrypt all data and login information. SSL certificate authentication is also available when SSL connections are used.

\item {} 
Columns inside the database can be encrypted using the \sphinxhref{http://www.postgresql.org/docs/current/static/pgcrypto.html}{pgcrypto} module, which includes hashing algorithms, direct ciphers (blowfish, aes) and both public key and symmetric PGP encryption.

\end{itemize}


\subsubsection{SSL Connections}
\label{\detokenize{maintenance:id1}}
In order to use SSL connections, both your client and server must support SSL. Your version of PostgreSQL may have SSL support built, but not enabled. If so, we have to carry out a few steps to turn it on first.
\begin{itemize}
\item {} 
First, turn shut down PostgreSQL, since activating SSL will require a restart.

\item {} 
Next, we acquire or generate an SSL certificate and key. The certificate will need to have no passphrase on it, or the database server won’t be able to start up. You can generate a self-signed key as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a new certificate, filling out the certification info as prompted}
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{req}

\PYG{c+c1}{\PYGZsh{} Strip the passphrase from the certificate}
\PYG{n}{openssl} \PYG{n}{rsa} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{privkey}\PYG{o}{.}\PYG{n}{pem} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}

\PYG{c+c1}{\PYGZsh{} Convert the certificate into a self\PYGZhy{}signed cert}
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}

\PYG{c+c1}{\PYGZsh{} Set the permission of the key to private read/write}
\PYG{n}{chmod} \PYG{n}{og}\PYG{o}{\PYGZhy{}}\PYG{n}{rwx} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}
\end{sphinxVerbatim}

\item {} 
Copy the \sphinxcode{\sphinxupquote{server.crt}} and \sphinxcode{\sphinxupquote{server.key}} into the PostgreSQL data directory.

\item {} 
Enable SSL support in the \sphinxcode{\sphinxupquote{postgresql.conf}} file by turning the “ssl” parameter to “on”.

\noindent\sphinxincludegraphics{{ssl_conf}.jpg}

\item {} 
Now re-start PostgreSQL. The server is now ready for SSL operation.

\end{itemize}

With the server enabled for SSL, creating an encrypted connection is easy. In PgAdmin, create a new server connection (File \textgreater{} Add Server…), and set the SSL parameter to “require”.

\noindent\sphinxincludegraphics{{ssl_create}.jpg}

Once you connect with the new connection, you can see in its properties that it is using an SSL connection.

\noindent\sphinxincludegraphics{{ssl_props}.jpg}

Since the default SSL connection mode is “prefer”, you don’t even need to specify an SSL preference when connecting. A connection with the command line \sphinxcode{\sphinxupquote{psql}} terminal will pick up the SSL option and use it by default:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psql} \PYG{p}{(}\PYG{l+m+mf}{8.4}\PYG{o}{.}\PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{SSL} \PYG{n}{connection} \PYG{p}{(}\PYG{n}{cipher}\PYG{p}{:} \PYG{n}{DHE}\PYG{o}{\PYGZhy{}}\PYG{n}{RSA}\PYG{o}{\PYGZhy{}}\PYG{n}{AES256}\PYG{o}{\PYGZhy{}}\PYG{n}{SHA}\PYG{p}{,} \PYG{n}{bits}\PYG{p}{:} \PYG{l+m+mi}{256}\PYG{p}{)}
\PYG{n}{Type} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{help}\PYG{l+s+s2}{\PYGZdq{}} \PYG{k}{for} \PYG{n}{help}\PYG{o}{.}

\PYG{n}{postgres}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{}}
\end{sphinxVerbatim}

Note how the terminal reports the SSL status of the connection.


\subsubsection{Data Encryption}
\label{\detokenize{maintenance:data-encryption}}
The \sphinxhref{http://www.postgresql.org/docs/current/static/pgcrypto.html}{pgcrypto} module has a huge range of encryption options, so we will only demonstrate the simplest use case: encrypting a column of data using a symmetric cipher.
\begin{itemize}
\item {} 
First, enable pgcrypto by creating the EXTENSION, either in PgAdmin or psql.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{n}{EXTENSION} \PYG{k}{IF} \PYG{k}{NOT} \PYG{k}{EXISTS} \PYG{n}{pgcrypto}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Then, test the encryption function. The first parameter is the \sphinxstylestrong{data to encrypt}, the second is the user selected \sphinxstylestrong{cipher key}, and the third is the \sphinxstylestrong{algorithm} used to encrypt which in this case \sphinxstyleemphasis{bf} stands for \sphinxstyleemphasis{blowfish}, another option for this is \sphinxstyleemphasis{aes} which stands for \sphinxstyleemphasis{AES (Rijndael-128)}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} encrypt a string using blowfish (bf)}
\PYG{k}{SELECT} \PYG{n}{encrypt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}this is a test phrase\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}mykey\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bf\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
And make sure it’s reversible too!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} round\PYGZhy{}trip a string using blowfish (bf)}
\PYG{k}{SELECT} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{encrypt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}this is a test phrase\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}mykey\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bf\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}mykey\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bf\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{Links}
\label{\detokenize{maintenance:links}}\begin{itemize}
\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/auth-methods.html}{PostgreSQL Authentication}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/encryption-options.html}{PostgreSQL Encrpyption}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/libpq-ssl.html}{PostgreSQL SSL Support}

\end{itemize}


\section{PostgreSQL Schemas}
\label{\detokenize{maintenance:postgresql-schemas}}\label{\detokenize{maintenance:schemas}}
Production databases inevitably have a large number of tables and views, and managing them all in one schema can become unwieldy quickly. Fortunately, \sphinxhref{http://www.postgresql.org/}{PostgreSQL} includes the concept of a “\_Schema”.

Schemas are like folders, and can hold tables, views, functions, sequences and other relations.  Every database starts out with one schema, the \sphinxcode{\sphinxupquote{public}} schema.

\noindent\sphinxincludegraphics{{schemas}.jpg}

Inside that schema, the default install of PostGIS creates the \sphinxcode{\sphinxupquote{geometry\_columns}}, \sphinxcode{\sphinxupquote{geography\_columns}} and \sphinxcode{\sphinxupquote{spatial\_ref\_sys}} metadata relations, as well as all the types and functions used by PostGIS. So users of PostGIS always need access to the public schema.

In the public schema you can also see all the tables we have created so far in the course.


\subsection{Why use Schemas?}
\label{\detokenize{maintenance:why-use-schemas}}
There are two very good reasons for using schemas:
\begin{itemize}
\item {} 
Data that is managed in a schema is easier to apply bulk actions to.
\begin{itemize}
\item {} 
It’s easier to back-up data that’s in a separate schema: so volatile data can have a different back-up schedule from non-volatile data.

\item {} 
It’s easier to restore data that’s in a separate schema: so application-oriented schemas can be separately restored and backed up for time travel and recovery.

\item {} 
It’s easier to manage application differences when the application data is in a schema: so a new version of software can work off a table structure in a new schema, and cut-over involves a simple change to the schema name.

\end{itemize}

\item {} 
Users can be restricted in their work to single schemas to allow isolation of analytical and test tables from production tables.

\end{itemize}

So for production purposes, keeping your application data separate in schemas improves management; and for user purposes, keeping your users in separate schemas keeps them from treading on each other.


\subsection{Creating a Data Schema}
\label{\detokenize{maintenance:creating-a-data-schema}}
Let’s create a new schema and move a table into it.  First, create a new schema in the database:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{SCHEMA} \PYG{n}{census}\PYG{p}{;}
\end{sphinxVerbatim}

Next, we will move the \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} table to the \sphinxcode{\sphinxupquote{census}} schema:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER} \PYG{k}{TABLE} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{SET} \PYG{k}{SCHEMA} \PYG{n}{census}\PYG{p}{;}
\end{sphinxVerbatim}

If you’re using the \sphinxstyleliteralstrong{\sphinxupquote{psql}} command-line program, you’ll notice that \sphinxcode{\sphinxupquote{nyc\_census\_blocks}} has disappeared from your table listing now! If you’re using PgAdmin, you might have to refresh your view to see the new schema and the table inside it.

You can access tables inside schemas in two ways:
\begin{itemize}
\item {} 
by referencing them using \sphinxcode{\sphinxupquote{schema.table}} notation

\item {} 
by adding the schema to your \sphinxcode{\sphinxupquote{search\_path}}

\end{itemize}

Explicit referencing is easy, but it gets tiring to type after a while:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{census}\PYG{p}{.}\PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{k}{LIMIT} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}

Manipulating the \sphinxcode{\sphinxupquote{search\_path}} is a nice way to provide access to tables in multiple schemas without lots of extra typing.

You can set the \sphinxcode{\sphinxupquote{search\_path}} at run time using the \sphinxcode{\sphinxupquote{SET}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SET} \PYG{n}{search\PYGZus{}path} \PYG{o}{=} \PYG{n}{census}\PYG{p}{,} \PYG{k}{public}\PYG{p}{;}
\end{sphinxVerbatim}

This ensures that all references to relations and functions are searched in both the \sphinxcode{\sphinxupquote{census}} and the \sphinxcode{\sphinxupquote{public}} schemas. Remember that all the PostGIS functions and types are in \sphinxcode{\sphinxupquote{public}} so we don’t want to drop that from the search path.

Setting the search path every time you connect can get tiring too, but fortunately it’s possible to permanently set the search path for a user:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER} \PYG{k}{USER} \PYG{n}{postgres} \PYG{k}{SET} \PYG{n}{search\PYGZus{}path} \PYG{o}{=} \PYG{n}{census}\PYG{p}{,} \PYG{k}{public}\PYG{p}{;}
\end{sphinxVerbatim}

Now the postgres user will always have the \sphinxcode{\sphinxupquote{census}} schema in their search path.


\subsection{Creating a User Schema}
\label{\detokenize{maintenance:creating-a-user-schema}}
Users like to create tables, and PostGIS users do so particularly: analysis operations with SQL demand temporary tables for visualization or interim results, so spatial SQL tends to require that users have CREATE privileges more than ordinary database workloads.

By default, every role in Oracle is given a personal schema. This is a nice practice to use for PostgreSQL users too, and is easy to replicate using PostgreSQL roles, schemas, and search paths.

Create a new user with table creation privileges (see \DUrole{xref,std,std-ref}{security} for information about the \sphinxcode{\sphinxupquote{postgis\_writer}} role), then create a schema with that user as the authorization:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{myuser} \PYG{k}{WITH} \PYG{k}{ROLE} \PYG{n}{postgis\PYGZus{}writer}\PYG{p}{;}
\PYG{k}{CREATE} \PYG{k}{SCHEMA} \PYG{n}{myuser} \PYG{k}{AUTHORIZATION} \PYG{n}{myuser}\PYG{p}{;}
\end{sphinxVerbatim}

If you log in as that user, you’ll find the default \sphinxcode{\sphinxupquote{search\_path}} for PostgreSQL is actually this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{show} \PYG{n}{search\PYGZus{}path}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n}{search\PYGZus{}path}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}user}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{public}
\end{sphinxVerbatim}

The first schema on the search path us the user’s named schema! So now the following conditions exist:
\begin{itemize}
\item {} 
The user exists, with the ability to create spatial tables.

\item {} 
The user’s named schema exists, and the user owns it.

\item {} 
The user’s search path has the user schema first, so new tables are automatically created there, and queries automatically search there first.

\end{itemize}

That’s all there is to it, the user’s default work area is now nicely separated from any tables in other schemas.


\section{PostgreSQL Backup and Restore}
\label{\detokenize{maintenance:postgresql-backup-and-restore}}\label{\detokenize{maintenance:backup}}
There are lots of ways to backup a PostgreSQL database, and the one you choose will depend a great deal on how you are using the database.
\begin{itemize}
\item {} 
For relatively static databases, the basic pg\_dump/pg\_restore tools can be used to take periodic snapshots of the data.

\item {} 
For frequently changing data, using an “online backup” scheme allows continuous archiving of updates to a secure location.

\end{itemize}

Online backup is the basis for replication and stand-by systems for \sphinxhref{http://www.postgresql.org/docs/current/static/high-availability.html}{high availability}, particularly for versions of PostgreSQL \textgreater{}= 9.0.


\subsection{Laying Out your Data}
\label{\detokenize{maintenance:laying-out-your-data}}
As discussed in \DUrole{xref,std,std-ref}{schemas}, ensuring that production data is always stored in separate schemas is a very important \sphinxstylestrong{best practice} in managing data. There are two reasons:
\begin{itemize}
\item {} 
Backing up and restoring data in schemas is much simpler than managing lists of tables to be backed up individually.

\item {} 
Keeping data tables out of the “public” schema allows far easier upgrades, as discussed in \DUrole{xref,std,std-ref}{upgrades}.

\end{itemize}


\subsection{Basic Backup and Restore}
\label{\detokenize{maintenance:basic-backup-and-restore}}
Backing up a full database is easy using the \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump} utility. The utility is a command-line tool, which makes it easy to automate with scripting, and it can also be invoke via a GUI in the PgAdmin utility.

To backup our \sphinxcode{\sphinxupquote{nyc}} database, we can use the GUI, just right-click the database you want to backup:

\noindent\sphinxincludegraphics{{backup1}.jpg}

Enter the name of the backup file you want to create.

\noindent\sphinxincludegraphics{{backup2}.jpg}

Note that there are three backup format options: compress, tar and plain.
\begin{itemize}
\item {} 
\sphinxstylestrong{Plain} is just a textual SQL file. This is the simplest format and in many ways the most flexible, since it can be editing or altered easily and then loaded back into a database, allowing offline changes to things like ownership or other global information.

\item {} 
\sphinxstylestrong{Tar} using a UNIX archive format to hold components of the dump in separate files. Using the tar format allows the \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgrestore.html}{pg\_restore} utility to selectively restore parts of the dump.

\item {} 
\sphinxstylestrong{Compress} is like the Tar format, but compresses the internal components individually, allowing them to be selectively restored without decompressing the entire archive.

\end{itemize}

We’ll check the Compress option and go, saving out a backup file.

The same operation can be done with the command line like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}dump} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{=}\PYG{n}{nyc}\PYG{o}{.}\PYG{n}{backup} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{format}\PYG{o}{=}\PYG{n}{c} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{username}\PYG{o}{=}\PYG{n}{postgres} \PYG{n}{nyc}
\end{sphinxVerbatim}

Because the backup file is in Compress format, we can view the contents using the \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgrestore.html}{pg\_restore} command to list the manifest. In the PgAdmin GUI, “View” is an option in the panel.

\noindent\sphinxincludegraphics{{backup3}.jpg}

When you look at the manifest, one of the things you might notice is that there are a lot of “FUNCTION” signatures in there.

\noindent\sphinxincludegraphics{{backup4}.jpg}

That’s because the \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump} utility dumps \sphinxstylestrong{every} non-system object in the database, and that includes the PostGIS function definitions.

\begin{sphinxadmonition}{note}{Note:}
PostgreSQL 9.1+ includes an “EXTENSION” feature that allows add-on packages like PostGIS to be installed as registered system components and therefore excluded from \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump} output. PostGIS 2.0 and higher support installation using this extension system.
\end{sphinxadmonition}

We can see the same manifest from the command-line using \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgrestore.html}{pg\_restore} directly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}restore} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{n}{nyc}\PYG{o}{.}\PYG{n}{backup}
\end{sphinxVerbatim}

The problem with a dump file full of PostGIS function signatures is that we really wanted a dump of our data, not our system functions.

Since every object is in the dump file, we can restore to a blank database and get full functionality. In doing so, we are expecting that system we are restoring to has exactly the same version of PostGIS as the one we dumped from (since the function signature definitions reference a particular version of the PostGIS shared library).

From the command-line the restore looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{createdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port} \PYG{l+m+mi}{54321} \PYG{n}{nyc2}
\PYG{n}{pg\PYGZus{}restore} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dbname}\PYG{o}{=}\PYG{n}{nyc2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port} \PYG{l+m+mi}{54321} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{username}\PYG{o}{=}\PYG{n}{postgres} \PYG{n}{nyc}\PYG{o}{.}\PYG{n}{backup}
\end{sphinxVerbatim}

Dumping just data, without function signatures, is where having data in schemas is handy, because there is a command-line flag to only dump a particular schema:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}dump} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{format}\PYG{o}{=}\PYG{n}{c} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{schema}\PYG{o}{=}\PYG{n}{census} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{=}\PYG{n}{census}\PYG{o}{.}\PYG{n}{backup}
\end{sphinxVerbatim}

Now when we list the contents of the dump, we see just the data tables we wanted:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}restore} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list} \PYG{n}{census}\PYG{o}{.}\PYG{n}{backup}

\PYG{p}{;}
\PYG{p}{;} \PYG{n}{Archive} \PYG{n}{created} \PYG{n}{at} \PYG{n}{Thu} \PYG{n}{Aug}  \PYG{l+m+mi}{9} \PYG{l+m+mi}{11}\PYG{p}{:}\PYG{l+m+mi}{02}\PYG{p}{:}\PYG{l+m+mi}{49} \PYG{l+m+mi}{2012}
\PYG{p}{;}     \PYG{n}{dbname}\PYG{p}{:} \PYG{n}{nyc}
\PYG{p}{;}     \PYG{n}{TOC} \PYG{n}{Entries}\PYG{p}{:} \PYG{l+m+mi}{11}
\PYG{p}{;}     \PYG{n}{Compression}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{p}{;}     \PYG{n}{Dump} \PYG{n}{Version}\PYG{p}{:} \PYG{l+m+mf}{1.11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0}
\PYG{p}{;}     \PYG{n}{Format}\PYG{p}{:} \PYG{n}{CUSTOM}
\PYG{p}{;}     \PYG{n}{Integer}\PYG{p}{:} \PYG{l+m+mi}{4} \PYG{n+nb}{bytes}
\PYG{p}{;}     \PYG{n}{Offset}\PYG{p}{:} \PYG{l+m+mi}{8} \PYG{n+nb}{bytes}
\PYG{p}{;}     \PYG{n}{Dumped} \PYG{k+kn}{from} \PYG{n+nn}{database} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mf}{8.4}\PYG{o}{.}\PYG{l+m+mi}{9}
\PYG{p}{;}     \PYG{n}{Dumped} \PYG{n}{by} \PYG{n}{pg\PYGZus{}dump} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mf}{8.4}\PYG{o}{.}\PYG{l+m+mi}{9}
\PYG{p}{;}
\PYG{p}{;}
\PYG{p}{;} \PYG{n}{Selected} \PYG{n}{TOC} \PYG{n}{Entries}\PYG{p}{:}
\PYG{p}{;}
\PYG{l+m+mi}{6}\PYG{p}{;} \PYG{l+m+mi}{2615} \PYG{l+m+mi}{20091} \PYG{n}{SCHEMA} \PYG{o}{\PYGZhy{}} \PYG{n}{census} \PYG{n}{postgres}
\PYG{l+m+mi}{146}\PYG{p}{;} \PYG{l+m+mi}{1259} \PYG{l+m+mi}{19845} \PYG{n}{TABLE} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{postgres}
\PYG{l+m+mi}{145}\PYG{p}{;} \PYG{l+m+mi}{1259} \PYG{l+m+mi}{19843} \PYG{n}{SEQUENCE} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}gid\PYGZus{}seq} \PYG{n}{postgres}
\PYG{l+m+mi}{2691}\PYG{p}{;} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{SEQUENCE} \PYG{n}{OWNED} \PYG{n}{BY} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}gid\PYGZus{}seq} \PYG{n}{postgres}
\PYG{l+m+mi}{2692}\PYG{p}{;} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{SEQUENCE} \PYG{n}{SET} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}gid\PYGZus{}seq} \PYG{n}{postgres}
\PYG{l+m+mi}{2681}\PYG{p}{;} \PYG{l+m+mi}{2604} \PYG{l+m+mi}{19848} \PYG{n}{DEFAULT} \PYG{n}{census} \PYG{n}{gid} \PYG{n}{postgres}
\PYG{l+m+mi}{2688}\PYG{p}{;} \PYG{l+m+mi}{0} \PYG{l+m+mi}{19845} \PYG{n}{TABLE} \PYG{n}{DATA} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks} \PYG{n}{postgres}
\PYG{l+m+mi}{2686}\PYG{p}{;} \PYG{l+m+mi}{2606} \PYG{l+m+mi}{19853} \PYG{n}{CONSTRAINT} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}pkey} \PYG{n}{postgres}
\PYG{l+m+mi}{2687}\PYG{p}{;} \PYG{l+m+mi}{1259} \PYG{l+m+mi}{20078} \PYG{n}{INDEX} \PYG{n}{census} \PYG{n}{nyc\PYGZus{}census\PYGZus{}blocks\PYGZus{}geom\PYGZus{}gist} \PYG{n}{postgres}
\end{sphinxVerbatim}

Having just the data tables is handy, because it means we can store to a database with any version of PostGIS installed, as we talk about in \DUrole{xref,std,std-ref}{upgrades}.


\subsubsection{Backing Up Users}
\label{\detokenize{maintenance:backing-up-users}}
The \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump} utility operates a database at a time (or a schema or table at a time, if you restrict it). However, information about users is is stored across an entire cluster, it’s not stored in any one database!

To backup your user information, use the \sphinxhref{http://www.postgresql.org/docs/current/static/app-pg-dumpall.html}{pg\_dumpall} utility, with the “\textendash{}globals-only” flag.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}dumpall} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{globals}\PYG{o}{\PYGZhy{}}\PYG{n}{only} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port} \PYG{l+m+mi}{54321}
\end{sphinxVerbatim}

You can also use \sphinxhref{http://www.postgresql.org/docs/current/static/app-pg-dumpall.html}{pg\_dumpall} in its default mode to backup an entire cluster, but be aware that, as with \sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump}, you will end up backing up the PostGIS function signatures, so the dump will have to be restored against an identical software installation, it can’t be used as part of an upgrade process.


\subsection{Online Backup and Restore}
\label{\detokenize{maintenance:online-backup-and-restore}}
Online backup and restore allows an administrator to keep an extremely up-to-date set of backup files without the overhead of repeatedly dumping the entire database. If the database is under frequent insert and update load, then online backup might be preferable to basic backup.

\begin{sphinxadmonition}{note}{Note:}
The best way to learn about online backup is to read the relevant sections of the PostgreSQL manual on \sphinxhref{http://www.postgresql.org/docs/current/static/continuous-archiving.html}{continuous archiving and point-in-time recovery}. This section of the PostGIS course will just provide a brief snapshot of online backup set-up.
\end{sphinxadmonition}


\subsubsection{How it Works}
\label{\detokenize{maintenance:how-it-works}}
Rather than continually write to the main data tables, PostgreSQL stores changes initially in “write-ahead logs” (WAL). Taken together, these logs are a complete record of all changes made to a database.  Online backup consists of taking a copy of the database main data table, then taking a copy of each WAL that is generated from then on.

\noindent\sphinxincludegraphics{{backup5}.jpg}

When it is time to recover to a new database, the system starts on the main data copy, then replays all the WAL files into the database. The end result is a restored database in the same state as the original at the time of the last WAL received.

Because WAL are being written anyways, and transferring copies to an archive server is computationally cheap, online backup is an effective means of keeping a very up-to-date backup of a system without resorting to intensive regular full dumps.


\subsubsection{Archiving the WAL Files}
\label{\detokenize{maintenance:archiving-the-wal-files}}
The first thing to do in setting up online backup is to create an archiving method. PostgreSQL archiving methods are the ultimate in flexibility: the PostgreSQL backend simply calls a script specified in the \sphinxcode{\sphinxupquote{archive\_command}} configuration parameter.

That means archiving can be as simple as copying the file to a network-mounted drive, and as complex as encrypting and emailing the files to the remote archive. Any process you can script you can use to archive the files.

To turn on archiving we will edit \sphinxcode{\sphinxupquote{postgresql.conf}}, first turning on WAL archiving:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{wal\PYGZus{}level} \PYG{o}{=} \PYG{n}{archive}
\PYG{n}{archive\PYGZus{}mode} \PYG{o}{=} \PYG{n}{on}
\end{sphinxVerbatim}

And then setting the \sphinxcode{\sphinxupquote{archive\_command}} to copy our archive files to a safe location (changing the destination paths as appropriate):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Unix}
\PYG{n}{archive\PYGZus{}command} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test ! \PYGZhy{}f /archivedir/}\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s+s1}{ \PYGZam{}\PYGZam{} cp }\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{p /archivedir/}\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Windows}
\PYG{n}{archive\PYGZus{}command} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{copy }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{archivedir}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

It is important that the archive command not over-write existing files, so the unix command includes an initial test to ensure that the files aren’t already there. It is also important that the command returns a non-zero status if the copy process fails.

Once the changes are made you can re-start PostgreSQL to make them effective.


\subsubsection{Taking the Base Backup}
\label{\detokenize{maintenance:taking-the-base-backup}}
Once the archiving process is in place, you need to take a base back-up.

Put the database into backup mode (this doesn’t do anything to alter operation of queries or data updates, it just forces a checkpoint and writes a label file indicating when the backup was taken).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{pg\PYGZus{}start\PYGZus{}backup}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}/archivedir/basebackup.tgz\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For the label, using the path to the backup file is a good practice, as it helps you track down where the backup was stored.

Copy the database to an archival location:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} Unix
tar cvfz /archivedir/basebackup.tgz \PYGZdl{}\PYGZob{}PGDATA\PYGZcb{}
\end{sphinxVerbatim}

Then tell the database the backup process is complete.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{pg\PYGZus{}stop\PYGZus{}backup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All these steps can of course be scripted for regular base backups.


\subsubsection{Restoring from the Archive}
\label{\detokenize{maintenance:restoring-from-the-archive}}
These steps are taking from the PostgreSQL manual on \sphinxhref{http://www.postgresql.org/docs/current/static/continuous-archiving.html}{continuous archiving and point-in-time recovery}.
\begin{itemize}
\item {} 
Stop the server, if it’s running.

\item {} 
If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster’s pg\_xlog subdirectory, as it might contain logs which were not archived before the system went down.

\item {} 
Remove all existing files and subdirectories under the cluster data directory and under the root directories of any tablespaces you are using.

\item {} 
Restore the database files from your file system backup. Be sure that they are restored with the right ownership (the database system user, not root!) and with the right permissions. If you are using tablespaces, you should verify that the symbolic links in pg\_tblspc/ were correctly restored.

\item {} 
Remove any files present in pg\_xlog/; these came from the file system backup and are therefore probably obsolete rather than current. If you didn’t archive pg\_xlog/ at all, then recreate it with proper permissions, being careful to ensure that you re-establish it as a symbolic link if you had it set up that way before.

\item {} 
If you have unarchived WAL segment files that you saved in step 2, copy them into pg\_xlog/. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)

\item {} 
Create a recovery command file recovery.conf in the cluster data directory (see Chapter 26). You might also want to temporarily modify pg\_hba.conf to prevent ordinary users from connecting until you are sure the recovery was successful.

\item {} 
Start the server. The server will go into recovery mode and proceed to read through the archived WAL files it needs. Should the recovery be terminated because of an external error, the server can simply be restarted and it will continue recovery. Upon completion of the recovery process, the server will rename recovery.conf to recovery.done (to prevent accidentally re-entering recovery mode later) and then commence normal database operations.

\item {} 
Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring pg\_hba.conf to normal.

\end{itemize}


\subsection{Links}
\label{\detokenize{maintenance:id3}}\begin{itemize}
\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/app-pgdump.html}{pg\_dump}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/app-pg-dumpall.html}{pg\_dumpall}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/app-pgrestore.html}{pg\_restore}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/high-availability.html}{PostgreSQL High Availability}

\item {} 
\sphinxhref{http://www.postgresql.org/docs/current/static/continuous-archiving.html}{PostgreSQL High Availability Continuous Archiving and PITR}

\end{itemize}


\section{Tuning PostgreSQL for Spatial}
\label{\detokenize{maintenance:tuning-postgresql-for-spatial}}\label{\detokenize{maintenance:tuning}}
PostgreSQL is a very versatile database system, capable of running efficiently in very low-resource environments and environments shared with a variety of other applications.  In order to ensure it will run properly for many different environments, the default configuration is very conservative and not terribly appropriate for a high-performance production database.  Add the fact that geospatial databases have different usage patterns, and the data tend to consist of fewer, much larger records than non-geospatial databases, and you can see that the default configuration will not be totally appropriate for our purposes.

All of these configuration parameters can be edited in the \sphinxcode{\sphinxupquote{postgresql.conf}} configuration file. If using Mac with the postgres app installation, this is \sphinxcode{\sphinxupquote{/Users/may/Library/Application Support/Postgres/var-11/postgresql.conf}} This is a regular text file and can be edited using TextEdit or any other text editor.  The changes will not take effect until the server is restarted.

\noindent\sphinxincludegraphics{{conf01_mac}.png}

This section describes some of the configuration parameters that should be adjusted for a production-ready geospatial database.  For each section, find the appropriate item in the file, remove the comment symbol \sphinxstylestrong{\#} and change the \sphinxstyleemphasis{Value} to the recommended value as described, then after editing all values \sphinxstylestrong{Save} the file.

\begin{sphinxadmonition}{note}{Note:}
These values are recommendations only; each environment will differ and testing is required to determine the optimal configuration.  But this section should get you off to a good start.
\end{sphinxadmonition}


\subsection{shared\_buffers}
\label{\detokenize{maintenance:shared-buffers}}
Sets the amount of memory the database server uses for shared memory buffers.  These are shared amongst the back-end processes, as the name suggests.  The default values are typically woefully inadequate for production databases.
\begin{quote}

\sphinxstyleemphasis{Default value}: typically 128MB

\sphinxstyleemphasis{Recommended value}: 75\% of database memory (500MB)
\end{quote}

\noindent\sphinxincludegraphics{{shared_buffers}.png}


\subsection{work\_mem}
\label{\detokenize{maintenance:work-mem}}
Defines the amount of memory that internal sorting operations and hash tables can consume before the database switches to on-disk files.  This value defines the available memory for each operation; complex queries may have several sort or hash operations running in parallel, and each connected session may be executing a query.

As such you must consider how many connections and the complexity of expected queries before increasing this value.  The benefit to increasing is that the processing of more of these operations, including ORDER BY, and DISTINCT clauses, merge and hash joins, hash-based aggregation and hash-based processing of subqueries, can be accomplished without incurring disk writes.
\begin{quote}

\sphinxstyleemphasis{Default value}: 4MB

\sphinxstyleemphasis{Recommended value}: 16MB
\end{quote}

\noindent\sphinxincludegraphics{{work_mem}.png}


\subsection{maintenance\_work\_mem}
\label{\detokenize{maintenance:maintenance-work-mem}}
Defines the amount of memory used for maintenance operations, including vacuuming, index and foreign key creation.  As these operations are not terribly common, the default value may be acceptable.  This parameter can alternately be increased for a single session before the execution of a number of \sphinxstyleliteralstrong{\sphinxupquote{CREATE INDEX}} or \sphinxstyleliteralstrong{\sphinxupquote{VACUUM}} calls as shown below.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SET} \PYG{n}{maintenance\PYGZus{}work\PYGZus{}mem} \PYG{k}{TO} \PYG{l+s+s1}{\PYGZsq{}128MB\PYGZsq{}}\PYG{p}{;}
\PYG{k}{VACUUM} \PYG{k}{ANALYZE}\PYG{p}{;}
\PYG{k}{SET} \PYG{n}{maintenance\PYGZus{}work\PYGZus{}mem} \PYG{k}{TO} \PYG{l+s+s1}{\PYGZsq{}16MB\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Default value}: 64MB

\sphinxstyleemphasis{Recommended value}: 128MB
\end{quote}

\noindent\sphinxincludegraphics{{maintenance_work_mem}.png}


\subsection{random\_page\_cost}
\label{\detokenize{maintenance:random-page-cost}}
This is a unit-less value that represents the cost of a random page access from disk.  This value is relative to a number of other cost parameters including sequential page access, and CPU operation costs.  While there is no magic bullet for this value, the default is generally conservative.  This value can be set on a per-session basis using the \sphinxcode{\sphinxupquote{SET random\_page\_cost TO 2.0}} command.
\begin{quote}

\sphinxstyleemphasis{Default value}: 4.0

\sphinxstyleemphasis{Recommended value}: 2.0
\end{quote}

\noindent\sphinxincludegraphics{{random_page_cost}.png}


\subsection{seq\_page\_cost}
\label{\detokenize{maintenance:seq-page-cost}}
This is the parameter that controls the cost of a sequential page access.  This value does not generally require adjustment but the difference between this value and \sphinxcode{\sphinxupquote{random\_page\_cost}} greatly affects the choices made by the query planner.  This value can also be set on a per-session basis.
\begin{quote}

\sphinxstyleemphasis{Default value}: 1.0

\sphinxstyleemphasis{Recommended value}: 1.0
\end{quote}

\noindent\sphinxincludegraphics{{seq_page_cost}.png}


\subsection{Reload configuration}
\label{\detokenize{maintenance:reload-configuration}}
After these changes are made, save changes and reload the configuration. The easiest way to do this is to restart the PostgreSQL service.
\begin{itemize}
\item {} 
In pgAdmin, right-click the server \sphinxstylestrong{PostGIS (localhost:5432)} and select \sphinxstyleemphasis{Reload Configuration}.

\end{itemize}


\section{Software Upgrades}
\label{\detokenize{maintenance:software-upgrades}}\label{\detokenize{maintenance:upgrades}}
Because PostGIS resides within PostgreSQL every PostGIS installation actually consists of two versions of software: the PostgreSQL version and the PostGIS version.  As a general principle, each version of PostGIS can be theoretically run within a number of versions of PostgreSQL, and vice versa.

So, upgrades need to be considered in terms of upgrading each component.


\subsection{Upgrading PostgreSQL}
\label{\detokenize{maintenance:upgrading-postgresql}}
There are two kinds of PostgreSQL upgrade scenarios:
\begin{itemize}
\item {} 
A “minor upgrade” when the software version increases at the “patch” level. For example, from 8.4.3 to 8.4.4, or from 9.0.1 to 9.0.3. Increases of more than one patch version are just fine. Minor upgrades fix bugs but do not add any new features or change behaviour.

\item {} 
A “major upgrade” when the “major” or “minor” versions increase. For example, from 8.4.5 to 9.0.0, or from 9.0.5 to 9.1.1. Major upgrades add new features and change behavior.

\end{itemize}


\subsubsection{Minor PostgreSQL Upgrades}
\label{\detokenize{maintenance:minor-postgresql-upgrades}}
For “minor upgrades”, no special process is necessary. Simply install the new software, and re-start the server.


\subsubsection{Major PostgreSQL Upgrades}
\label{\detokenize{maintenance:major-postgresql-upgrades}}
For “major upgrades” there are two ways to carry out the upgrade.


\subsection{Dump/Restore}
\label{\detokenize{maintenance:dump-restore}}
Dumping and restoring involves converting all the data to a platform neutral format (text representations) on dump, and back to native representations on restore, so it can be time consuming and CPU intensive. However, if you are migrating to a new architecture or operating system, it’s a required process. It’s also a time-tested and well-understood upgrade path, so if your database is not too big, there’s no reason not to stick with it.
\begin{itemize}
\item {} 
Dump your data \sphinxcode{\sphinxupquote{pg\_dumpall}} from the old database.

\item {} 
Install the new version of PostgreSQL and the same version of PostGIS you are using in your old database. You need to match the PostGIS version so that the dump file function definitions reference an expected version of the PostGIS library.

\item {} 
Initialize the new data area using the \sphinxcode{\sphinxupquote{initdb}} program from the new software.

\item {} 
Start the new server on the new data area.

\item {} 
Restore the dump file using \sphinxcode{\sphinxupquote{pg\_restore}}.

\end{itemize}


\subsection{pg\_upgrade}
\label{\detokenize{maintenance:pg-upgrade}}
The \sphinxhref{http://www.postgresql.org/docs/current/static/pgupgrade.html}{pg\_upgrade} utility allows PostgreSQL data directories to be upgraded without the requirement for a dump/restore step. The utility cannot handle changes to the data files themselves, but handles the more common and frequent changes to system tables that occur in PostgreSQL major upgrades.

\begin{sphinxadmonition}{note}{Note:}
The full instructions for running the upgrade process are in the \sphinxhref{http://www.postgresql.org/docs/current/static/pgupgrade.html}{pg\_upgrade} web page at the PostgreSQL site.
\end{sphinxadmonition}

The \sphinxhref{http://www.postgresql.org/docs/current/static/pgupgrade.html}{pg\_upgrade} program expects to have access to both versions of PostgreSQL it is working with, the old and the new version, so you will have to install them both.
\begin{itemize}
\item {} 
Install the new version of PostgreSQL you will be using.

\item {} 
Install the same version of PostGIS you are using in the old PostgreSQL into the new PostgreSQL.

\item {} 
Initialize the new PostgreSQL data area with the new copy of \sphinxcode{\sphinxupquote{initdb}}.

\item {} 
Ensure both the old and new PostgreSQL servers are turned off.

\item {} 
Run \sphinxhref{http://www.postgresql.org/docs/current/static/pgupgrade.html}{pg\_upgrade}, making sure to use the binary from the new software installation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}upgrade}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{old}\PYG{o}{\PYGZhy{}}\PYG{n}{datadir} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:/Program Files/PostgreSQL/8.4/data}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{new}\PYG{o}{\PYGZhy{}}\PYG{n}{datadir} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:/Program Files/PostgreSQL/9.0/data}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{old}\PYG{o}{\PYGZhy{}}\PYG{n}{bindir} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:/Program Files/PostgreSQL/8.4/bin}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{new}\PYG{o}{\PYGZhy{}}\PYG{n}{bindir} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C:/Program Files/PostgreSQL/9.0/bin}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
If \sphinxhref{http://www.postgresql.org/docs/current/static/pgupgrade.html}{pg\_upgrade} generated any \sphinxcode{\sphinxupquote{.sql}} files, run them now.

\item {} 
Start the new server.

\end{itemize}


\subsection{Upgrading PostGIS}
\label{\detokenize{maintenance:upgrading-postgis}}
There are two upgrade scenarios for PostGIS too, but they are slightly different from the PostgreSQL scheme:

There are two kinds of PostGIS upgrade scenarios:
\begin{itemize}
\item {} 
A “minor or patch upgrade” is when the software version increases at the “patch” or “minor” level. For example, from 2.0.1 to 2.0.2, or from 2.0.2 to 2.1.0. Patch upgrades fix bugs only and do not add new features. Minor upgrades fix add new features or change behaviour.

\item {} 
A “major upgrade” is when the “major” version increases. This is extremely rare. For example, from 0.9.4 to 1.0.0, or from 1.5.4 to 2.0.0. Major upgrades change the on-disk storage format for geometries and require a full database dump and restore.

\end{itemize}


\subsubsection{Minor/Patch PostGIS Upgrades}
\label{\detokenize{maintenance:minor-patch-postgis-upgrades}}
PostGIS deals with minor and upgrades through the \sphinxcode{\sphinxupquote{EXTENSION}} mechanism. If you spatially-enabled your database using \sphinxcode{\sphinxupquote{CREATE EXTENSION postgis}}, you can update your database using the same functionality.

First, install the new software so it is available to the database.

Then, run the SQL to upgrade your PostGIS extension.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} To upgrade to 2.1.2}
\PYG{k}{ALTER} \PYG{n}{EXTENSION} \PYG{n}{postgis} \PYG{k}{UPDATE} \PYG{k}{TO} \PYG{l+s+s1}{\PYGZsq{}2.1.2\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Major PostGIS Upgrades}
\label{\detokenize{maintenance:major-postgis-upgrades}}
Major upgrades involve changes to the actual data format for the on-disk storage of geometry and geography data. As such, the data tables need to be re-written. The only way to achieve this is to dump (creating a neutral text-based output) and restore (writing the new table format to disk).

To upgrade, you will have to dump your data first, as discussed in {\hyperref[\detokenize{maintenance:backup}]{\sphinxcrossref{\DUrole{std,std-ref}{PostgreSQL Backup and Restore}}}}.


\subsubsection{With Data in Schemas}
\label{\detokenize{maintenance:with-data-in-schemas}}\begin{itemize}
\item {} 
Dump your data by schema.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}dump}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{compressed}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{=}\PYG{n}{yourschema}\PYG{o}{.}\PYG{n}{backup}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{schema}\PYG{o}{=}\PYG{n}{yourschema}
   \PYG{n}{yourdatabase}
\end{sphinxVerbatim}

\item {} 
Install the new version of the PostGIS software.

\item {} 
Create a new blank database, and enable PostGIS in it.

\item {} 
Load your data using pg\_restore.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}restore}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{compressed}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dbname}\PYG{o}{=}\PYG{n}{yournewdatabase}
  \PYG{n}{yourschema}\PYG{o}{.}\PYG{n}{backup}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{Without Data in Schemas}
\label{\detokenize{maintenance:without-data-in-schemas}}
In this case you have to dump the whole database, which means the dump file will contain PostGIS function and type signatures, and old ones at that. Before loading that file back into the new database, we strip out all the PostGIS-specific bits using a magic script from the PostGIS distribution.
\begin{itemize}
\item {} 
Dump your whole database, using the “compressed” backup format.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}dump}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{compressed}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{=}\PYG{n}{yourdatabase}\PYG{o}{.}\PYG{n}{backup} \PYG{n}{yourdatabase}
\end{sphinxVerbatim}

\item {} 
Install the new version of the PostGIS software.

\item {} 
Filter your database backup using the ./utils/postgis\_restore.pl script from the new version of PostGIS.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{postgis\PYGZus{}restore}\PYG{o}{.}\PYG{n}{pl} \PYG{n}{yourdatabase}\PYG{o}{.}\PYG{n}{backup} \PYG{o}{\PYGZgt{}} \PYG{n}{yourdatabase}\PYG{o}{.}\PYG{n}{sql}
\end{sphinxVerbatim}

\item {} 
Create a new blank database, and enable PostGIS in it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} New in PostGIS 2+ / PgSQL 9.1+}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Formal extensions replace hand loading sql files!}
\PYG{k}{CREATE} \PYG{n}{EXTENSION} \PYG{n}{postgis}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Load the filtered data back into the new databaes

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psql}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54321}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{=}\PYG{n}{yourdatabase}\PYG{o}{.}\PYG{n}{sql}
   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dbname}\PYG{o}{=}\PYG{n}{yournewdatabase}
\end{sphinxVerbatim}

\end{itemize}

You should now have an upgraded database ready to use.


\subsubsection{Default SRID}
\label{\detokenize{maintenance:default-srid}}
For PostGIS 0.X and 1.X, the SRID assigned to geometries created without specifying an SRID was -1.

For PostGIS 2.X, the SRID assigned to geometries created without specifying an SRID is 0.

This is only important to client applications calling the ST\_SRID() function and testing the result.


\subsubsection{SRID Range Limits}
\label{\detokenize{maintenance:srid-range-limits}}
In order to fit the SRID number into a limited address range in the PostgreSQL system tables, the range of values PostGIS 2.X supports for SRID numbers is actually smaller than the range supported in 1.X.

Legal user-defined SRIDs in PostGIS 2.X are from 1 to 998999. The top 10000 SRIDs are retained by PostGIS for internal use.


\chapter{Appendix A: PostGIS Functions}
\label{\detokenize{postgis-functions:appendix-a-postgis-functions}}\label{\detokenize{postgis-functions:postgis-functions}}\label{\detokenize{postgis-functions::doc}}

\section{Constructors}
\label{\detokenize{postgis-functions:constructors}}\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_MakePoint(Longitude, Latitude)}}}] \leavevmode
Returns a new point. Note the order of the coordinates (longitude then latitude).

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_GeomFromText(WellKnownText, srid)}}}] \leavevmode
Returns a new geometry from a standard WKT string and srid.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_SetSRID(geometry, srid)}}}] \leavevmode
Updates the srid on a geometry.  Returns the same geometry.  This does not alter the coordinates of the geometry, it just updates the srid. This function is useful for conditioning geometries created without an srid.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Expand(geometry, Radius)}}}] \leavevmode
Returns a new geometry that is an expanded bounding box of the input geometry.  This function is useful for creating envelopes for use in indexed searches.

\end{description}


\section{Outputs}
\label{\detokenize{postgis-functions:outputs}}\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsText(geometry)}}}] \leavevmode
Returns a geometry in a human-readable text format.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGML(geometry)}}}] \leavevmode
Returns a geometry in standard OGC {\hyperref[\detokenize{glossary:term-gml}]{\sphinxtermref{\DUrole{xref,std,std-term}{GML}}}} format.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_AsGeoJSON(geometry)}}}] \leavevmode
Returns a geometry to a standard \sphinxhref{http://geojson.org}{GeoJSON} format.

\end{description}


\section{Measurements}
\label{\detokenize{postgis-functions:measurements}}\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Area(geometry)}}}] \leavevmode
Returns the area of the geometry in the units of the spatial reference system.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Length(geometry)}}}] \leavevmode
Returns the length of the geometry in the units of the spatial reference system.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Perimeter(geometry)}}}] \leavevmode
Returns the perimeter of the geometry in the units of the spatial reference system.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_NumPoints(linestring)}}}] \leavevmode
Returns the number of vertices in a linestring.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_NumRings(polygon)}}}] \leavevmode
Returns the number of rings in a polygon.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_NumGeometries(geometry)}}}] \leavevmode
Returns the number of geometries in a geometry collection.

\end{description}


\section{Relationships}
\label{\detokenize{postgis-functions:relationships}}\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Distance(geometry, geometry)}}}] \leavevmode
Returns the distance between two geometries in the units of the spatial reference system.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_DWithin(geometry, geometry, radius)}}}] \leavevmode
Returns true if the geometries are within the radius distance of one another, otherwise false.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Intersects(geometry, geometry)}}}] \leavevmode
Returns true if the geometries are not disjoint, otherwise false.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Contains(geometry, geometry)}}}] \leavevmode
Returns true if the first geometry fully contains the second geometry, otherwise false.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ST\_Crosses(geometry, geometry)}}}] \leavevmode
Returns true if a line or polygon boundary crosses another line or polygon boundary, otherwise false.

\end{description}


\chapter{Appendix B: Glossary}
\label{\detokenize{glossary:appendix-b-glossary}}\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary::doc}}\begin{description}
\item[{CRS\index{CRS@\spxentry{CRS}|spxpagem}\phantomsection\label{\detokenize{glossary:term-crs}}}] \leavevmode
A “coordinate reference system”. The combination of a geographic coordinate system and a projected coordinate system.

\item[{GDAL\index{GDAL@\spxentry{GDAL}|spxpagem}\phantomsection\label{\detokenize{glossary:term-gdal}}}] \leavevmode
\sphinxhref{http://gdal.org}{Geospatial Data Abstraction Library}, pronounced “GOO-duhl”, an open source raster access library with support for a large number of formats, used widely in both open source and proprietary software.

\item[{GeoJSON\index{GeoJSON@\spxentry{GeoJSON}|spxpagem}\phantomsection\label{\detokenize{glossary:term-geojson}}}] \leavevmode
“Javascript Object Notation”, a text format that is very fast to parse in Javascript virtual machines. In spatial, the extended specification for \sphinxhref{http://geojson.org}{GeoJSON} is commonly used.

\item[{GIS\index{GIS@\spxentry{GIS}|spxpagem}\phantomsection\label{\detokenize{glossary:term-gis}}}] \leavevmode
\sphinxhref{http://en.wikipedia.org/wiki/Geographic\_information\_system}{Geographic information system} or geographical information system captures, stores, analyzes, manages, and presents data that is linked to location.

\item[{GML\index{GML@\spxentry{GML}|spxpagem}\phantomsection\label{\detokenize{glossary:term-gml}}}] \leavevmode
\sphinxhref{http://www.opengeospatial.org/standards/gml}{Geography Markup Language}.  GML is the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} standard XML format for representing spatial feature information.

\item[{JSON\index{JSON@\spxentry{JSON}|spxpagem}\phantomsection\label{\detokenize{glossary:term-json}}}] \leavevmode
“\sphinxhref{http://en.wikipedia.org/wiki/JSON}{Javascript Object Notation}”, a text format that is very fast to parse in Javascript virtual machines. In spatial, the extended specification for \sphinxhref{http://geojson.org}{GeoJSON} is commonly used.

\item[{JSTL\index{JSTL@\spxentry{JSTL}|spxpagem}\phantomsection\label{\detokenize{glossary:term-jstl}}}] \leavevmode
“JavaServer Page Template Library”, a tag library for {\hyperref[\detokenize{glossary:term-jsp}]{\sphinxtermref{\DUrole{xref,std,std-term}{JSP}}}} that encapsulates many of the standard functions handled in JSP (database queries, iteration, conditionals) into a terse syntax.

\item[{JSP\index{JSP@\spxentry{JSP}|spxpagem}\phantomsection\label{\detokenize{glossary:term-jsp}}}] \leavevmode
“JavaServer Pages” a scripting system for Java server applications that allows the interleaving of markup and Java procedural code.

\item[{KML\index{KML@\spxentry{KML}|spxpagem}\phantomsection\label{\detokenize{glossary:term-kml}}}] \leavevmode
“Keyhole Markup Language”, the spatial XML format used by Google Earth. Google Earth was originally written by a company named “Keyhole”, hence the (now obscure) reference in the name.

\item[{OGC\index{OGC@\spxentry{OGC}|spxpagem}\phantomsection\label{\detokenize{glossary:term-ogc}}}] \leavevmode
The \sphinxhref{http://opengeospatial.org/}{Open Geospatial Consortium} (OGC) is a standards organization that develops specifications for geospatial services.

\item[{OSGeo\index{OSGeo@\spxentry{OSGeo}|spxpagem}\phantomsection\label{\detokenize{glossary:term-osgeo}}}] \leavevmode
The \sphinxhref{http://osgeo.org}{Open Source Geospatial Foundation} (OSGeo) is a non-profit foundation dedicated to the promotion and support of open source geospatial software.

\item[{SFSQL\index{SFSQL@\spxentry{SFSQL}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sfsql}}}] \leavevmode
The \sphinxhref{http://www.opengeospatial.org/standards/sfs}{Simple Features for SQL} (SFSQL) specification from the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} defines the types and functions that make up a standard spatial database.

\item[{SLD\index{SLD@\spxentry{SLD}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sld}}}] \leavevmode
The \sphinxhref{http://www.opengeospatial.org/standards/sld}{Styled Layer Descriptor} (SLD) specification from the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} defines an format for describing cartographic rendering of vector features.

\item[{SRID\index{SRID@\spxentry{SRID}|spxpagem}\phantomsection\label{\detokenize{glossary:term-srid}}}] \leavevmode
“Spatial reference ID” a unique number assigned to a particular “coordinate reference system”. The PostGIS table \sphinxstylestrong{spatial\_ref\_sys} contains a large collection of well-known srid values and text representations of the coordinate reference systems.

\item[{SQL\index{SQL@\spxentry{SQL}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sql}}}] \leavevmode
“\sphinxhref{http://en.wikipedia.org/wiki/SQL}{Structured query language}” is the standard means for querying relational databases.

\item[{SQL/MM\index{SQL/MM@\spxentry{SQL/MM}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sql-mm}}}] \leavevmode
\sphinxhref{http://www.fer.hr/\_download/repository/SQLMM\_Spatial-\_The\_Standard\_to\_Manage\_Spatial\_Data\_in\_Relational\_Database\_Systems.pdf}{SQL Multimedia}; includes several sections on extended types, including a substantial section on spatial types.

\item[{SVG\index{SVG@\spxentry{SVG}|spxpagem}\phantomsection\label{\detokenize{glossary:term-svg}}}] \leavevmode
“\sphinxhref{http://en.wikipedia.org/wiki/Scalable\_Vector\_Graphics}{Scalable vector graphics}” is a family of specifications of an XML-based file format for describing two-dimensional vector graphics, both static and dynamic (i.e. interactive or animated).

\item[{WFS\index{WFS@\spxentry{WFS}|spxpagem}\phantomsection\label{\detokenize{glossary:term-wfs}}}] \leavevmode
The \sphinxhref{http://www.opengeospatial.org/standards/wfs}{Web Feature Service} (WFS) specification from the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} defines an interface for reading and writing geographic features across the web.

\item[{WMS\index{WMS@\spxentry{WMS}|spxpagem}\phantomsection\label{\detokenize{glossary:term-wms}}}] \leavevmode
The \sphinxhref{http://www.opengeospatial.org/standards/wms}{Web Map Service} (WMS) specification from the {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} defines an interface for requesting rendered map images across the web.

\item[{WKB\index{WKB@\spxentry{WKB}|spxpagem}\phantomsection\label{\detokenize{glossary:term-wkb}}}] \leavevmode
“Well-known binary”. Refers to the binary representation of geometries described in the Simple Features for SQL specification ({\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}}).

\item[{WKT\index{WKT@\spxentry{WKT}|spxpagem}\phantomsection\label{\detokenize{glossary:term-wkt}}}] \leavevmode
“\sphinxhref{http://en.wikipedia.org/wiki/Well-known\_text}{Well-known text}”. Can refer either to the text representation of geometries, with strings starting “POINT”, “LINESTRING”, “POLYGON”, etc. Or can refer to the text representation of a {\hyperref[\detokenize{glossary:term-crs}]{\sphinxtermref{\DUrole{xref,std,std-term}{CRS}}}}, with strings starting “PROJCS”, “GEOGCS”, etc.  Well-known text representations are {\hyperref[\detokenize{glossary:term-ogc}]{\sphinxtermref{\DUrole{xref,std,std-term}{OGC}}}} standards, but do not have their own specification documents. The first descriptions of WKT (for geometries and for CRS) appeared in the {\hyperref[\detokenize{glossary:term-sfsql}]{\sphinxtermref{\DUrole{xref,std,std-term}{SFSQL}}}} 1.0 specification.

\end{description}


\chapter{Appendix C: License}
\label{\detokenize{license:appendix-c-license}}\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
This work is licensed under the Creative Commons Attribution-Share Alike, United States License. To view a copy of this license, visit \sphinxurl{http://creativecommons.org/licenses/by-sa/3.0/us/} or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Our attribution requirement is that you retain the visible copyright notices in all materials.



\renewcommand{\indexname}{Index}
\printindex
\end{document}